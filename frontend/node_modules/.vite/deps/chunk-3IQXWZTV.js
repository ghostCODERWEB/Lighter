import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-EWTE5DHJ.js";

// .api/apis/zklighter/node_modules/@jsdevtools/ono/esm/isomorphic.browser.js
var format, addInspectMethod;
var init_isomorphic_browser = __esm({
  ".api/apis/zklighter/node_modules/@jsdevtools/ono/esm/isomorphic.browser.js"() {
    format = false;
    addInspectMethod = false;
  }
});

// .api/apis/zklighter/node_modules/@jsdevtools/ono/esm/stack.js
function isLazyStack(stackProp) {
  return Boolean(stackProp && stackProp.configurable && typeof stackProp.get === "function");
}
function isWritableStack(stackProp) {
  return Boolean(
    // If there is no stack property, then it's writable, since assigning it will create it
    !stackProp || stackProp.writable || typeof stackProp.set === "function"
  );
}
function joinStacks(newError, originalError) {
  let newStack = popStack(newError.stack);
  let originalStack = originalError ? originalError.stack : void 0;
  if (newStack && originalStack) {
    return newStack + "\n\n" + originalStack;
  } else {
    return newStack || originalStack;
  }
}
function lazyJoinStacks(lazyStack, newError, originalError) {
  if (originalError) {
    Object.defineProperty(newError, "stack", {
      get: () => {
        let newStack = lazyStack.get.apply(newError);
        return joinStacks({ stack: newStack }, originalError);
      },
      enumerable: false,
      configurable: true
    });
  } else {
    lazyPopStack(newError, lazyStack);
  }
}
function popStack(stack) {
  if (stack) {
    let lines = stack.split(newline);
    let onoStart;
    for (let i = 0; i < lines.length; i++) {
      let line = lines[i];
      if (onoCall.test(line)) {
        if (onoStart === void 0) {
          onoStart = i;
        }
      } else if (onoStart !== void 0) {
        lines.splice(onoStart, i - onoStart);
        break;
      }
    }
    if (lines.length > 0) {
      return lines.join("\n");
    }
  }
  return stack;
}
function lazyPopStack(error, lazyStack) {
  Object.defineProperty(error, "stack", {
    get: () => popStack(lazyStack.get.apply(error)),
    enumerable: false,
    configurable: true
  });
}
var newline, onoCall;
var init_stack = __esm({
  ".api/apis/zklighter/node_modules/@jsdevtools/ono/esm/stack.js"() {
    newline = /\r?\n/;
    onoCall = /\bono[ @]/;
  }
});

// .api/apis/zklighter/node_modules/@jsdevtools/ono/esm/to-json.js
function toJSON() {
  let pojo = {};
  let error = this;
  for (let key of getDeepKeys(error)) {
    if (typeof key === "string") {
      let value = error[key];
      let type = typeof value;
      if (!nonJsonTypes.includes(type)) {
        pojo[key] = value;
      }
    }
  }
  return pojo;
}
function getDeepKeys(obj, omit = []) {
  let keys = [];
  while (obj && obj !== objectPrototype) {
    keys = keys.concat(Object.getOwnPropertyNames(obj), Object.getOwnPropertySymbols(obj));
    obj = Object.getPrototypeOf(obj);
  }
  let uniqueKeys = new Set(keys);
  for (let key of omit.concat(protectedProps)) {
    uniqueKeys.delete(key);
  }
  return uniqueKeys;
}
var nonJsonTypes, protectedProps, objectPrototype;
var init_to_json = __esm({
  ".api/apis/zklighter/node_modules/@jsdevtools/ono/esm/to-json.js"() {
    nonJsonTypes = ["function", "symbol", "undefined"];
    protectedProps = ["constructor", "prototype", "__proto__"];
    objectPrototype = Object.getPrototypeOf({});
  }
});

// .api/apis/zklighter/node_modules/@jsdevtools/ono/esm/extend-error.js
function extendError(error, originalError, props) {
  let onoError = error;
  extendStack(onoError, originalError);
  if (originalError && typeof originalError === "object") {
    mergeErrors(onoError, originalError);
  }
  onoError.toJSON = toJSON;
  if (addInspectMethod) {
    addInspectMethod(onoError);
  }
  if (props && typeof props === "object") {
    Object.assign(onoError, props);
  }
  return onoError;
}
function extendStack(newError, originalError) {
  let stackProp = Object.getOwnPropertyDescriptor(newError, "stack");
  if (isLazyStack(stackProp)) {
    lazyJoinStacks(stackProp, newError, originalError);
  } else if (isWritableStack(stackProp)) {
    newError.stack = joinStacks(newError, originalError);
  }
}
function mergeErrors(newError, originalError) {
  let keys = getDeepKeys(originalError, protectedProps2);
  let _newError = newError;
  let _originalError = originalError;
  for (let key of keys) {
    if (_newError[key] === void 0) {
      try {
        _newError[key] = _originalError[key];
      } catch (e) {
      }
    }
  }
}
var protectedProps2;
var init_extend_error = __esm({
  ".api/apis/zklighter/node_modules/@jsdevtools/ono/esm/extend-error.js"() {
    init_isomorphic_browser();
    init_stack();
    init_to_json();
    protectedProps2 = ["name", "message", "stack"];
  }
});

// .api/apis/zklighter/node_modules/@jsdevtools/ono/esm/normalize.js
function normalizeOptions(options) {
  options = options || {};
  return {
    concatMessages: options.concatMessages === void 0 ? true : Boolean(options.concatMessages),
    format: options.format === void 0 ? format : typeof options.format === "function" ? options.format : false
  };
}
function normalizeArgs(args, options) {
  let originalError;
  let props;
  let formatArgs;
  let message = "";
  if (typeof args[0] === "string") {
    formatArgs = args;
  } else if (typeof args[1] === "string") {
    if (args[0] instanceof Error) {
      originalError = args[0];
    } else {
      props = args[0];
    }
    formatArgs = args.slice(1);
  } else {
    originalError = args[0];
    props = args[1];
    formatArgs = args.slice(2);
  }
  if (formatArgs.length > 0) {
    if (options.format) {
      message = options.format.apply(void 0, formatArgs);
    } else {
      message = formatArgs.join(" ");
    }
  }
  if (options.concatMessages && originalError && originalError.message) {
    message += (message ? " \n" : "") + originalError.message;
  }
  return { originalError, props, message };
}
var init_normalize = __esm({
  ".api/apis/zklighter/node_modules/@jsdevtools/ono/esm/normalize.js"() {
    init_isomorphic_browser();
  }
});

// .api/apis/zklighter/node_modules/@jsdevtools/ono/esm/constructor.js
function Ono(ErrorConstructor, options) {
  options = normalizeOptions(options);
  function ono2(...args) {
    let { originalError, props, message } = normalizeArgs(args, options);
    let newError = new ErrorConstructor(message);
    return extendError(newError, originalError, props);
  }
  ono2[Symbol.species] = ErrorConstructor;
  return ono2;
}
var constructor;
var init_constructor = __esm({
  ".api/apis/zklighter/node_modules/@jsdevtools/ono/esm/constructor.js"() {
    init_extend_error();
    init_normalize();
    init_to_json();
    constructor = Ono;
    Ono.toJSON = function toJSON2(error) {
      return toJSON.call(error);
    };
    Ono.extend = function extend(error, originalError, props) {
      if (props || originalError instanceof Error) {
        return extendError(error, originalError, props);
      } else if (originalError) {
        return extendError(error, void 0, originalError);
      } else {
        return extendError(error);
      }
    };
  }
});

// .api/apis/zklighter/node_modules/@jsdevtools/ono/esm/singleton.js
function ono(...args) {
  let originalError = args[0];
  if (typeof originalError === "object" && typeof originalError.name === "string") {
    for (let typedOno of Object.values(onoMap)) {
      if (typeof typedOno === "function" && typedOno.name === "ono") {
        let species = typedOno[Symbol.species];
        if (species && species !== Error && (originalError instanceof species || originalError.name === species.name)) {
          return typedOno.apply(void 0, args);
        }
      }
    }
  }
  return ono.error.apply(void 0, args);
}
var singleton, onoMap;
var init_singleton = __esm({
  ".api/apis/zklighter/node_modules/@jsdevtools/ono/esm/singleton.js"() {
    init_constructor();
    singleton = ono;
    ono.error = new constructor(Error);
    ono.eval = new constructor(EvalError);
    ono.range = new constructor(RangeError);
    ono.reference = new constructor(ReferenceError);
    ono.syntax = new constructor(SyntaxError);
    ono.type = new constructor(TypeError);
    ono.uri = new constructor(URIError);
    onoMap = ono;
  }
});

// browser-external:util
var require_util = __commonJS({
  "browser-external:util"(exports, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "util" has been externalized for browser compatibility. Cannot access "util.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// .api/apis/zklighter/node_modules/@jsdevtools/ono/esm/types.js
var import_util;
var init_types = __esm({
  ".api/apis/zklighter/node_modules/@jsdevtools/ono/esm/types.js"() {
    import_util = __toESM(require_util());
  }
});

// .api/apis/zklighter/node_modules/@jsdevtools/ono/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  Ono: () => constructor,
  default: () => esm_default,
  ono: () => singleton
});
var esm_default;
var init_esm = __esm({
  ".api/apis/zklighter/node_modules/@jsdevtools/ono/esm/index.js"() {
    init_singleton();
    init_constructor();
    init_types();
    esm_default = singleton;
    if (typeof module === "object" && typeof module.exports === "object") {
      module.exports = Object.assign(module.exports.default, module.exports);
    }
  }
});

// .api/apis/zklighter/node_modules/call-me-maybe/src/next.js
var require_next = __commonJS({
  ".api/apis/zklighter/node_modules/call-me-maybe/src/next.js"(exports, module2) {
    "use strict";
    function makeNext() {
      if (typeof process === "object" && typeof process.nextTick === "function") {
        return process.nextTick;
      } else if (typeof setImmediate === "function") {
        return setImmediate;
      } else {
        return function next(f) {
          setTimeout(f, 0);
        };
      }
    }
    module2.exports = makeNext();
  }
});

// .api/apis/zklighter/node_modules/call-me-maybe/src/maybe.js
var require_maybe = __commonJS({
  ".api/apis/zklighter/node_modules/call-me-maybe/src/maybe.js"(exports, module2) {
    "use strict";
    var next = require_next();
    module2.exports = function maybe(cb, promise) {
      if (cb) {
        promise.then(function(result) {
          next(function() {
            cb(null, result);
          });
        }, function(err) {
          next(function() {
            cb(err);
          });
        });
        return void 0;
      } else {
        return promise;
      }
    };
  }
});

// browser-external:url
var require_url = __commonJS({
  "browser-external:url"(exports, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "url" has been externalized for browser compatibility. Cannot access "url.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// .api/apis/zklighter/node_modules/@readme/json-schema-ref-parser/lib/util/url.js
var require_url2 = __commonJS({
  ".api/apis/zklighter/node_modules/@readme/json-schema-ref-parser/lib/util/url.js"(exports, module2) {
    var isWindows = /^win/.test(process.platform);
    var forwardSlashPattern = /\//g;
    var protocolPattern = /^(\w{2,}):\/\//i;
    var url = module2.exports;
    var jsonPointerSlash = /~1/g;
    var jsonPointerTilde = /~0/g;
    var urlEncodePatterns = [
      /\?/g,
      "%3F",
      /#/g,
      "%23"
    ];
    var urlDecodePatterns = [
      /%23/g,
      "#",
      /%24/g,
      "$",
      /%26/g,
      "&",
      /%2C/g,
      ",",
      /%40/g,
      "@"
    ];
    exports.parse = require_url().parse;
    exports.resolve = require_url().resolve;
    exports.cwd = function cwd() {
      if (process.browser) {
        return location.href;
      }
      const path = process.cwd();
      const lastChar = path.slice(-1);
      if (lastChar === "/" || lastChar === "\\") {
        return path;
      }
      return `${path}/`;
    };
    exports.getProtocol = function getProtocol(path) {
      const match2 = protocolPattern.exec(path);
      if (match2) {
        return match2[1].toLowerCase();
      }
    };
    exports.getExtension = function getExtension(path) {
      const lastDot = path.lastIndexOf(".");
      if (lastDot >= 0) {
        return url.stripQuery(path.substr(lastDot).toLowerCase());
      }
      return "";
    };
    exports.stripQuery = function stripQuery(path) {
      const queryIndex = path.indexOf("?");
      if (queryIndex >= 0) {
        path = path.substr(0, queryIndex);
      }
      return path;
    };
    exports.getHash = function getHash(path) {
      const hashIndex = path.indexOf("#");
      if (hashIndex >= 0) {
        return path.substr(hashIndex);
      }
      return "#";
    };
    exports.stripHash = function stripHash(path) {
      const hashIndex = path.indexOf("#");
      if (hashIndex >= 0) {
        return path.substr(0, hashIndex);
      }
      return path;
    };
    exports.isHttp = function isHttp(path) {
      const protocol = url.getProtocol(path);
      if (protocol === "http" || protocol === "https") {
        return true;
      } else if (protocol === void 0) {
        return process.browser;
      }
      return false;
    };
    exports.isFileSystemPath = function isFileSystemPath(path) {
      if (process.browser) {
        return false;
      }
      const protocol = url.getProtocol(path);
      return protocol === void 0 || protocol === "file";
    };
    exports.fromFileSystemPath = function fromFileSystemPath(path) {
      if (isWindows) {
        path = path.replace(/\\/g, "/");
      }
      path = encodeURI(path);
      for (let i = 0; i < urlEncodePatterns.length; i += 2) {
        path = path.replace(urlEncodePatterns[i], urlEncodePatterns[i + 1]);
      }
      return path;
    };
    exports.toFileSystemPath = function toFileSystemPath(path, keepFileProtocol) {
      path = decodeURI(path);
      for (let i = 0; i < urlDecodePatterns.length; i += 2) {
        path = path.replace(urlDecodePatterns[i], urlDecodePatterns[i + 1]);
      }
      let isFileUrl = path.substr(0, 7).toLowerCase() === "file://";
      if (isFileUrl) {
        path = path[7] === "/" ? path.substr(8) : path.substr(7);
        if (isWindows && path[1] === "/") {
          path = `${path[0]}:${path.substr(1)}`;
        }
        if (keepFileProtocol) {
          path = `file:///${path}`;
        } else {
          isFileUrl = false;
          path = isWindows ? path : `/${path}`;
        }
      }
      if (isWindows && !isFileUrl) {
        path = path.replace(forwardSlashPattern, "\\");
        if (path.substr(1, 2) === ":\\") {
          path = path[0].toUpperCase() + path.substr(1);
        }
      }
      return path;
    };
    exports.safePointerToPath = function safePointerToPath(pointer) {
      if (pointer.length <= 1 || pointer[0] !== "#" || pointer[1] !== "/") {
        return [];
      }
      return pointer.slice(2).split("/").map((value) => {
        return decodeURIComponent(value).replace(jsonPointerSlash, "/").replace(jsonPointerTilde, "~");
      });
    };
  }
});

// .api/apis/zklighter/node_modules/@readme/json-schema-ref-parser/lib/util/errors.js
var require_errors = __commonJS({
  ".api/apis/zklighter/node_modules/@readme/json-schema-ref-parser/lib/util/errors.js"(exports) {
    var { Ono: Ono2 } = (init_esm(), __toCommonJS(esm_exports));
    var { stripHash, toFileSystemPath } = require_url2();
    function setErrorName(err) {
      Object.defineProperty(err.prototype, "name", {
        value: err.name,
        enumerable: true
      });
    }
    var JSONParserError = class JSONParserError extends Error {
      constructor(message, source) {
        super();
        this.code = "EUNKNOWN";
        this.message = message;
        this.source = source;
        this.path = null;
        Ono2.extend(this);
      }
      get footprint() {
        return `${this.path}+${this.source}+${this.code}+${this.message}`;
      }
    };
    exports.JSONParserError = JSONParserError;
    setErrorName(JSONParserError);
    var JSONParserErrorGroup = class JSONParserErrorGroup2 extends Error {
      constructor(parser) {
        super();
        this.files = parser;
        this.message = `${this.errors.length} error${this.errors.length > 1 ? "s" : ""} occurred while reading '${toFileSystemPath(parser.$refs._root$Ref.path)}'`;
        Ono2.extend(this);
      }
      static getParserErrors(parser) {
        const errors = [];
        for (const $ref of Object.values(parser.$refs._$refs)) {
          if ($ref.errors) {
            errors.push(...$ref.errors);
          }
        }
        return errors;
      }
      get errors() {
        return JSONParserErrorGroup2.getParserErrors(this.files);
      }
    };
    exports.JSONParserErrorGroup = JSONParserErrorGroup;
    setErrorName(JSONParserErrorGroup);
    var ParserError = class ParserError extends JSONParserError {
      constructor(message, source) {
        super(`Error parsing ${source}: ${message}`, source);
        this.code = "EPARSER";
      }
    };
    exports.ParserError = ParserError;
    setErrorName(ParserError);
    var UnmatchedParserError = class UnmatchedParserError extends JSONParserError {
      constructor(source) {
        super(`Could not find parser for "${source}"`, source);
        this.code = "EUNMATCHEDPARSER";
      }
    };
    exports.UnmatchedParserError = UnmatchedParserError;
    setErrorName(UnmatchedParserError);
    var ResolverError = class ResolverError extends JSONParserError {
      constructor(ex, source) {
        super(ex.message || `Error reading file "${source}"`, source);
        this.code = "ERESOLVER";
        if ("code" in ex) {
          this.ioErrorCode = String(ex.code);
        }
      }
    };
    exports.ResolverError = ResolverError;
    setErrorName(ResolverError);
    var UnmatchedResolverError = class UnmatchedResolverError extends JSONParserError {
      constructor(source) {
        super(`Could not find resolver for "${source}"`, source);
        this.code = "EUNMATCHEDRESOLVER";
      }
    };
    exports.UnmatchedResolverError = UnmatchedResolverError;
    setErrorName(UnmatchedResolverError);
    var MissingPointerError = class MissingPointerError extends JSONParserError {
      constructor(token, path) {
        super(`Token "${token}" does not exist.`, stripHash(path));
        this.code = "EMISSINGPOINTER";
      }
    };
    exports.MissingPointerError = MissingPointerError;
    setErrorName(MissingPointerError);
    var InvalidPointerError = class InvalidPointerError extends JSONParserError {
      constructor(pointer, path) {
        super(`Invalid $ref pointer "${pointer}". Pointers must begin with "#/"`, stripHash(path));
        this.code = "EINVALIDPOINTER";
      }
    };
    exports.InvalidPointerError = InvalidPointerError;
    setErrorName(InvalidPointerError);
    exports.isHandledError = function(err) {
      return err instanceof JSONParserError || err instanceof JSONParserErrorGroup;
    };
    exports.normalizeError = function(err) {
      if (err.path === null) {
        err.path = [];
      }
      return err;
    };
  }
});

// .api/apis/zklighter/node_modules/@readme/json-schema-ref-parser/lib/pointer.js
var require_pointer = __commonJS({
  ".api/apis/zklighter/node_modules/@readme/json-schema-ref-parser/lib/pointer.js"(exports, module2) {
    var $Ref = require_ref();
    var { JSONParserError, InvalidPointerError, MissingPointerError, isHandledError } = require_errors();
    var url = require_url2();
    var slashes = /\//g;
    var tildes = /~/g;
    var escapedSlash = /~1/g;
    var escapedTilde = /~0/g;
    module2.exports = Pointer;
    function Pointer($ref, path, friendlyPath) {
      this.$ref = $ref;
      this.path = path;
      this.originalPath = friendlyPath || path;
      this.value = void 0;
      this.circular = false;
      this.indirections = 0;
    }
    Pointer.prototype.resolve = function(obj, options, pathFromRoot) {
      const tokens = Pointer.parse(this.path, this.originalPath);
      this.value = unwrapOrThrow(obj);
      for (let i = 0; i < tokens.length; i++) {
        if (resolveIf$Ref(this, options)) {
          this.path = Pointer.join(this.path, tokens.slice(i));
        }
        if (typeof this.value === "object" && this.value !== null && "$ref" in this.value) {
          return this;
        }
        const token = tokens[i];
        if (this.value[token] === void 0 || this.value[token] === null) {
          this.value = null;
          throw new MissingPointerError(token, this.originalPath);
        } else {
          this.value = this.value[token];
        }
      }
      if (!this.value || this.value.$ref && url.resolve(this.path, this.value.$ref) !== pathFromRoot) {
        resolveIf$Ref(this, options);
      }
      return this;
    };
    Pointer.prototype.set = function(obj, value, options) {
      const tokens = Pointer.parse(this.path);
      let token;
      if (tokens.length === 0) {
        this.value = value;
        return value;
      }
      this.value = unwrapOrThrow(obj);
      for (let i = 0; i < tokens.length - 1; i++) {
        resolveIf$Ref(this, options);
        token = tokens[i];
        if (this.value && this.value[token] !== void 0) {
          this.value = this.value[token];
        } else {
          this.value = setValue(this, token, {});
        }
      }
      resolveIf$Ref(this, options);
      token = tokens[tokens.length - 1];
      setValue(this, token, value);
      return obj;
    };
    Pointer.parse = function(path, originalPath) {
      let pointer = url.getHash(path).substr(1);
      if (!pointer) {
        return [];
      }
      pointer = pointer.split("/");
      for (let i = 0; i < pointer.length; i++) {
        pointer[i] = decodeURIComponent(pointer[i].replace(escapedSlash, "/").replace(escapedTilde, "~"));
      }
      if (pointer[0] !== "") {
        throw new InvalidPointerError(pointer, originalPath === void 0 ? path : originalPath);
      }
      return pointer.slice(1);
    };
    Pointer.join = function(base, tokens) {
      if (base.indexOf("#") === -1) {
        base += "#";
      }
      tokens = Array.isArray(tokens) ? tokens : [tokens];
      for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i];
        base += `/${encodeURIComponent(token.replace(tildes, "~0").replace(slashes, "~1"))}`;
      }
      return base;
    };
    function resolveIf$Ref(pointer, options) {
      if ($Ref.isAllowed$Ref(pointer.value, options)) {
        const $refPath = url.resolve(pointer.path, pointer.value.$ref);
        if ($refPath === pointer.path) {
          pointer.circular = true;
        } else {
          const resolved = pointer.$ref.$refs._resolve($refPath, pointer.path, options);
          if (resolved === null) {
            return false;
          }
          pointer.indirections += resolved.indirections + 1;
          if ($Ref.isExtended$Ref(pointer.value)) {
            pointer.value = $Ref.dereference(pointer.value, resolved.value);
            return false;
          }
          pointer.$ref = resolved.$ref;
          pointer.path = resolved.path;
          pointer.value = resolved.value;
          return true;
        }
      }
    }
    function setValue(pointer, token, value) {
      if (pointer.value && typeof pointer.value === "object") {
        if (token === "-" && Array.isArray(pointer.value)) {
          pointer.value.push(value);
        } else {
          pointer.value[token] = value;
        }
      } else {
        throw new JSONParserError(
          `Error assigning $ref pointer "${pointer.path}". 
Cannot set "${token}" of a non-object.`
        );
      }
      return value;
    }
    function unwrapOrThrow(value) {
      if (isHandledError(value)) {
        throw value;
      }
      return value;
    }
  }
});

// .api/apis/zklighter/node_modules/@readme/json-schema-ref-parser/lib/ref.js
var require_ref = __commonJS({
  ".api/apis/zklighter/node_modules/@readme/json-schema-ref-parser/lib/ref.js"(exports, module2) {
    module2.exports = $Ref;
    var Pointer = require_pointer();
    var { InvalidPointerError, isHandledError, normalizeError } = require_errors();
    var { safePointerToPath, stripHash, getHash } = require_url2();
    function $Ref() {
      this.path = void 0;
      this.value = void 0;
      this.$refs = void 0;
      this.pathType = void 0;
      this.errors = void 0;
    }
    $Ref.prototype.addError = function(err) {
      if (this.errors === void 0) {
        this.errors = [];
      }
      const existingErrors = this.errors.map(({ footprint }) => footprint);
      if (Array.isArray(err.errors)) {
        this.errors.push(...err.errors.map(normalizeError).filter(({ footprint }) => !existingErrors.includes(footprint)));
      } else if (!existingErrors.includes(err.footprint)) {
        this.errors.push(normalizeError(err));
      }
    };
    $Ref.prototype.exists = function(path, options) {
      try {
        this.resolve(path, options);
        return true;
      } catch (e) {
        return false;
      }
    };
    $Ref.prototype.get = function(path, options) {
      return this.resolve(path, options).value;
    };
    $Ref.prototype.resolve = function(path, options, friendlyPath, pathFromRoot) {
      const pointer = new Pointer(this, path, friendlyPath);
      try {
        return pointer.resolve(this.value, options, pathFromRoot);
      } catch (err) {
        if (!options || !options.continueOnError || !isHandledError(err)) {
          throw err;
        }
        if (err.path === null) {
          err.path = safePointerToPath(getHash(pathFromRoot));
        }
        if (err instanceof InvalidPointerError) {
          err.source = stripHash(pathFromRoot);
        }
        this.addError(err);
        return null;
      }
    };
    $Ref.prototype.set = function(path, value) {
      const pointer = new Pointer(this, path);
      this.value = pointer.set(this.value, value);
    };
    $Ref.is$Ref = function(value) {
      return value && typeof value === "object" && typeof value.$ref === "string" && value.$ref.length > 0;
    };
    $Ref.isExternal$Ref = function(value) {
      return $Ref.is$Ref(value) && value.$ref[0] !== "#";
    };
    $Ref.isAllowed$Ref = function(value, options) {
      if ($Ref.is$Ref(value)) {
        if (value.$ref.substr(0, 2) === "#/" || value.$ref === "#") {
          return true;
        } else if (value.$ref[0] !== "#" && (!options || options.resolve.external)) {
          return true;
        }
      }
    };
    $Ref.isExtended$Ref = function(value) {
      return $Ref.is$Ref(value) && Object.keys(value).length > 1;
    };
    $Ref.dereference = function($ref, resolvedValue) {
      if (resolvedValue && typeof resolvedValue === "object" && $Ref.isExtended$Ref($ref)) {
        const merged = {};
        for (const key of Object.keys($ref)) {
          if (key !== "$ref") {
            merged[key] = $ref[key];
          }
        }
        for (const key of Object.keys(resolvedValue)) {
          if (!(key in merged)) {
            merged[key] = resolvedValue[key];
          }
        }
        return merged;
      }
      return resolvedValue;
    };
  }
});

// .api/apis/zklighter/node_modules/@readme/json-schema-ref-parser/lib/bundle.js
var require_bundle = __commonJS({
  ".api/apis/zklighter/node_modules/@readme/json-schema-ref-parser/lib/bundle.js"(exports, module2) {
    var $Ref = require_ref();
    var Pointer = require_pointer();
    var url = require_url2();
    module2.exports = function bundle(parser, options) {
      const inventory = [];
      crawl(parser, "schema", `${parser.$refs._root$Ref.path}#`, "#", 0, inventory, parser.$refs, options);
      remap(inventory);
    };
    function crawl(parent, key, path, pathFromRoot, indirections, inventory, $refs, options) {
      const obj = key === null ? parent : parent[key];
      if (obj && typeof obj === "object" && !ArrayBuffer.isView(obj)) {
        if ($Ref.isAllowed$Ref(obj)) {
          inventory$Ref(parent, key, path, pathFromRoot, indirections, inventory, $refs, options);
        } else {
          const keys = Object.keys(obj).sort((a, b) => {
            if (a === "definitions") {
              return -1;
            } else if (b === "definitions") {
              return 1;
            }
            return a.length - b.length;
          });
          for (const key2 of keys) {
            const keyPath = Pointer.join(path, key2);
            const keyPathFromRoot = Pointer.join(pathFromRoot, key2);
            const value = obj[key2];
            if ($Ref.isAllowed$Ref(value)) {
              inventory$Ref(obj, key2, path, keyPathFromRoot, indirections, inventory, $refs, options);
            } else {
              crawl(obj, key2, keyPath, keyPathFromRoot, indirections, inventory, $refs, options);
            }
          }
        }
      }
    }
    function inventory$Ref($refParent, $refKey, path, pathFromRoot, indirections, inventory, $refs, options) {
      const $ref = $refKey === null ? $refParent : $refParent[$refKey];
      const $refPath = url.resolve(path, $ref.$ref);
      const pointer = $refs._resolve($refPath, pathFromRoot, options);
      if (pointer === null) {
        return;
      }
      const depth = Pointer.parse(pathFromRoot).length;
      const file = url.stripHash(pointer.path);
      const hash = url.getHash(pointer.path);
      const external = file !== $refs._root$Ref.path;
      const extended = $Ref.isExtended$Ref($ref);
      indirections += pointer.indirections;
      const existingEntry = findInInventory(inventory, $refParent, $refKey);
      if (existingEntry) {
        if (depth < existingEntry.depth || indirections < existingEntry.indirections) {
          removeFromInventory(inventory, existingEntry);
        } else {
          return;
        }
      }
      inventory.push({
        $ref,
        // The JSON Reference (e.g. {$ref: string})
        parent: $refParent,
        // The object that contains this $ref pointer
        key: $refKey,
        // The key in `parent` that is the $ref pointer
        pathFromRoot,
        // The path to the $ref pointer, from the JSON Schema root
        depth,
        // How far from the JSON Schema root is this $ref pointer?
        file,
        // The file that the $ref pointer resolves to
        hash,
        // The hash within `file` that the $ref pointer resolves to
        value: pointer.value,
        // The resolved value of the $ref pointer
        circular: pointer.circular,
        // Is this $ref pointer DIRECTLY circular? (i.e. it references itself)
        extended,
        // Does this $ref extend its resolved value? (i.e. it has extra properties, in addition to "$ref")
        external,
        // Does this $ref pointer point to a file other than the main JSON Schema file?
        indirections
        // The number of indirect references that were traversed to resolve the value
      });
      if (!existingEntry) {
        crawl(pointer.value, null, pointer.path, pathFromRoot, indirections + 1, inventory, $refs, options);
      }
    }
    function remap(inventory) {
      inventory.sort((a, b) => {
        if (a.file !== b.file) {
          return a.file < b.file ? -1 : 1;
        } else if (a.hash !== b.hash) {
          return a.hash < b.hash ? -1 : 1;
        } else if (a.circular !== b.circular) {
          return a.circular ? -1 : 1;
        } else if (a.extended !== b.extended) {
          return a.extended ? 1 : -1;
        } else if (a.indirections !== b.indirections) {
          return a.indirections - b.indirections;
        } else if (a.depth !== b.depth) {
          return a.depth - b.depth;
        }
        const aDefinitionsIndex = a.pathFromRoot.lastIndexOf("/definitions");
        const bDefinitionsIndex = b.pathFromRoot.lastIndexOf("/definitions");
        if (aDefinitionsIndex !== bDefinitionsIndex) {
          return bDefinitionsIndex - aDefinitionsIndex;
        }
        return a.pathFromRoot.length - b.pathFromRoot.length;
      });
      let file;
      let hash;
      let pathFromRoot;
      for (const entry of inventory) {
        if (!entry.external) {
          entry.$ref.$ref = entry.hash;
        } else if (entry.file === file && entry.hash === hash) {
          entry.$ref.$ref = pathFromRoot;
        } else if (entry.file === file && entry.hash.indexOf(`${hash}/`) === 0) {
          entry.$ref.$ref = Pointer.join(pathFromRoot, Pointer.parse(entry.hash.replace(hash, "#")));
        } else {
          file = entry.file;
          hash = entry.hash;
          pathFromRoot = entry.pathFromRoot;
          entry.parent[entry.key] = $Ref.dereference(entry.$ref, entry.value);
          entry.$ref = entry.parent[entry.key];
          if (entry.circular) {
            entry.$ref.$ref = entry.pathFromRoot;
          }
        }
      }
    }
    function findInInventory(inventory, $refParent, $refKey) {
      for (let i = 0; i < inventory.length; i++) {
        const existingEntry = inventory[i];
        if (existingEntry.parent === $refParent && existingEntry.key === $refKey) {
          return existingEntry;
        }
      }
    }
    function removeFromInventory(inventory, entry) {
      const index = inventory.indexOf(entry);
      inventory.splice(index, 1);
    }
  }
});

// .api/apis/zklighter/node_modules/@readme/json-schema-ref-parser/lib/dereference.js
var require_dereference = __commonJS({
  ".api/apis/zklighter/node_modules/@readme/json-schema-ref-parser/lib/dereference.js"(exports, module2) {
    var { ono: ono2 } = (init_esm(), __toCommonJS(esm_exports));
    var Pointer = require_pointer();
    var $Ref = require_ref();
    var { InvalidPointerError } = require_errors();
    var url = require_url2();
    module2.exports = function dereference(parser, options) {
      const dereferenced = crawl(
        parser.schema,
        parser.$refs._root$Ref.path,
        "#",
        /* @__PURE__ */ new Set(),
        /* @__PURE__ */ new Set(),
        /* @__PURE__ */ new Map(),
        parser.$refs,
        options
      );
      parser.$refs.circular = dereferenced.circular;
      parser.schema = dereferenced.value;
    };
    function crawl(obj, path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options) {
      var _a, _b;
      let dereferenced;
      const result = {
        value: obj,
        circular: false
      };
      if (options.dereference.circular === "ignore" || !processedObjects.has(obj)) {
        if (obj && typeof obj === "object" && !ArrayBuffer.isView(obj)) {
          parents.add(obj);
          processedObjects.add(obj);
          if ($Ref.isAllowed$Ref(obj, options)) {
            dereferenced = dereference$Ref(
              obj,
              path,
              pathFromRoot,
              parents,
              processedObjects,
              dereferencedCache,
              $refs,
              options
            );
            result.circular = dereferenced.circular;
            result.value = dereferenced.value;
            if (obj.description) {
              result.value.description = obj.description;
            }
            if (obj.summary) {
              result.value.summary = obj.summary;
            }
          } else {
            for (const key of Object.keys(obj)) {
              const keyPath = Pointer.join(path, key);
              const keyPathFromRoot = Pointer.join(pathFromRoot, key);
              const value = obj[key];
              const refSlashSplit = (_a = value == null ? void 0 : value.$ref) == null ? void 0 : _a.split("/");
              const refHashSplit = (_b = value == null ? void 0 : value.ref) == null ? void 0 : _b.split("#");
              const validRef = refSlashSplit == null ? void 0 : refSlashSplit.find((ele) => ele.slice(-1) === "#");
              if ((refSlashSplit == null ? void 0 : refSlashSplit.length) > 1 && (refHashSplit == null ? void 0 : refHashSplit.length) > 1 && !validRef) {
                throw new InvalidPointerError(value.$ref, keyPath);
              }
              let circular = false;
              if ($Ref.isAllowed$Ref(value, options)) {
                dereferenced = dereference$Ref(
                  value,
                  keyPath,
                  keyPathFromRoot,
                  parents,
                  processedObjects,
                  dereferencedCache,
                  $refs,
                  options
                );
                circular = dereferenced.circular;
                if (obj[key] !== dereferenced.value) {
                  obj[key] = dereferenced.value;
                  if (value.description) {
                    obj[key].description = value.description;
                  }
                  if (value.summary) {
                    obj[key].summary = value.summary;
                  }
                }
              } else if (!parents.has(value)) {
                dereferenced = crawl(
                  value,
                  keyPath,
                  keyPathFromRoot,
                  parents,
                  processedObjects,
                  dereferencedCache,
                  $refs,
                  options
                );
                circular = dereferenced.circular;
                if (obj[key] !== dereferenced.value) {
                  obj[key] = dereferenced.value;
                }
              } else {
                circular = foundCircularReference(keyPath, $refs, options);
              }
              result.circular = result.circular || circular;
            }
          }
          parents.delete(obj);
        }
      }
      return result;
    }
    function dereference$Ref($ref, path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options) {
      const $refPath = url.resolve(path, $ref.$ref);
      const cache = dereferencedCache.get($refPath);
      if (cache) {
        const refKeys = Object.keys($ref);
        if (refKeys.length > 1) {
          const extraKeys = {};
          for (const key of refKeys) {
            if (key !== "$ref" && !(key in cache.value)) {
              extraKeys[key] = $ref[key];
            }
          }
          return {
            circular: cache.circular,
            value: { ...cache.value, ...extraKeys }
          };
        }
        return cache;
      }
      const pointer = $refs._resolve($refPath, path, options);
      if (pointer === null) {
        return {
          circular: false,
          value: null
        };
      }
      const directCircular = pointer.circular;
      let circular = directCircular || parents.has(pointer.value);
      circular && foundCircularReference(path, $refs, options);
      let dereferencedValue = $Ref.dereference($ref, pointer.value);
      if (!circular) {
        const dereferenced = crawl(
          dereferencedValue,
          pointer.path,
          pathFromRoot,
          parents,
          processedObjects,
          dereferencedCache,
          $refs,
          options
        );
        circular = dereferenced.circular;
        dereferencedValue = dereferenced.value;
      }
      if (circular && !directCircular && options.dereference.circular === "ignore") {
        dereferencedValue = $ref;
      }
      if (directCircular) {
        dereferencedValue.$ref = pathFromRoot;
      }
      const dereferencedObject = {
        circular,
        value: dereferencedValue
      };
      if (Object.keys($ref).length === 1) {
        dereferencedCache.set($refPath, dereferencedObject);
      }
      return dereferencedObject;
    }
    function foundCircularReference(keyPath, $refs, options) {
      $refs.circular = true;
      $refs.circularRefs.push(keyPath);
      if (!options.dereference.circular) {
        throw ono2.reference(`Circular $ref pointer found at ${keyPath}`);
      }
      return true;
    }
  }
});

// .api/apis/zklighter/node_modules/@readme/json-schema-ref-parser/lib/parsers/binary.js
var require_binary = __commonJS({
  ".api/apis/zklighter/node_modules/@readme/json-schema-ref-parser/lib/parsers/binary.js"(exports, module2) {
    var BINARY_REGEXP = /\.(jpeg|jpg|gif|png|bmp|ico)$/i;
    module2.exports = {
      /**
       * The order that this parser will run, in relation to other parsers.
       *
       * @type {number}
       */
      order: 400,
      /**
       * Whether to allow "empty" files (zero bytes).
       *
       * @type {boolean}
       */
      allowEmpty: true,
      /**
       * Determines whether this parser can parse a given file reference.
       * Parsers that return true will be tried, in order, until one successfully parses the file.
       * Parsers that return false will be skipped, UNLESS all parsers returned false, in which case
       * every parser will be tried.
       *
       * @param {object} file           - An object containing information about the referenced file
       * @param {string} file.url       - The full URL of the referenced file
       * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
       * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
       * @returns {boolean}
       */
      canParse(file) {
        return Buffer.isBuffer(file.data) && BINARY_REGEXP.test(file.url);
      },
      /**
       * Parses the given data as a Buffer (byte array).
       *
       * @param {object} file           - An object containing information about the referenced file
       * @param {string} file.url       - The full URL of the referenced file
       * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
       * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
       * @returns {Buffer}
       */
      parse(file) {
        if (Buffer.isBuffer(file.data)) {
          return file.data;
        }
        return Buffer.from(file.data);
      }
    };
  }
});

// .api/apis/zklighter/node_modules/@readme/json-schema-ref-parser/lib/parsers/json.js
var require_json = __commonJS({
  ".api/apis/zklighter/node_modules/@readme/json-schema-ref-parser/lib/parsers/json.js"(exports, module2) {
    var { ParserError } = require_errors();
    module2.exports = {
      /**
       * The order that this parser will run, in relation to other parsers.
       *
       * @type {number}
       */
      order: 100,
      /**
       * Whether to allow "empty" files. This includes zero-byte files, as well as empty JSON objects.
       *
       * @type {boolean}
       */
      allowEmpty: true,
      /**
       * Determines whether this parser can parse a given file reference.
       * Parsers that match will be tried, in order, until one successfully parses the file.
       * Parsers that don't match will be skipped, UNLESS none of the parsers match, in which case
       * every parser will be tried.
       *
       * @type {RegExp|string|string[]|function}
       */
      canParse: ".json",
      /**
       * Parses the given file as JSON
       *
       * @param {object} file           - An object containing information about the referenced file
       * @param {string} file.url       - The full URL of the referenced file
       * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
       * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
       * @returns {Promise}
       */
      // eslint-disable-next-line require-await
      async parse(file) {
        let data = file.data;
        if (Buffer.isBuffer(data)) {
          data = data.toString();
        }
        if (typeof data === "string") {
          if (data.trim().length === 0) {
            return;
          }
          try {
            return JSON.parse(data);
          } catch (e) {
            throw new ParserError(e.message, file.url);
          }
        }
        return data;
      }
    };
  }
});

// .api/apis/zklighter/node_modules/@readme/json-schema-ref-parser/lib/parsers/text.js
var require_text = __commonJS({
  ".api/apis/zklighter/node_modules/@readme/json-schema-ref-parser/lib/parsers/text.js"(exports, module2) {
    var { ParserError } = require_errors();
    var TEXT_REGEXP = /\.(txt|htm|html|md|xml|js|min|map|css|scss|less|svg)$/i;
    module2.exports = {
      /**
       * The order that this parser will run, in relation to other parsers.
       *
       * @type {number}
       */
      order: 300,
      /**
       * Whether to allow "empty" files (zero bytes).
       *
       * @type {boolean}
       */
      allowEmpty: true,
      /**
       * The encoding that the text is expected to be in.
       *
       * @type {string}
       */
      encoding: "utf8",
      /**
       * Determines whether this parser can parse a given file reference.
       * Parsers that return true will be tried, in order, until one successfully parses the file.
       * Parsers that return false will be skipped, UNLESS all parsers returned false, in which case
       * every parser will be tried.
       *
       * @param {object} file           - An object containing information about the referenced file
       * @param {string} file.url       - The full URL of the referenced file
       * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
       * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
       * @returns {boolean}
       */
      canParse(file) {
        return (typeof file.data === "string" || Buffer.isBuffer(file.data)) && TEXT_REGEXP.test(file.url);
      },
      /**
       * Parses the given file as text
       *
       * @param {object} file           - An object containing information about the referenced file
       * @param {string} file.url       - The full URL of the referenced file
       * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
       * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
       * @returns {string}
       */
      parse(file) {
        if (typeof file.data === "string") {
          return file.data;
        } else if (Buffer.isBuffer(file.data)) {
          return file.data.toString(this.encoding);
        }
        throw new ParserError("data is not text", file.url);
      }
    };
  }
});

// .api/apis/zklighter/node_modules/js-yaml/lib/common.js
var require_common = __commonJS({
  ".api/apis/zklighter/node_modules/js-yaml/lib/common.js"(exports, module2) {
    "use strict";
    function isNothing(subject) {
      return typeof subject === "undefined" || subject === null;
    }
    function isObject(subject) {
      return typeof subject === "object" && subject !== null;
    }
    function toArray(sequence) {
      if (Array.isArray(sequence)) return sequence;
      else if (isNothing(sequence)) return [];
      return [sequence];
    }
    function extend2(target, source) {
      var index, length, key, sourceKeys;
      if (source) {
        sourceKeys = Object.keys(source);
        for (index = 0, length = sourceKeys.length; index < length; index += 1) {
          key = sourceKeys[index];
          target[key] = source[key];
        }
      }
      return target;
    }
    function repeat(string, count) {
      var result = "", cycle;
      for (cycle = 0; cycle < count; cycle += 1) {
        result += string;
      }
      return result;
    }
    function isNegativeZero(number) {
      return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
    }
    module2.exports.isNothing = isNothing;
    module2.exports.isObject = isObject;
    module2.exports.toArray = toArray;
    module2.exports.repeat = repeat;
    module2.exports.isNegativeZero = isNegativeZero;
    module2.exports.extend = extend2;
  }
});

// .api/apis/zklighter/node_modules/js-yaml/lib/exception.js
var require_exception = __commonJS({
  ".api/apis/zklighter/node_modules/js-yaml/lib/exception.js"(exports, module2) {
    "use strict";
    function formatError(exception, compact) {
      var where = "", message = exception.reason || "(unknown reason)";
      if (!exception.mark) return message;
      if (exception.mark.name) {
        where += 'in "' + exception.mark.name + '" ';
      }
      where += "(" + (exception.mark.line + 1) + ":" + (exception.mark.column + 1) + ")";
      if (!compact && exception.mark.snippet) {
        where += "\n\n" + exception.mark.snippet;
      }
      return message + " " + where;
    }
    function YAMLException(reason, mark) {
      Error.call(this);
      this.name = "YAMLException";
      this.reason = reason;
      this.mark = mark;
      this.message = formatError(this, false);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack || "";
      }
    }
    YAMLException.prototype = Object.create(Error.prototype);
    YAMLException.prototype.constructor = YAMLException;
    YAMLException.prototype.toString = function toString(compact) {
      return this.name + ": " + formatError(this, compact);
    };
    module2.exports = YAMLException;
  }
});

// .api/apis/zklighter/node_modules/js-yaml/lib/snippet.js
var require_snippet = __commonJS({
  ".api/apis/zklighter/node_modules/js-yaml/lib/snippet.js"(exports, module2) {
    "use strict";
    var common = require_common();
    function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
      var head = "";
      var tail = "";
      var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
      if (position - lineStart > maxHalfLength) {
        head = " ... ";
        lineStart = position - maxHalfLength + head.length;
      }
      if (lineEnd - position > maxHalfLength) {
        tail = " ...";
        lineEnd = position + maxHalfLength - tail.length;
      }
      return {
        str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "") + tail,
        pos: position - lineStart + head.length
        // relative position
      };
    }
    function padStart(string, max) {
      return common.repeat(" ", max - string.length) + string;
    }
    function makeSnippet(mark, options) {
      options = Object.create(options || null);
      if (!mark.buffer) return null;
      if (!options.maxLength) options.maxLength = 79;
      if (typeof options.indent !== "number") options.indent = 1;
      if (typeof options.linesBefore !== "number") options.linesBefore = 3;
      if (typeof options.linesAfter !== "number") options.linesAfter = 2;
      var re = /\r?\n|\r|\0/g;
      var lineStarts = [0];
      var lineEnds = [];
      var match2;
      var foundLineNo = -1;
      while (match2 = re.exec(mark.buffer)) {
        lineEnds.push(match2.index);
        lineStarts.push(match2.index + match2[0].length);
        if (mark.position <= match2.index && foundLineNo < 0) {
          foundLineNo = lineStarts.length - 2;
        }
      }
      if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;
      var result = "", i, line;
      var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
      var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
      for (i = 1; i <= options.linesBefore; i++) {
        if (foundLineNo - i < 0) break;
        line = getLine(
          mark.buffer,
          lineStarts[foundLineNo - i],
          lineEnds[foundLineNo - i],
          mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
          maxLineLength
        );
        result = common.repeat(" ", options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
      }
      line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
      result += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
      result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
      for (i = 1; i <= options.linesAfter; i++) {
        if (foundLineNo + i >= lineEnds.length) break;
        line = getLine(
          mark.buffer,
          lineStarts[foundLineNo + i],
          lineEnds[foundLineNo + i],
          mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
          maxLineLength
        );
        result += common.repeat(" ", options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
      }
      return result.replace(/\n$/, "");
    }
    module2.exports = makeSnippet;
  }
});

// .api/apis/zklighter/node_modules/js-yaml/lib/type.js
var require_type = __commonJS({
  ".api/apis/zklighter/node_modules/js-yaml/lib/type.js"(exports, module2) {
    "use strict";
    var YAMLException = require_exception();
    var TYPE_CONSTRUCTOR_OPTIONS = [
      "kind",
      "multi",
      "resolve",
      "construct",
      "instanceOf",
      "predicate",
      "represent",
      "representName",
      "defaultStyle",
      "styleAliases"
    ];
    var YAML_NODE_KINDS = [
      "scalar",
      "sequence",
      "mapping"
    ];
    function compileStyleAliases(map) {
      var result = {};
      if (map !== null) {
        Object.keys(map).forEach(function(style) {
          map[style].forEach(function(alias) {
            result[String(alias)] = style;
          });
        });
      }
      return result;
    }
    function Type(tag, options) {
      options = options || {};
      Object.keys(options).forEach(function(name) {
        if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
          throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
        }
      });
      this.options = options;
      this.tag = tag;
      this.kind = options["kind"] || null;
      this.resolve = options["resolve"] || function() {
        return true;
      };
      this.construct = options["construct"] || function(data) {
        return data;
      };
      this.instanceOf = options["instanceOf"] || null;
      this.predicate = options["predicate"] || null;
      this.represent = options["represent"] || null;
      this.representName = options["representName"] || null;
      this.defaultStyle = options["defaultStyle"] || null;
      this.multi = options["multi"] || false;
      this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
      if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
        throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
      }
    }
    module2.exports = Type;
  }
});

// .api/apis/zklighter/node_modules/js-yaml/lib/schema.js
var require_schema = __commonJS({
  ".api/apis/zklighter/node_modules/js-yaml/lib/schema.js"(exports, module2) {
    "use strict";
    var YAMLException = require_exception();
    var Type = require_type();
    function compileList(schema, name) {
      var result = [];
      schema[name].forEach(function(currentType) {
        var newIndex = result.length;
        result.forEach(function(previousType, previousIndex) {
          if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
            newIndex = previousIndex;
          }
        });
        result[newIndex] = currentType;
      });
      return result;
    }
    function compileMap() {
      var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {},
        multi: {
          scalar: [],
          sequence: [],
          mapping: [],
          fallback: []
        }
      }, index, length;
      function collectType(type) {
        if (type.multi) {
          result.multi[type.kind].push(type);
          result.multi["fallback"].push(type);
        } else {
          result[type.kind][type.tag] = result["fallback"][type.tag] = type;
        }
      }
      for (index = 0, length = arguments.length; index < length; index += 1) {
        arguments[index].forEach(collectType);
      }
      return result;
    }
    function Schema(definition) {
      return this.extend(definition);
    }
    Schema.prototype.extend = function extend2(definition) {
      var implicit = [];
      var explicit = [];
      if (definition instanceof Type) {
        explicit.push(definition);
      } else if (Array.isArray(definition)) {
        explicit = explicit.concat(definition);
      } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
        if (definition.implicit) implicit = implicit.concat(definition.implicit);
        if (definition.explicit) explicit = explicit.concat(definition.explicit);
      } else {
        throw new YAMLException("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
      }
      implicit.forEach(function(type) {
        if (!(type instanceof Type)) {
          throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
        }
        if (type.loadKind && type.loadKind !== "scalar") {
          throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
        }
        if (type.multi) {
          throw new YAMLException("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
        }
      });
      explicit.forEach(function(type) {
        if (!(type instanceof Type)) {
          throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
        }
      });
      var result = Object.create(Schema.prototype);
      result.implicit = (this.implicit || []).concat(implicit);
      result.explicit = (this.explicit || []).concat(explicit);
      result.compiledImplicit = compileList(result, "implicit");
      result.compiledExplicit = compileList(result, "explicit");
      result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
      return result;
    };
    module2.exports = Schema;
  }
});

// .api/apis/zklighter/node_modules/js-yaml/lib/type/str.js
var require_str = __commonJS({
  ".api/apis/zklighter/node_modules/js-yaml/lib/type/str.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    module2.exports = new Type("tag:yaml.org,2002:str", {
      kind: "scalar",
      construct: function(data) {
        return data !== null ? data : "";
      }
    });
  }
});

// .api/apis/zklighter/node_modules/js-yaml/lib/type/seq.js
var require_seq = __commonJS({
  ".api/apis/zklighter/node_modules/js-yaml/lib/type/seq.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    module2.exports = new Type("tag:yaml.org,2002:seq", {
      kind: "sequence",
      construct: function(data) {
        return data !== null ? data : [];
      }
    });
  }
});

// .api/apis/zklighter/node_modules/js-yaml/lib/type/map.js
var require_map = __commonJS({
  ".api/apis/zklighter/node_modules/js-yaml/lib/type/map.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    module2.exports = new Type("tag:yaml.org,2002:map", {
      kind: "mapping",
      construct: function(data) {
        return data !== null ? data : {};
      }
    });
  }
});

// .api/apis/zklighter/node_modules/js-yaml/lib/schema/failsafe.js
var require_failsafe = __commonJS({
  ".api/apis/zklighter/node_modules/js-yaml/lib/schema/failsafe.js"(exports, module2) {
    "use strict";
    var Schema = require_schema();
    module2.exports = new Schema({
      explicit: [
        require_str(),
        require_seq(),
        require_map()
      ]
    });
  }
});

// .api/apis/zklighter/node_modules/js-yaml/lib/type/null.js
var require_null = __commonJS({
  ".api/apis/zklighter/node_modules/js-yaml/lib/type/null.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    function resolveYamlNull(data) {
      if (data === null) return true;
      var max = data.length;
      return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
    }
    function constructYamlNull() {
      return null;
    }
    function isNull(object) {
      return object === null;
    }
    module2.exports = new Type("tag:yaml.org,2002:null", {
      kind: "scalar",
      resolve: resolveYamlNull,
      construct: constructYamlNull,
      predicate: isNull,
      represent: {
        canonical: function() {
          return "~";
        },
        lowercase: function() {
          return "null";
        },
        uppercase: function() {
          return "NULL";
        },
        camelcase: function() {
          return "Null";
        },
        empty: function() {
          return "";
        }
      },
      defaultStyle: "lowercase"
    });
  }
});

// .api/apis/zklighter/node_modules/js-yaml/lib/type/bool.js
var require_bool = __commonJS({
  ".api/apis/zklighter/node_modules/js-yaml/lib/type/bool.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    function resolveYamlBoolean(data) {
      if (data === null) return false;
      var max = data.length;
      return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
    }
    function constructYamlBoolean(data) {
      return data === "true" || data === "True" || data === "TRUE";
    }
    function isBoolean(object) {
      return Object.prototype.toString.call(object) === "[object Boolean]";
    }
    module2.exports = new Type("tag:yaml.org,2002:bool", {
      kind: "scalar",
      resolve: resolveYamlBoolean,
      construct: constructYamlBoolean,
      predicate: isBoolean,
      represent: {
        lowercase: function(object) {
          return object ? "true" : "false";
        },
        uppercase: function(object) {
          return object ? "TRUE" : "FALSE";
        },
        camelcase: function(object) {
          return object ? "True" : "False";
        }
      },
      defaultStyle: "lowercase"
    });
  }
});

// .api/apis/zklighter/node_modules/js-yaml/lib/type/int.js
var require_int = __commonJS({
  ".api/apis/zklighter/node_modules/js-yaml/lib/type/int.js"(exports, module2) {
    "use strict";
    var common = require_common();
    var Type = require_type();
    function isHexCode(c) {
      return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
    }
    function isOctCode(c) {
      return 48 <= c && c <= 55;
    }
    function isDecCode(c) {
      return 48 <= c && c <= 57;
    }
    function resolveYamlInteger(data) {
      if (data === null) return false;
      var max = data.length, index = 0, hasDigits = false, ch;
      if (!max) return false;
      ch = data[index];
      if (ch === "-" || ch === "+") {
        ch = data[++index];
      }
      if (ch === "0") {
        if (index + 1 === max) return true;
        ch = data[++index];
        if (ch === "b") {
          index++;
          for (; index < max; index++) {
            ch = data[index];
            if (ch === "_") continue;
            if (ch !== "0" && ch !== "1") return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        if (ch === "x") {
          index++;
          for (; index < max; index++) {
            ch = data[index];
            if (ch === "_") continue;
            if (!isHexCode(data.charCodeAt(index))) return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        if (ch === "o") {
          index++;
          for (; index < max; index++) {
            ch = data[index];
            if (ch === "_") continue;
            if (!isOctCode(data.charCodeAt(index))) return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
      }
      if (ch === "_") return false;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_") continue;
        if (!isDecCode(data.charCodeAt(index))) {
          return false;
        }
        hasDigits = true;
      }
      if (!hasDigits || ch === "_") return false;
      return true;
    }
    function constructYamlInteger(data) {
      var value = data, sign = 1, ch;
      if (value.indexOf("_") !== -1) {
        value = value.replace(/_/g, "");
      }
      ch = value[0];
      if (ch === "-" || ch === "+") {
        if (ch === "-") sign = -1;
        value = value.slice(1);
        ch = value[0];
      }
      if (value === "0") return 0;
      if (ch === "0") {
        if (value[1] === "b") return sign * parseInt(value.slice(2), 2);
        if (value[1] === "x") return sign * parseInt(value.slice(2), 16);
        if (value[1] === "o") return sign * parseInt(value.slice(2), 8);
      }
      return sign * parseInt(value, 10);
    }
    function isInteger(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
    }
    module2.exports = new Type("tag:yaml.org,2002:int", {
      kind: "scalar",
      resolve: resolveYamlInteger,
      construct: constructYamlInteger,
      predicate: isInteger,
      represent: {
        binary: function(obj) {
          return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
        },
        octal: function(obj) {
          return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
        },
        decimal: function(obj) {
          return obj.toString(10);
        },
        /* eslint-disable max-len */
        hexadecimal: function(obj) {
          return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
        }
      },
      defaultStyle: "decimal",
      styleAliases: {
        binary: [2, "bin"],
        octal: [8, "oct"],
        decimal: [10, "dec"],
        hexadecimal: [16, "hex"]
      }
    });
  }
});

// .api/apis/zklighter/node_modules/js-yaml/lib/type/float.js
var require_float = __commonJS({
  ".api/apis/zklighter/node_modules/js-yaml/lib/type/float.js"(exports, module2) {
    "use strict";
    var common = require_common();
    var Type = require_type();
    var YAML_FLOAT_PATTERN = new RegExp(
      // 2.5e4, 2.5 and integers
      "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
    );
    function resolveYamlFloat(data) {
      if (data === null) return false;
      if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
      // Probably should update regexp & check speed
      data[data.length - 1] === "_") {
        return false;
      }
      return true;
    }
    function constructYamlFloat(data) {
      var value, sign;
      value = data.replace(/_/g, "").toLowerCase();
      sign = value[0] === "-" ? -1 : 1;
      if ("+-".indexOf(value[0]) >= 0) {
        value = value.slice(1);
      }
      if (value === ".inf") {
        return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
      } else if (value === ".nan") {
        return NaN;
      }
      return sign * parseFloat(value, 10);
    }
    var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
    function representYamlFloat(object, style) {
      var res;
      if (isNaN(object)) {
        switch (style) {
          case "lowercase":
            return ".nan";
          case "uppercase":
            return ".NAN";
          case "camelcase":
            return ".NaN";
        }
      } else if (Number.POSITIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return ".inf";
          case "uppercase":
            return ".INF";
          case "camelcase":
            return ".Inf";
        }
      } else if (Number.NEGATIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return "-.inf";
          case "uppercase":
            return "-.INF";
          case "camelcase":
            return "-.Inf";
        }
      } else if (common.isNegativeZero(object)) {
        return "-0.0";
      }
      res = object.toString(10);
      return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
    }
    function isFloat(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
    }
    module2.exports = new Type("tag:yaml.org,2002:float", {
      kind: "scalar",
      resolve: resolveYamlFloat,
      construct: constructYamlFloat,
      predicate: isFloat,
      represent: representYamlFloat,
      defaultStyle: "lowercase"
    });
  }
});

// .api/apis/zklighter/node_modules/js-yaml/lib/schema/json.js
var require_json2 = __commonJS({
  ".api/apis/zklighter/node_modules/js-yaml/lib/schema/json.js"(exports, module2) {
    "use strict";
    module2.exports = require_failsafe().extend({
      implicit: [
        require_null(),
        require_bool(),
        require_int(),
        require_float()
      ]
    });
  }
});

// .api/apis/zklighter/node_modules/js-yaml/lib/schema/core.js
var require_core = __commonJS({
  ".api/apis/zklighter/node_modules/js-yaml/lib/schema/core.js"(exports, module2) {
    "use strict";
    module2.exports = require_json2();
  }
});

// .api/apis/zklighter/node_modules/js-yaml/lib/type/timestamp.js
var require_timestamp = __commonJS({
  ".api/apis/zklighter/node_modules/js-yaml/lib/type/timestamp.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    var YAML_DATE_REGEXP = new RegExp(
      "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
    );
    var YAML_TIMESTAMP_REGEXP = new RegExp(
      "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
    );
    function resolveYamlTimestamp(data) {
      if (data === null) return false;
      if (YAML_DATE_REGEXP.exec(data) !== null) return true;
      if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
      return false;
    }
    function constructYamlTimestamp(data) {
      var match2, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
      match2 = YAML_DATE_REGEXP.exec(data);
      if (match2 === null) match2 = YAML_TIMESTAMP_REGEXP.exec(data);
      if (match2 === null) throw new Error("Date resolve error");
      year = +match2[1];
      month = +match2[2] - 1;
      day = +match2[3];
      if (!match2[4]) {
        return new Date(Date.UTC(year, month, day));
      }
      hour = +match2[4];
      minute = +match2[5];
      second = +match2[6];
      if (match2[7]) {
        fraction = match2[7].slice(0, 3);
        while (fraction.length < 3) {
          fraction += "0";
        }
        fraction = +fraction;
      }
      if (match2[9]) {
        tz_hour = +match2[10];
        tz_minute = +(match2[11] || 0);
        delta = (tz_hour * 60 + tz_minute) * 6e4;
        if (match2[9] === "-") delta = -delta;
      }
      date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
      if (delta) date.setTime(date.getTime() - delta);
      return date;
    }
    function representYamlTimestamp(object) {
      return object.toISOString();
    }
    module2.exports = new Type("tag:yaml.org,2002:timestamp", {
      kind: "scalar",
      resolve: resolveYamlTimestamp,
      construct: constructYamlTimestamp,
      instanceOf: Date,
      represent: representYamlTimestamp
    });
  }
});

// .api/apis/zklighter/node_modules/js-yaml/lib/type/merge.js
var require_merge = __commonJS({
  ".api/apis/zklighter/node_modules/js-yaml/lib/type/merge.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    function resolveYamlMerge(data) {
      return data === "<<" || data === null;
    }
    module2.exports = new Type("tag:yaml.org,2002:merge", {
      kind: "scalar",
      resolve: resolveYamlMerge
    });
  }
});

// .api/apis/zklighter/node_modules/js-yaml/lib/type/binary.js
var require_binary2 = __commonJS({
  ".api/apis/zklighter/node_modules/js-yaml/lib/type/binary.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
    function resolveYamlBinary(data) {
      if (data === null) return false;
      var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;
      for (idx = 0; idx < max; idx++) {
        code = map.indexOf(data.charAt(idx));
        if (code > 64) continue;
        if (code < 0) return false;
        bitlen += 6;
      }
      return bitlen % 8 === 0;
    }
    function constructYamlBinary(data) {
      var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map = BASE64_MAP, bits = 0, result = [];
      for (idx = 0; idx < max; idx++) {
        if (idx % 4 === 0 && idx) {
          result.push(bits >> 16 & 255);
          result.push(bits >> 8 & 255);
          result.push(bits & 255);
        }
        bits = bits << 6 | map.indexOf(input.charAt(idx));
      }
      tailbits = max % 4 * 6;
      if (tailbits === 0) {
        result.push(bits >> 16 & 255);
        result.push(bits >> 8 & 255);
        result.push(bits & 255);
      } else if (tailbits === 18) {
        result.push(bits >> 10 & 255);
        result.push(bits >> 2 & 255);
      } else if (tailbits === 12) {
        result.push(bits >> 4 & 255);
      }
      return new Uint8Array(result);
    }
    function representYamlBinary(object) {
      var result = "", bits = 0, idx, tail, max = object.length, map = BASE64_MAP;
      for (idx = 0; idx < max; idx++) {
        if (idx % 3 === 0 && idx) {
          result += map[bits >> 18 & 63];
          result += map[bits >> 12 & 63];
          result += map[bits >> 6 & 63];
          result += map[bits & 63];
        }
        bits = (bits << 8) + object[idx];
      }
      tail = max % 3;
      if (tail === 0) {
        result += map[bits >> 18 & 63];
        result += map[bits >> 12 & 63];
        result += map[bits >> 6 & 63];
        result += map[bits & 63];
      } else if (tail === 2) {
        result += map[bits >> 10 & 63];
        result += map[bits >> 4 & 63];
        result += map[bits << 2 & 63];
        result += map[64];
      } else if (tail === 1) {
        result += map[bits >> 2 & 63];
        result += map[bits << 4 & 63];
        result += map[64];
        result += map[64];
      }
      return result;
    }
    function isBinary(obj) {
      return Object.prototype.toString.call(obj) === "[object Uint8Array]";
    }
    module2.exports = new Type("tag:yaml.org,2002:binary", {
      kind: "scalar",
      resolve: resolveYamlBinary,
      construct: constructYamlBinary,
      predicate: isBinary,
      represent: representYamlBinary
    });
  }
});

// .api/apis/zklighter/node_modules/js-yaml/lib/type/omap.js
var require_omap = __commonJS({
  ".api/apis/zklighter/node_modules/js-yaml/lib/type/omap.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var _toString = Object.prototype.toString;
    function resolveYamlOmap(data) {
      if (data === null) return true;
      var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        pairHasKey = false;
        if (_toString.call(pair) !== "[object Object]") return false;
        for (pairKey in pair) {
          if (_hasOwnProperty.call(pair, pairKey)) {
            if (!pairHasKey) pairHasKey = true;
            else return false;
          }
        }
        if (!pairHasKey) return false;
        if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
        else return false;
      }
      return true;
    }
    function constructYamlOmap(data) {
      return data !== null ? data : [];
    }
    module2.exports = new Type("tag:yaml.org,2002:omap", {
      kind: "sequence",
      resolve: resolveYamlOmap,
      construct: constructYamlOmap
    });
  }
});

// .api/apis/zklighter/node_modules/js-yaml/lib/type/pairs.js
var require_pairs = __commonJS({
  ".api/apis/zklighter/node_modules/js-yaml/lib/type/pairs.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    var _toString = Object.prototype.toString;
    function resolveYamlPairs(data) {
      if (data === null) return true;
      var index, length, pair, keys, result, object = data;
      result = new Array(object.length);
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        if (_toString.call(pair) !== "[object Object]") return false;
        keys = Object.keys(pair);
        if (keys.length !== 1) return false;
        result[index] = [keys[0], pair[keys[0]]];
      }
      return true;
    }
    function constructYamlPairs(data) {
      if (data === null) return [];
      var index, length, pair, keys, result, object = data;
      result = new Array(object.length);
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        keys = Object.keys(pair);
        result[index] = [keys[0], pair[keys[0]]];
      }
      return result;
    }
    module2.exports = new Type("tag:yaml.org,2002:pairs", {
      kind: "sequence",
      resolve: resolveYamlPairs,
      construct: constructYamlPairs
    });
  }
});

// .api/apis/zklighter/node_modules/js-yaml/lib/type/set.js
var require_set = __commonJS({
  ".api/apis/zklighter/node_modules/js-yaml/lib/type/set.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    function resolveYamlSet(data) {
      if (data === null) return true;
      var key, object = data;
      for (key in object) {
        if (_hasOwnProperty.call(object, key)) {
          if (object[key] !== null) return false;
        }
      }
      return true;
    }
    function constructYamlSet(data) {
      return data !== null ? data : {};
    }
    module2.exports = new Type("tag:yaml.org,2002:set", {
      kind: "mapping",
      resolve: resolveYamlSet,
      construct: constructYamlSet
    });
  }
});

// .api/apis/zklighter/node_modules/js-yaml/lib/schema/default.js
var require_default = __commonJS({
  ".api/apis/zklighter/node_modules/js-yaml/lib/schema/default.js"(exports, module2) {
    "use strict";
    module2.exports = require_core().extend({
      implicit: [
        require_timestamp(),
        require_merge()
      ],
      explicit: [
        require_binary2(),
        require_omap(),
        require_pairs(),
        require_set()
      ]
    });
  }
});

// .api/apis/zklighter/node_modules/js-yaml/lib/loader.js
var require_loader = __commonJS({
  ".api/apis/zklighter/node_modules/js-yaml/lib/loader.js"(exports, module2) {
    "use strict";
    var common = require_common();
    var YAMLException = require_exception();
    var makeSnippet = require_snippet();
    var DEFAULT_SCHEMA = require_default();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var CONTEXT_FLOW_IN = 1;
    var CONTEXT_FLOW_OUT = 2;
    var CONTEXT_BLOCK_IN = 3;
    var CONTEXT_BLOCK_OUT = 4;
    var CHOMPING_CLIP = 1;
    var CHOMPING_STRIP = 2;
    var CHOMPING_KEEP = 3;
    var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
    var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
    var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
    var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function is_EOL(c) {
      return c === 10 || c === 13;
    }
    function is_WHITE_SPACE(c) {
      return c === 9 || c === 32;
    }
    function is_WS_OR_EOL(c) {
      return c === 9 || c === 32 || c === 10 || c === 13;
    }
    function is_FLOW_INDICATOR(c) {
      return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
    }
    function fromHexCode(c) {
      var lc;
      if (48 <= c && c <= 57) {
        return c - 48;
      }
      lc = c | 32;
      if (97 <= lc && lc <= 102) {
        return lc - 97 + 10;
      }
      return -1;
    }
    function escapedHexLen(c) {
      if (c === 120) {
        return 2;
      }
      if (c === 117) {
        return 4;
      }
      if (c === 85) {
        return 8;
      }
      return 0;
    }
    function fromDecimalCode(c) {
      if (48 <= c && c <= 57) {
        return c - 48;
      }
      return -1;
    }
    function simpleEscapeSequence(c) {
      return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "" : c === 95 ? "" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
    }
    function charFromCodepoint(c) {
      if (c <= 65535) {
        return String.fromCharCode(c);
      }
      return String.fromCharCode(
        (c - 65536 >> 10) + 55296,
        (c - 65536 & 1023) + 56320
      );
    }
    var simpleEscapeCheck = new Array(256);
    var simpleEscapeMap = new Array(256);
    for (i = 0; i < 256; i++) {
      simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
      simpleEscapeMap[i] = simpleEscapeSequence(i);
    }
    var i;
    function State(input, options) {
      this.input = input;
      this.filename = options["filename"] || null;
      this.schema = options["schema"] || DEFAULT_SCHEMA;
      this.onWarning = options["onWarning"] || null;
      this.legacy = options["legacy"] || false;
      this.json = options["json"] || false;
      this.listener = options["listener"] || null;
      this.implicitTypes = this.schema.compiledImplicit;
      this.typeMap = this.schema.compiledTypeMap;
      this.length = input.length;
      this.position = 0;
      this.line = 0;
      this.lineStart = 0;
      this.lineIndent = 0;
      this.firstTabInLine = -1;
      this.documents = [];
    }
    function generateError(state, message) {
      var mark = {
        name: state.filename,
        buffer: state.input.slice(0, -1),
        // omit trailing \0
        position: state.position,
        line: state.line,
        column: state.position - state.lineStart
      };
      mark.snippet = makeSnippet(mark);
      return new YAMLException(message, mark);
    }
    function throwError(state, message) {
      throw generateError(state, message);
    }
    function throwWarning(state, message) {
      if (state.onWarning) {
        state.onWarning.call(null, generateError(state, message));
      }
    }
    var directiveHandlers = {
      YAML: function handleYamlDirective(state, name, args) {
        var match2, major, minor;
        if (state.version !== null) {
          throwError(state, "duplication of %YAML directive");
        }
        if (args.length !== 1) {
          throwError(state, "YAML directive accepts exactly one argument");
        }
        match2 = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
        if (match2 === null) {
          throwError(state, "ill-formed argument of the YAML directive");
        }
        major = parseInt(match2[1], 10);
        minor = parseInt(match2[2], 10);
        if (major !== 1) {
          throwError(state, "unacceptable YAML version of the document");
        }
        state.version = args[0];
        state.checkLineBreaks = minor < 2;
        if (minor !== 1 && minor !== 2) {
          throwWarning(state, "unsupported YAML version of the document");
        }
      },
      TAG: function handleTagDirective(state, name, args) {
        var handle, prefix;
        if (args.length !== 2) {
          throwError(state, "TAG directive accepts exactly two arguments");
        }
        handle = args[0];
        prefix = args[1];
        if (!PATTERN_TAG_HANDLE.test(handle)) {
          throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
        }
        if (_hasOwnProperty.call(state.tagMap, handle)) {
          throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
        }
        if (!PATTERN_TAG_URI.test(prefix)) {
          throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
        }
        try {
          prefix = decodeURIComponent(prefix);
        } catch (err) {
          throwError(state, "tag prefix is malformed: " + prefix);
        }
        state.tagMap[handle] = prefix;
      }
    };
    function captureSegment(state, start, end, checkJson) {
      var _position, _length, _character, _result;
      if (start < end) {
        _result = state.input.slice(start, end);
        if (checkJson) {
          for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
            _character = _result.charCodeAt(_position);
            if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
              throwError(state, "expected valid JSON character");
            }
          }
        } else if (PATTERN_NON_PRINTABLE.test(_result)) {
          throwError(state, "the stream contains non-printable characters");
        }
        state.result += _result;
      }
    }
    function mergeMappings(state, destination, source, overridableKeys) {
      var sourceKeys, key, index, quantity;
      if (!common.isObject(source)) {
        throwError(state, "cannot merge mappings; the provided source object is unacceptable");
      }
      sourceKeys = Object.keys(source);
      for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
        key = sourceKeys[index];
        if (!_hasOwnProperty.call(destination, key)) {
          destination[key] = source[key];
          overridableKeys[key] = true;
        }
      }
    }
    function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
      var index, quantity;
      if (Array.isArray(keyNode)) {
        keyNode = Array.prototype.slice.call(keyNode);
        for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
          if (Array.isArray(keyNode[index])) {
            throwError(state, "nested arrays are not supported inside keys");
          }
          if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
            keyNode[index] = "[object Object]";
          }
        }
      }
      if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
        keyNode = "[object Object]";
      }
      keyNode = String(keyNode);
      if (_result === null) {
        _result = {};
      }
      if (keyTag === "tag:yaml.org,2002:merge") {
        if (Array.isArray(valueNode)) {
          for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
            mergeMappings(state, _result, valueNode[index], overridableKeys);
          }
        } else {
          mergeMappings(state, _result, valueNode, overridableKeys);
        }
      } else {
        if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {
          state.line = startLine || state.line;
          state.lineStart = startLineStart || state.lineStart;
          state.position = startPos || state.position;
          throwError(state, "duplicated mapping key");
        }
        if (keyNode === "__proto__") {
          Object.defineProperty(_result, keyNode, {
            configurable: true,
            enumerable: true,
            writable: true,
            value: valueNode
          });
        } else {
          _result[keyNode] = valueNode;
        }
        delete overridableKeys[keyNode];
      }
      return _result;
    }
    function readLineBreak(state) {
      var ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 10) {
        state.position++;
      } else if (ch === 13) {
        state.position++;
        if (state.input.charCodeAt(state.position) === 10) {
          state.position++;
        }
      } else {
        throwError(state, "a line break is expected");
      }
      state.line += 1;
      state.lineStart = state.position;
      state.firstTabInLine = -1;
    }
    function skipSeparationSpace(state, allowComments, checkIndent) {
      var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        while (is_WHITE_SPACE(ch)) {
          if (ch === 9 && state.firstTabInLine === -1) {
            state.firstTabInLine = state.position;
          }
          ch = state.input.charCodeAt(++state.position);
        }
        if (allowComments && ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 10 && ch !== 13 && ch !== 0);
        }
        if (is_EOL(ch)) {
          readLineBreak(state);
          ch = state.input.charCodeAt(state.position);
          lineBreaks++;
          state.lineIndent = 0;
          while (ch === 32) {
            state.lineIndent++;
            ch = state.input.charCodeAt(++state.position);
          }
        } else {
          break;
        }
      }
      if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
        throwWarning(state, "deficient indentation");
      }
      return lineBreaks;
    }
    function testDocumentSeparator(state) {
      var _position = state.position, ch;
      ch = state.input.charCodeAt(_position);
      if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
        _position += 3;
        ch = state.input.charCodeAt(_position);
        if (ch === 0 || is_WS_OR_EOL(ch)) {
          return true;
        }
      }
      return false;
    }
    function writeFoldedLines(state, count) {
      if (count === 1) {
        state.result += " ";
      } else if (count > 1) {
        state.result += common.repeat("\n", count - 1);
      }
    }
    function readPlainScalar(state, nodeIndent, withinFlowCollection) {
      var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
      ch = state.input.charCodeAt(state.position);
      if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
        return false;
      }
      if (ch === 63 || ch === 45) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          return false;
        }
      }
      state.kind = "scalar";
      state.result = "";
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
      while (ch !== 0) {
        if (ch === 58) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
            break;
          }
        } else if (ch === 35) {
          preceding = state.input.charCodeAt(state.position - 1);
          if (is_WS_OR_EOL(preceding)) {
            break;
          }
        } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
          break;
        } else if (is_EOL(ch)) {
          _line = state.line;
          _lineStart = state.lineStart;
          _lineIndent = state.lineIndent;
          skipSeparationSpace(state, false, -1);
          if (state.lineIndent >= nodeIndent) {
            hasPendingContent = true;
            ch = state.input.charCodeAt(state.position);
            continue;
          } else {
            state.position = captureEnd;
            state.line = _line;
            state.lineStart = _lineStart;
            state.lineIndent = _lineIndent;
            break;
          }
        }
        if (hasPendingContent) {
          captureSegment(state, captureStart, captureEnd, false);
          writeFoldedLines(state, state.line - _line);
          captureStart = captureEnd = state.position;
          hasPendingContent = false;
        }
        if (!is_WHITE_SPACE(ch)) {
          captureEnd = state.position + 1;
        }
        ch = state.input.charCodeAt(++state.position);
      }
      captureSegment(state, captureStart, captureEnd, false);
      if (state.result) {
        return true;
      }
      state.kind = _kind;
      state.result = _result;
      return false;
    }
    function readSingleQuotedScalar(state, nodeIndent) {
      var ch, captureStart, captureEnd;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 39) {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 39) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (ch === 39) {
            captureStart = state.position;
            state.position++;
            captureEnd = state.position;
          } else {
            return true;
          }
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, "unexpected end of the document within a single quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, "unexpected end of the stream within a single quoted scalar");
    }
    function readDoubleQuotedScalar(state, nodeIndent) {
      var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 34) {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 34) {
          captureSegment(state, captureStart, state.position, true);
          state.position++;
          return true;
        } else if (ch === 92) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (is_EOL(ch)) {
            skipSeparationSpace(state, false, nodeIndent);
          } else if (ch < 256 && simpleEscapeCheck[ch]) {
            state.result += simpleEscapeMap[ch];
            state.position++;
          } else if ((tmp = escapedHexLen(ch)) > 0) {
            hexLength = tmp;
            hexResult = 0;
            for (; hexLength > 0; hexLength--) {
              ch = state.input.charCodeAt(++state.position);
              if ((tmp = fromHexCode(ch)) >= 0) {
                hexResult = (hexResult << 4) + tmp;
              } else {
                throwError(state, "expected hexadecimal character");
              }
            }
            state.result += charFromCodepoint(hexResult);
            state.position++;
          } else {
            throwError(state, "unknown escape sequence");
          }
          captureStart = captureEnd = state.position;
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, "unexpected end of the document within a double quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, "unexpected end of the stream within a double quoted scalar");
    }
    function readFlowCollection(state, nodeIndent) {
      var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 91) {
        terminator = 93;
        isMapping = false;
        _result = [];
      } else if (ch === 123) {
        terminator = 125;
        isMapping = true;
        _result = {};
      } else {
        return false;
      }
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(++state.position);
      while (ch !== 0) {
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === terminator) {
          state.position++;
          state.tag = _tag;
          state.anchor = _anchor;
          state.kind = isMapping ? "mapping" : "sequence";
          state.result = _result;
          return true;
        } else if (!readNext) {
          throwError(state, "missed comma between flow collection entries");
        } else if (ch === 44) {
          throwError(state, "expected the node content, but found ','");
        }
        keyTag = keyNode = valueNode = null;
        isPair = isExplicitPair = false;
        if (ch === 63) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following)) {
            isPair = isExplicitPair = true;
            state.position++;
            skipSeparationSpace(state, true, nodeIndent);
          }
        }
        _line = state.line;
        _lineStart = state.lineStart;
        _pos = state.position;
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        keyTag = state.tag;
        keyNode = state.result;
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if ((isExplicitPair || state.line === _line) && ch === 58) {
          isPair = true;
          ch = state.input.charCodeAt(++state.position);
          skipSeparationSpace(state, true, nodeIndent);
          composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
          valueNode = state.result;
        }
        if (isMapping) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
        } else if (isPair) {
          _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
        } else {
          _result.push(keyNode);
        }
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === 44) {
          readNext = true;
          ch = state.input.charCodeAt(++state.position);
        } else {
          readNext = false;
        }
      }
      throwError(state, "unexpected end of the stream within a flow collection");
    }
    function readBlockScalar(state, nodeIndent) {
      var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 124) {
        folding = false;
      } else if (ch === 62) {
        folding = true;
      } else {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      while (ch !== 0) {
        ch = state.input.charCodeAt(++state.position);
        if (ch === 43 || ch === 45) {
          if (CHOMPING_CLIP === chomping) {
            chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
          } else {
            throwError(state, "repeat of a chomping mode identifier");
          }
        } else if ((tmp = fromDecimalCode(ch)) >= 0) {
          if (tmp === 0) {
            throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
          } else if (!detectedIndent) {
            textIndent = nodeIndent + tmp - 1;
            detectedIndent = true;
          } else {
            throwError(state, "repeat of an indentation width identifier");
          }
        } else {
          break;
        }
      }
      if (is_WHITE_SPACE(ch)) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (is_WHITE_SPACE(ch));
        if (ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (!is_EOL(ch) && ch !== 0);
        }
      }
      while (ch !== 0) {
        readLineBreak(state);
        state.lineIndent = 0;
        ch = state.input.charCodeAt(state.position);
        while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
        if (!detectedIndent && state.lineIndent > textIndent) {
          textIndent = state.lineIndent;
        }
        if (is_EOL(ch)) {
          emptyLines++;
          continue;
        }
        if (state.lineIndent < textIndent) {
          if (chomping === CHOMPING_KEEP) {
            state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          } else if (chomping === CHOMPING_CLIP) {
            if (didReadContent) {
              state.result += "\n";
            }
          }
          break;
        }
        if (folding) {
          if (is_WHITE_SPACE(ch)) {
            atMoreIndented = true;
            state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          } else if (atMoreIndented) {
            atMoreIndented = false;
            state.result += common.repeat("\n", emptyLines + 1);
          } else if (emptyLines === 0) {
            if (didReadContent) {
              state.result += " ";
            }
          } else {
            state.result += common.repeat("\n", emptyLines);
          }
        } else {
          state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        }
        didReadContent = true;
        detectedIndent = true;
        emptyLines = 0;
        captureStart = state.position;
        while (!is_EOL(ch) && ch !== 0) {
          ch = state.input.charCodeAt(++state.position);
        }
        captureSegment(state, captureStart, state.position, false);
      }
      return true;
    }
    function readBlockSequence(state, nodeIndent) {
      var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
      if (state.firstTabInLine !== -1) return false;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        if (state.firstTabInLine !== -1) {
          state.position = state.firstTabInLine;
          throwError(state, "tab characters must not be used in indentation");
        }
        if (ch !== 45) {
          break;
        }
        following = state.input.charCodeAt(state.position + 1);
        if (!is_WS_OR_EOL(following)) {
          break;
        }
        detected = true;
        state.position++;
        if (skipSeparationSpace(state, true, -1)) {
          if (state.lineIndent <= nodeIndent) {
            _result.push(null);
            ch = state.input.charCodeAt(state.position);
            continue;
          }
        }
        _line = state.line;
        composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
        _result.push(state.result);
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
          throwError(state, "bad indentation of a sequence entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "sequence";
        state.result = _result;
        return true;
      }
      return false;
    }
    function readBlockMapping(state, nodeIndent, flowIndent) {
      var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
      if (state.firstTabInLine !== -1) return false;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        if (!atExplicitKey && state.firstTabInLine !== -1) {
          state.position = state.firstTabInLine;
          throwError(state, "tab characters must not be used in indentation");
        }
        following = state.input.charCodeAt(state.position + 1);
        _line = state.line;
        if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
          if (ch === 63) {
            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
              keyTag = keyNode = valueNode = null;
            }
            detected = true;
            atExplicitKey = true;
            allowCompact = true;
          } else if (atExplicitKey) {
            atExplicitKey = false;
            allowCompact = true;
          } else {
            throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
          }
          state.position += 1;
          ch = following;
        } else {
          _keyLine = state.line;
          _keyLineStart = state.lineStart;
          _keyPos = state.position;
          if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
            break;
          }
          if (state.line === _line) {
            ch = state.input.charCodeAt(state.position);
            while (is_WHITE_SPACE(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            if (ch === 58) {
              ch = state.input.charCodeAt(++state.position);
              if (!is_WS_OR_EOL(ch)) {
                throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
              }
              if (atExplicitKey) {
                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
                keyTag = keyNode = valueNode = null;
              }
              detected = true;
              atExplicitKey = false;
              allowCompact = false;
              keyTag = state.tag;
              keyNode = state.result;
            } else if (detected) {
              throwError(state, "can not read an implicit mapping pair; a colon is missed");
            } else {
              state.tag = _tag;
              state.anchor = _anchor;
              return true;
            }
          } else if (detected) {
            throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true;
          }
        }
        if (state.line === _line || state.lineIndent > nodeIndent) {
          if (atExplicitKey) {
            _keyLine = state.line;
            _keyLineStart = state.lineStart;
            _keyPos = state.position;
          }
          if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
            if (atExplicitKey) {
              keyNode = state.result;
            } else {
              valueNode = state.result;
            }
          }
          if (!atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          skipSeparationSpace(state, true, -1);
          ch = state.input.charCodeAt(state.position);
        }
        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
          throwError(state, "bad indentation of a mapping entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "mapping";
        state.result = _result;
      }
      return detected;
    }
    function readTagProperty(state) {
      var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 33) return false;
      if (state.tag !== null) {
        throwError(state, "duplication of a tag property");
      }
      ch = state.input.charCodeAt(++state.position);
      if (ch === 60) {
        isVerbatim = true;
        ch = state.input.charCodeAt(++state.position);
      } else if (ch === 33) {
        isNamed = true;
        tagHandle = "!!";
        ch = state.input.charCodeAt(++state.position);
      } else {
        tagHandle = "!";
      }
      _position = state.position;
      if (isVerbatim) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && ch !== 62);
        if (state.position < state.length) {
          tagName = state.input.slice(_position, state.position);
          ch = state.input.charCodeAt(++state.position);
        } else {
          throwError(state, "unexpected end of the stream within a verbatim tag");
        }
      } else {
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          if (ch === 33) {
            if (!isNamed) {
              tagHandle = state.input.slice(_position - 1, state.position + 1);
              if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                throwError(state, "named tag handle cannot contain such characters");
              }
              isNamed = true;
              _position = state.position + 1;
            } else {
              throwError(state, "tag suffix cannot contain exclamation marks");
            }
          }
          ch = state.input.charCodeAt(++state.position);
        }
        tagName = state.input.slice(_position, state.position);
        if (PATTERN_FLOW_INDICATORS.test(tagName)) {
          throwError(state, "tag suffix cannot contain flow indicator characters");
        }
      }
      if (tagName && !PATTERN_TAG_URI.test(tagName)) {
        throwError(state, "tag name cannot contain such characters: " + tagName);
      }
      try {
        tagName = decodeURIComponent(tagName);
      } catch (err) {
        throwError(state, "tag name is malformed: " + tagName);
      }
      if (isVerbatim) {
        state.tag = tagName;
      } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
        state.tag = state.tagMap[tagHandle] + tagName;
      } else if (tagHandle === "!") {
        state.tag = "!" + tagName;
      } else if (tagHandle === "!!") {
        state.tag = "tag:yaml.org,2002:" + tagName;
      } else {
        throwError(state, 'undeclared tag handle "' + tagHandle + '"');
      }
      return true;
    }
    function readAnchorProperty(state) {
      var _position, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 38) return false;
      if (state.anchor !== null) {
        throwError(state, "duplication of an anchor property");
      }
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, "name of an anchor node must contain at least one character");
      }
      state.anchor = state.input.slice(_position, state.position);
      return true;
    }
    function readAlias(state) {
      var _position, alias, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 42) return false;
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, "name of an alias node must contain at least one character");
      }
      alias = state.input.slice(_position, state.position);
      if (!_hasOwnProperty.call(state.anchorMap, alias)) {
        throwError(state, 'unidentified alias "' + alias + '"');
      }
      state.result = state.anchorMap[alias];
      skipSeparationSpace(state, true, -1);
      return true;
    }
    function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
      var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type, flowIndent, blockIndent;
      if (state.listener !== null) {
        state.listener("open", state);
      }
      state.tag = null;
      state.anchor = null;
      state.kind = null;
      state.result = null;
      allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
      if (allowToSeek) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        }
      }
      if (indentStatus === 1) {
        while (readTagProperty(state) || readAnchorProperty(state)) {
          if (skipSeparationSpace(state, true, -1)) {
            atNewLine = true;
            allowBlockCollections = allowBlockStyles;
            if (state.lineIndent > parentIndent) {
              indentStatus = 1;
            } else if (state.lineIndent === parentIndent) {
              indentStatus = 0;
            } else if (state.lineIndent < parentIndent) {
              indentStatus = -1;
            }
          } else {
            allowBlockCollections = false;
          }
        }
      }
      if (allowBlockCollections) {
        allowBlockCollections = atNewLine || allowCompact;
      }
      if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
        if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
          flowIndent = parentIndent;
        } else {
          flowIndent = parentIndent + 1;
        }
        blockIndent = state.position - state.lineStart;
        if (indentStatus === 1) {
          if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
            hasContent = true;
          } else {
            if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
              hasContent = true;
            } else if (readAlias(state)) {
              hasContent = true;
              if (state.tag !== null || state.anchor !== null) {
                throwError(state, "alias node should not have any properties");
              }
            } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
              hasContent = true;
              if (state.tag === null) {
                state.tag = "?";
              }
            }
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
          }
        } else if (indentStatus === 0) {
          hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
        }
      }
      if (state.tag === null) {
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      } else if (state.tag === "?") {
        if (state.result !== null && state.kind !== "scalar") {
          throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
        }
        for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
          type = state.implicitTypes[typeIndex];
          if (type.resolve(state.result)) {
            state.result = type.construct(state.result);
            state.tag = type.tag;
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
            break;
          }
        }
      } else if (state.tag !== "!") {
        if (_hasOwnProperty.call(state.typeMap[state.kind || "fallback"], state.tag)) {
          type = state.typeMap[state.kind || "fallback"][state.tag];
        } else {
          type = null;
          typeList = state.typeMap.multi[state.kind || "fallback"];
          for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
            if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
              type = typeList[typeIndex];
              break;
            }
          }
        }
        if (!type) {
          throwError(state, "unknown tag !<" + state.tag + ">");
        }
        if (state.result !== null && type.kind !== state.kind) {
          throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
        }
        if (!type.resolve(state.result, state.tag)) {
          throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
        } else {
          state.result = type.construct(state.result, state.tag);
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
        }
      }
      if (state.listener !== null) {
        state.listener("close", state);
      }
      return state.tag !== null || state.anchor !== null || hasContent;
    }
    function readDocument(state) {
      var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
      state.version = null;
      state.checkLineBreaks = state.legacy;
      state.tagMap = /* @__PURE__ */ Object.create(null);
      state.anchorMap = /* @__PURE__ */ Object.create(null);
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if (state.lineIndent > 0 || ch !== 37) {
          break;
        }
        hasDirectives = true;
        ch = state.input.charCodeAt(++state.position);
        _position = state.position;
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        directiveName = state.input.slice(_position, state.position);
        directiveArgs = [];
        if (directiveName.length < 1) {
          throwError(state, "directive name must not be less than one character in length");
        }
        while (ch !== 0) {
          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (ch === 35) {
            do {
              ch = state.input.charCodeAt(++state.position);
            } while (ch !== 0 && !is_EOL(ch));
            break;
          }
          if (is_EOL(ch)) break;
          _position = state.position;
          while (ch !== 0 && !is_WS_OR_EOL(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          directiveArgs.push(state.input.slice(_position, state.position));
        }
        if (ch !== 0) readLineBreak(state);
        if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
          directiveHandlers[directiveName](state, directiveName, directiveArgs);
        } else {
          throwWarning(state, 'unknown document directive "' + directiveName + '"');
        }
      }
      skipSeparationSpace(state, true, -1);
      if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      } else if (hasDirectives) {
        throwError(state, "directives end mark is expected");
      }
      composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
      skipSeparationSpace(state, true, -1);
      if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
        throwWarning(state, "non-ASCII line breaks are interpreted as content");
      }
      state.documents.push(state.result);
      if (state.position === state.lineStart && testDocumentSeparator(state)) {
        if (state.input.charCodeAt(state.position) === 46) {
          state.position += 3;
          skipSeparationSpace(state, true, -1);
        }
        return;
      }
      if (state.position < state.length - 1) {
        throwError(state, "end of the stream or a document separator is expected");
      } else {
        return;
      }
    }
    function loadDocuments(input, options) {
      input = String(input);
      options = options || {};
      if (input.length !== 0) {
        if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
          input += "\n";
        }
        if (input.charCodeAt(0) === 65279) {
          input = input.slice(1);
        }
      }
      var state = new State(input, options);
      var nullpos = input.indexOf("\0");
      if (nullpos !== -1) {
        state.position = nullpos;
        throwError(state, "null byte is not allowed in input");
      }
      state.input += "\0";
      while (state.input.charCodeAt(state.position) === 32) {
        state.lineIndent += 1;
        state.position += 1;
      }
      while (state.position < state.length - 1) {
        readDocument(state);
      }
      return state.documents;
    }
    function loadAll(input, iterator, options) {
      if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
        options = iterator;
        iterator = null;
      }
      var documents = loadDocuments(input, options);
      if (typeof iterator !== "function") {
        return documents;
      }
      for (var index = 0, length = documents.length; index < length; index += 1) {
        iterator(documents[index]);
      }
    }
    function load(input, options) {
      var documents = loadDocuments(input, options);
      if (documents.length === 0) {
        return void 0;
      } else if (documents.length === 1) {
        return documents[0];
      }
      throw new YAMLException("expected a single document in the stream, but found more");
    }
    module2.exports.loadAll = loadAll;
    module2.exports.load = load;
  }
});

// .api/apis/zklighter/node_modules/js-yaml/lib/dumper.js
var require_dumper = __commonJS({
  ".api/apis/zklighter/node_modules/js-yaml/lib/dumper.js"(exports, module2) {
    "use strict";
    var common = require_common();
    var YAMLException = require_exception();
    var DEFAULT_SCHEMA = require_default();
    var _toString = Object.prototype.toString;
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var CHAR_BOM = 65279;
    var CHAR_TAB = 9;
    var CHAR_LINE_FEED = 10;
    var CHAR_CARRIAGE_RETURN = 13;
    var CHAR_SPACE = 32;
    var CHAR_EXCLAMATION = 33;
    var CHAR_DOUBLE_QUOTE = 34;
    var CHAR_SHARP = 35;
    var CHAR_PERCENT = 37;
    var CHAR_AMPERSAND = 38;
    var CHAR_SINGLE_QUOTE = 39;
    var CHAR_ASTERISK = 42;
    var CHAR_COMMA = 44;
    var CHAR_MINUS = 45;
    var CHAR_COLON = 58;
    var CHAR_EQUALS = 61;
    var CHAR_GREATER_THAN = 62;
    var CHAR_QUESTION = 63;
    var CHAR_COMMERCIAL_AT = 64;
    var CHAR_LEFT_SQUARE_BRACKET = 91;
    var CHAR_RIGHT_SQUARE_BRACKET = 93;
    var CHAR_GRAVE_ACCENT = 96;
    var CHAR_LEFT_CURLY_BRACKET = 123;
    var CHAR_VERTICAL_LINE = 124;
    var CHAR_RIGHT_CURLY_BRACKET = 125;
    var ESCAPE_SEQUENCES = {};
    ESCAPE_SEQUENCES[0] = "\\0";
    ESCAPE_SEQUENCES[7] = "\\a";
    ESCAPE_SEQUENCES[8] = "\\b";
    ESCAPE_SEQUENCES[9] = "\\t";
    ESCAPE_SEQUENCES[10] = "\\n";
    ESCAPE_SEQUENCES[11] = "\\v";
    ESCAPE_SEQUENCES[12] = "\\f";
    ESCAPE_SEQUENCES[13] = "\\r";
    ESCAPE_SEQUENCES[27] = "\\e";
    ESCAPE_SEQUENCES[34] = '\\"';
    ESCAPE_SEQUENCES[92] = "\\\\";
    ESCAPE_SEQUENCES[133] = "\\N";
    ESCAPE_SEQUENCES[160] = "\\_";
    ESCAPE_SEQUENCES[8232] = "\\L";
    ESCAPE_SEQUENCES[8233] = "\\P";
    var DEPRECATED_BOOLEANS_SYNTAX = [
      "y",
      "Y",
      "yes",
      "Yes",
      "YES",
      "on",
      "On",
      "ON",
      "n",
      "N",
      "no",
      "No",
      "NO",
      "off",
      "Off",
      "OFF"
    ];
    var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
    function compileStyleMap(schema, map) {
      var result, keys, index, length, tag, style, type;
      if (map === null) return {};
      result = {};
      keys = Object.keys(map);
      for (index = 0, length = keys.length; index < length; index += 1) {
        tag = keys[index];
        style = String(map[tag]);
        if (tag.slice(0, 2) === "!!") {
          tag = "tag:yaml.org,2002:" + tag.slice(2);
        }
        type = schema.compiledTypeMap["fallback"][tag];
        if (type && _hasOwnProperty.call(type.styleAliases, style)) {
          style = type.styleAliases[style];
        }
        result[tag] = style;
      }
      return result;
    }
    function encodeHex(character) {
      var string, handle, length;
      string = character.toString(16).toUpperCase();
      if (character <= 255) {
        handle = "x";
        length = 2;
      } else if (character <= 65535) {
        handle = "u";
        length = 4;
      } else if (character <= 4294967295) {
        handle = "U";
        length = 8;
      } else {
        throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
      }
      return "\\" + handle + common.repeat("0", length - string.length) + string;
    }
    var QUOTING_TYPE_SINGLE = 1;
    var QUOTING_TYPE_DOUBLE = 2;
    function State(options) {
      this.schema = options["schema"] || DEFAULT_SCHEMA;
      this.indent = Math.max(1, options["indent"] || 2);
      this.noArrayIndent = options["noArrayIndent"] || false;
      this.skipInvalid = options["skipInvalid"] || false;
      this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
      this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
      this.sortKeys = options["sortKeys"] || false;
      this.lineWidth = options["lineWidth"] || 80;
      this.noRefs = options["noRefs"] || false;
      this.noCompatMode = options["noCompatMode"] || false;
      this.condenseFlow = options["condenseFlow"] || false;
      this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
      this.forceQuotes = options["forceQuotes"] || false;
      this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
      this.implicitTypes = this.schema.compiledImplicit;
      this.explicitTypes = this.schema.compiledExplicit;
      this.tag = null;
      this.result = "";
      this.duplicates = [];
      this.usedDuplicates = null;
    }
    function indentString(string, spaces) {
      var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
      while (position < length) {
        next = string.indexOf("\n", position);
        if (next === -1) {
          line = string.slice(position);
          position = length;
        } else {
          line = string.slice(position, next + 1);
          position = next + 1;
        }
        if (line.length && line !== "\n") result += ind;
        result += line;
      }
      return result;
    }
    function generateNextLine(state, level) {
      return "\n" + common.repeat(" ", state.indent * level);
    }
    function testImplicitResolving(state, str) {
      var index, length, type;
      for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
        type = state.implicitTypes[index];
        if (type.resolve(str)) {
          return true;
        }
      }
      return false;
    }
    function isWhitespace(c) {
      return c === CHAR_SPACE || c === CHAR_TAB;
    }
    function isPrintable(c) {
      return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
    }
    function isNsCharOrWhitespace(c) {
      return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
    }
    function isPlainSafe(c, prev, inblock) {
      var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
      var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
      return (
        // ns-plain-safe
        (inblock ? (
          // c = flow-in
          cIsNsCharOrWhitespace
        ) : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
      );
    }
    function isPlainSafeFirst(c) {
      return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
    }
    function isPlainSafeLast(c) {
      return !isWhitespace(c) && c !== CHAR_COLON;
    }
    function codePointAt(string, pos) {
      var first = string.charCodeAt(pos), second;
      if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
        second = string.charCodeAt(pos + 1);
        if (second >= 56320 && second <= 57343) {
          return (first - 55296) * 1024 + second - 56320 + 65536;
        }
      }
      return first;
    }
    function needIndentIndicator(string) {
      var leadingSpaceRe = /^\n* /;
      return leadingSpaceRe.test(string);
    }
    var STYLE_PLAIN = 1;
    var STYLE_SINGLE = 2;
    var STYLE_LITERAL = 3;
    var STYLE_FOLDED = 4;
    var STYLE_DOUBLE = 5;
    function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
      var i;
      var char = 0;
      var prevChar = null;
      var hasLineBreak = false;
      var hasFoldableLine = false;
      var shouldTrackWidth = lineWidth !== -1;
      var previousLineBreak = -1;
      var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
      if (singleLineOnly || forceQuotes) {
        for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
          char = codePointAt(string, i);
          if (!isPrintable(char)) {
            return STYLE_DOUBLE;
          }
          plain = plain && isPlainSafe(char, prevChar, inblock);
          prevChar = char;
        }
      } else {
        for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
          char = codePointAt(string, i);
          if (char === CHAR_LINE_FEED) {
            hasLineBreak = true;
            if (shouldTrackWidth) {
              hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
              i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
              previousLineBreak = i;
            }
          } else if (!isPrintable(char)) {
            return STYLE_DOUBLE;
          }
          plain = plain && isPlainSafe(char, prevChar, inblock);
          prevChar = char;
        }
        hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
      }
      if (!hasLineBreak && !hasFoldableLine) {
        if (plain && !forceQuotes && !testAmbiguousType(string)) {
          return STYLE_PLAIN;
        }
        return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
      }
      if (indentPerLevel > 9 && needIndentIndicator(string)) {
        return STYLE_DOUBLE;
      }
      if (!forceQuotes) {
        return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
      }
      return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
    }
    function writeScalar(state, string, level, iskey, inblock) {
      state.dump = function() {
        if (string.length === 0) {
          return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
        }
        if (!state.noCompatMode) {
          if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
            return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
          }
        }
        var indent = state.indent * Math.max(1, level);
        var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
        var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
        function testAmbiguity(string2) {
          return testImplicitResolving(state, string2);
        }
        switch (chooseScalarStyle(
          string,
          singleLineOnly,
          state.indent,
          lineWidth,
          testAmbiguity,
          state.quotingType,
          state.forceQuotes && !iskey,
          inblock
        )) {
          case STYLE_PLAIN:
            return string;
          case STYLE_SINGLE:
            return "'" + string.replace(/'/g, "''") + "'";
          case STYLE_LITERAL:
            return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
          case STYLE_FOLDED:
            return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
          case STYLE_DOUBLE:
            return '"' + escapeString2(string, lineWidth) + '"';
          default:
            throw new YAMLException("impossible error: invalid scalar style");
        }
      }();
    }
    function blockHeader(string, indentPerLevel) {
      var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
      var clip = string[string.length - 1] === "\n";
      var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
      var chomp = keep ? "+" : clip ? "" : "-";
      return indentIndicator + chomp + "\n";
    }
    function dropEndingNewline(string) {
      return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
    }
    function foldString(string, width) {
      var lineRe = /(\n+)([^\n]*)/g;
      var result = function() {
        var nextLF = string.indexOf("\n");
        nextLF = nextLF !== -1 ? nextLF : string.length;
        lineRe.lastIndex = nextLF;
        return foldLine(string.slice(0, nextLF), width);
      }();
      var prevMoreIndented = string[0] === "\n" || string[0] === " ";
      var moreIndented;
      var match2;
      while (match2 = lineRe.exec(string)) {
        var prefix = match2[1], line = match2[2];
        moreIndented = line[0] === " ";
        result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
        prevMoreIndented = moreIndented;
      }
      return result;
    }
    function foldLine(line, width) {
      if (line === "" || line[0] === " ") return line;
      var breakRe = / [^ ]/g;
      var match2;
      var start = 0, end, curr = 0, next = 0;
      var result = "";
      while (match2 = breakRe.exec(line)) {
        next = match2.index;
        if (next - start > width) {
          end = curr > start ? curr : next;
          result += "\n" + line.slice(start, end);
          start = end + 1;
        }
        curr = next;
      }
      result += "\n";
      if (line.length - start > width && curr > start) {
        result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
      } else {
        result += line.slice(start);
      }
      return result.slice(1);
    }
    function escapeString2(string) {
      var result = "";
      var char = 0;
      var escapeSeq;
      for (var i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
        char = codePointAt(string, i);
        escapeSeq = ESCAPE_SEQUENCES[char];
        if (!escapeSeq && isPrintable(char)) {
          result += string[i];
          if (char >= 65536) result += string[i + 1];
        } else {
          result += escapeSeq || encodeHex(char);
        }
      }
      return result;
    }
    function writeFlowSequence(state, level, object) {
      var _result = "", _tag = state.tag, index, length, value;
      for (index = 0, length = object.length; index < length; index += 1) {
        value = object[index];
        if (state.replacer) {
          value = state.replacer.call(object, String(index), value);
        }
        if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
          if (_result !== "") _result += "," + (!state.condenseFlow ? " " : "");
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = "[" + _result + "]";
    }
    function writeBlockSequence(state, level, object, compact) {
      var _result = "", _tag = state.tag, index, length, value;
      for (index = 0, length = object.length; index < length; index += 1) {
        value = object[index];
        if (state.replacer) {
          value = state.replacer.call(object, String(index), value);
        }
        if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
          if (!compact || _result !== "") {
            _result += generateNextLine(state, level);
          }
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            _result += "-";
          } else {
            _result += "- ";
          }
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = _result || "[]";
    }
    function writeFlowMapping(state, level, object) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
      for (index = 0, length = objectKeyList.length; index < length; index += 1) {
        pairBuffer = "";
        if (_result !== "") pairBuffer += ", ";
        if (state.condenseFlow) pairBuffer += '"';
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (state.replacer) {
          objectValue = state.replacer.call(object, objectKey, objectValue);
        }
        if (!writeNode(state, level, objectKey, false, false)) {
          continue;
        }
        if (state.dump.length > 1024) pairBuffer += "? ";
        pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
        if (!writeNode(state, level, objectValue, false, false)) {
          continue;
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = "{" + _result + "}";
    }
    function writeBlockMapping(state, level, object, compact) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
      if (state.sortKeys === true) {
        objectKeyList.sort();
      } else if (typeof state.sortKeys === "function") {
        objectKeyList.sort(state.sortKeys);
      } else if (state.sortKeys) {
        throw new YAMLException("sortKeys must be a boolean or a function");
      }
      for (index = 0, length = objectKeyList.length; index < length; index += 1) {
        pairBuffer = "";
        if (!compact || _result !== "") {
          pairBuffer += generateNextLine(state, level);
        }
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (state.replacer) {
          objectValue = state.replacer.call(object, objectKey, objectValue);
        }
        if (!writeNode(state, level + 1, objectKey, true, true, true)) {
          continue;
        }
        explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
        if (explicitPair) {
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            pairBuffer += "?";
          } else {
            pairBuffer += "? ";
          }
        }
        pairBuffer += state.dump;
        if (explicitPair) {
          pairBuffer += generateNextLine(state, level);
        }
        if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
          continue;
        }
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += ":";
        } else {
          pairBuffer += ": ";
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = _result || "{}";
    }
    function detectType(state, object, explicit) {
      var _result, typeList, index, length, type, style;
      typeList = explicit ? state.explicitTypes : state.implicitTypes;
      for (index = 0, length = typeList.length; index < length; index += 1) {
        type = typeList[index];
        if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === "object" && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
          if (explicit) {
            if (type.multi && type.representName) {
              state.tag = type.representName(object);
            } else {
              state.tag = type.tag;
            }
          } else {
            state.tag = "?";
          }
          if (type.represent) {
            style = state.styleMap[type.tag] || type.defaultStyle;
            if (_toString.call(type.represent) === "[object Function]") {
              _result = type.represent(object, style);
            } else if (_hasOwnProperty.call(type.represent, style)) {
              _result = type.represent[style](object, style);
            } else {
              throw new YAMLException("!<" + type.tag + '> tag resolver accepts not "' + style + '" style');
            }
            state.dump = _result;
          }
          return true;
        }
      }
      return false;
    }
    function writeNode(state, level, object, block, compact, iskey, isblockseq) {
      state.tag = null;
      state.dump = object;
      if (!detectType(state, object, false)) {
        detectType(state, object, true);
      }
      var type = _toString.call(state.dump);
      var inblock = block;
      var tagStr;
      if (block) {
        block = state.flowLevel < 0 || state.flowLevel > level;
      }
      var objectOrArray = type === "[object Object]" || type === "[object Array]", duplicateIndex, duplicate;
      if (objectOrArray) {
        duplicateIndex = state.duplicates.indexOf(object);
        duplicate = duplicateIndex !== -1;
      }
      if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
        compact = false;
      }
      if (duplicate && state.usedDuplicates[duplicateIndex]) {
        state.dump = "*ref_" + duplicateIndex;
      } else {
        if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
          state.usedDuplicates[duplicateIndex] = true;
        }
        if (type === "[object Object]") {
          if (block && Object.keys(state.dump).length !== 0) {
            writeBlockMapping(state, level, state.dump, compact);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowMapping(state, level, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type === "[object Array]") {
          if (block && state.dump.length !== 0) {
            if (state.noArrayIndent && !isblockseq && level > 0) {
              writeBlockSequence(state, level - 1, state.dump, compact);
            } else {
              writeBlockSequence(state, level, state.dump, compact);
            }
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowSequence(state, level, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type === "[object String]") {
          if (state.tag !== "?") {
            writeScalar(state, state.dump, level, iskey, inblock);
          }
        } else if (type === "[object Undefined]") {
          return false;
        } else {
          if (state.skipInvalid) return false;
          throw new YAMLException("unacceptable kind of an object to dump " + type);
        }
        if (state.tag !== null && state.tag !== "?") {
          tagStr = encodeURI(
            state.tag[0] === "!" ? state.tag.slice(1) : state.tag
          ).replace(/!/g, "%21");
          if (state.tag[0] === "!") {
            tagStr = "!" + tagStr;
          } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
            tagStr = "!!" + tagStr.slice(18);
          } else {
            tagStr = "!<" + tagStr + ">";
          }
          state.dump = tagStr + " " + state.dump;
        }
      }
      return true;
    }
    function getDuplicateReferences(object, state) {
      var objects = [], duplicatesIndexes = [], index, length;
      inspectNode(object, objects, duplicatesIndexes);
      for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
        state.duplicates.push(objects[duplicatesIndexes[index]]);
      }
      state.usedDuplicates = new Array(length);
    }
    function inspectNode(object, objects, duplicatesIndexes) {
      var objectKeyList, index, length;
      if (object !== null && typeof object === "object") {
        index = objects.indexOf(object);
        if (index !== -1) {
          if (duplicatesIndexes.indexOf(index) === -1) {
            duplicatesIndexes.push(index);
          }
        } else {
          objects.push(object);
          if (Array.isArray(object)) {
            for (index = 0, length = object.length; index < length; index += 1) {
              inspectNode(object[index], objects, duplicatesIndexes);
            }
          } else {
            objectKeyList = Object.keys(object);
            for (index = 0, length = objectKeyList.length; index < length; index += 1) {
              inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
            }
          }
        }
      }
    }
    function dump(input, options) {
      options = options || {};
      var state = new State(options);
      if (!state.noRefs) getDuplicateReferences(input, state);
      var value = input;
      if (state.replacer) {
        value = state.replacer.call({ "": value }, "", value);
      }
      if (writeNode(state, 0, value, true, true)) return state.dump + "\n";
      return "";
    }
    module2.exports.dump = dump;
  }
});

// .api/apis/zklighter/node_modules/js-yaml/index.js
var require_js_yaml = __commonJS({
  ".api/apis/zklighter/node_modules/js-yaml/index.js"(exports, module2) {
    "use strict";
    var loader = require_loader();
    var dumper = require_dumper();
    function renamed(from, to) {
      return function() {
        throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
      };
    }
    module2.exports.Type = require_type();
    module2.exports.Schema = require_schema();
    module2.exports.FAILSAFE_SCHEMA = require_failsafe();
    module2.exports.JSON_SCHEMA = require_json2();
    module2.exports.CORE_SCHEMA = require_core();
    module2.exports.DEFAULT_SCHEMA = require_default();
    module2.exports.load = loader.load;
    module2.exports.loadAll = loader.loadAll;
    module2.exports.dump = dumper.dump;
    module2.exports.YAMLException = require_exception();
    module2.exports.types = {
      binary: require_binary2(),
      float: require_float(),
      map: require_map(),
      null: require_null(),
      pairs: require_pairs(),
      set: require_set(),
      timestamp: require_timestamp(),
      bool: require_bool(),
      int: require_int(),
      merge: require_merge(),
      omap: require_omap(),
      seq: require_seq(),
      str: require_str()
    };
    module2.exports.safeLoad = renamed("safeLoad", "load");
    module2.exports.safeLoadAll = renamed("safeLoadAll", "loadAll");
    module2.exports.safeDump = renamed("safeDump", "dump");
  }
});

// .api/apis/zklighter/node_modules/@readme/json-schema-ref-parser/lib/parsers/yaml.js
var require_yaml = __commonJS({
  ".api/apis/zklighter/node_modules/@readme/json-schema-ref-parser/lib/parsers/yaml.js"(exports, module2) {
    var yaml = require_js_yaml();
    var { JSON_SCHEMA } = require_js_yaml();
    var { ParserError } = require_errors();
    module2.exports = {
      /**
       * The order that this parser will run, in relation to other parsers.
       *
       * @type {number}
       */
      order: 200,
      /**
       * Whether to allow "empty" files. This includes zero-byte files, as well as empty JSON objects.
       *
       * @type {boolean}
       */
      allowEmpty: true,
      /**
       * Determines whether this parser can parse a given file reference.
       * Parsers that match will be tried, in order, until one successfully parses the file.
       * Parsers that don't match will be skipped, UNLESS none of the parsers match, in which case
       * every parser will be tried.
       *
       * @type {RegExp|string[]|function}
       */
      canParse: [".yaml", ".yml", ".json"],
      // JSON is valid YAML
      /**
       * Parses the given file as YAML
       *
       * @param {object} file           - An object containing information about the referenced file
       * @param {string} file.url       - The full URL of the referenced file
       * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
       * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
       * @returns {Promise}
       */
      // eslint-disable-next-line require-await
      async parse(file) {
        let data = file.data;
        if (Buffer.isBuffer(data)) {
          data = data.toString();
        }
        if (typeof data === "string") {
          try {
            return yaml.load(data, { schema: JSON_SCHEMA });
          } catch (e) {
            throw new ParserError(e.message, file.url);
          }
        }
        return data;
      }
    };
  }
});

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// .api/apis/zklighter/node_modules/@readme/json-schema-ref-parser/lib/resolvers/file.js
var require_file = __commonJS({
  ".api/apis/zklighter/node_modules/@readme/json-schema-ref-parser/lib/resolvers/file.js"(exports, module2) {
    var fs = require_fs();
    var { ono: ono2 } = (init_esm(), __toCommonJS(esm_exports));
    var { ResolverError } = require_errors();
    var url = require_url2();
    module2.exports = {
      /**
       * The order that this resolver will run, in relation to other resolvers.
       *
       * @type {number}
       */
      order: 100,
      /**
       * Determines whether this resolver can read a given file reference.
       * Resolvers that return true will be tried, in order, until one successfully resolves the file.
       * Resolvers that return false will not be given a chance to resolve the file.
       *
       * @param {object} file           - An object containing information about the referenced file
       * @param {string} file.url       - The full URL of the referenced file
       * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
       * @returns {boolean}
       */
      canRead(file) {
        return url.isFileSystemPath(file.url);
      },
      /**
       * Reads the given file and returns its raw contents as a Buffer.
       *
       * @param {object} file           - An object containing information about the referenced file
       * @param {string} file.url       - The full URL of the referenced file
       * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
       * @returns {Promise<Buffer>}
       */
      read(file) {
        return new Promise((resolve, reject) => {
          let path;
          try {
            path = url.toFileSystemPath(file.url);
          } catch (err) {
            reject(new ResolverError(ono2.uri(err, `Malformed URI: ${file.url}`), file.url));
          }
          try {
            fs.readFile(path, (err, data) => {
              if (err) {
                reject(new ResolverError(ono2(err, `Error opening file "${path}"`), path));
              } else {
                resolve(data);
              }
            });
          } catch (err) {
            reject(new ResolverError(ono2(err, `Error opening file "${path}"`), path));
          }
        });
      }
    };
  }
});

// browser-external:http
var require_http = __commonJS({
  "browser-external:http"(exports, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "http" has been externalized for browser compatibility. Cannot access "http.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:https
var require_https = __commonJS({
  "browser-external:https"(exports, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "https" has been externalized for browser compatibility. Cannot access "https.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// .api/apis/zklighter/node_modules/@readme/json-schema-ref-parser/lib/resolvers/http.js
var require_http2 = __commonJS({
  ".api/apis/zklighter/node_modules/@readme/json-schema-ref-parser/lib/resolvers/http.js"(exports, module2) {
    var http = require_http();
    var https = require_https();
    var { ono: ono2 } = (init_esm(), __toCommonJS(esm_exports));
    var { ResolverError } = require_errors();
    var url = require_url2();
    function get(u, httpOptions) {
      return new Promise((resolve, reject) => {
        const protocol = u.protocol === "https:" ? https : http;
        const req = protocol.get({
          hostname: u.hostname,
          port: u.port,
          path: u.path,
          auth: u.auth,
          protocol: u.protocol,
          headers: httpOptions.headers || {},
          withCredentials: httpOptions.withCredentials
        });
        if (typeof req.setTimeout === "function") {
          req.setTimeout(httpOptions.timeout);
        }
        req.on("timeout", () => {
          req.abort();
        });
        req.on("error", reject);
        req.once("response", (res) => {
          res.body = Buffer.alloc(0);
          res.on("data", (data) => {
            res.body = Buffer.concat([res.body, Buffer.from(data)]);
          });
          res.on("error", reject);
          res.on("end", () => {
            resolve(res);
          });
        });
      });
    }
    function download(u, httpOptions, redirects) {
      return new Promise((resolve, reject) => {
        u = url.parse(u);
        redirects = redirects || [];
        redirects.push(u.href);
        get(u, httpOptions).then((res) => {
          if (res.statusCode >= 400) {
            throw ono2({ status: res.statusCode }, `HTTP ERROR ${res.statusCode}`);
          } else if (res.statusCode >= 300) {
            if (redirects.length > httpOptions.redirects) {
              reject(
                new ResolverError(
                  ono2(
                    { status: res.statusCode },
                    `Error downloading ${redirects[0]}. 
Too many redirects: 
  ${redirects.join(" \n  ")}`
                  )
                )
              );
            } else if (!res.headers.location) {
              throw ono2({ status: res.statusCode }, `HTTP ${res.statusCode} redirect with no location header`);
            } else {
              const redirectTo = url.resolve(u, res.headers.location);
              download(redirectTo, httpOptions, redirects).then(resolve, reject);
            }
          } else {
            resolve(res.body || Buffer.alloc(0));
          }
        }).catch((err) => {
          reject(new ResolverError(ono2(err, `Error downloading ${u.href}`), u.href));
        });
      });
    }
    module2.exports = {
      /**
       * The order that this resolver will run, in relation to other resolvers.
       *
       * @type {number}
       */
      order: 200,
      /**
       * HTTP headers to send when downloading files.
       *
       * @example:
       * {
       *   "User-Agent": "JSON Schema $Ref Parser",
       *   Accept: "application/json"
       * }
       *
       * @type {object}
       */
      headers: null,
      /**
       * HTTP request timeout (in milliseconds).
       *
       * @type {number}
       */
      timeout: 5e3,
      // 5 seconds
      /**
       * The maximum number of HTTP redirects to follow.
       * To disable automatic following of redirects, set this to zero.
       *
       * @type {number}
       */
      redirects: 5,
      /**
       * The `withCredentials` option of XMLHttpRequest.
       * Set this to `true` if you're downloading files from a CORS-enabled server that requires authentication
       *
       * @type {boolean}
       */
      withCredentials: false,
      /**
       * Determines whether this resolver can read a given file reference.
       * Resolvers that return true will be tried in order, until one successfully resolves the file.
       * Resolvers that return false will not be given a chance to resolve the file.
       *
       * @param {object} file           - An object containing information about the referenced file
       * @param {string} file.url       - The full URL of the referenced file
       * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
       * @returns {boolean}
       */
      canRead(file) {
        return url.isHttp(file.url);
      },
      /**
       * Reads the given URL and returns its raw contents as a Buffer.
       *
       * @param {object} file           - An object containing information about the referenced file
       * @param {string} file.url       - The full URL of the referenced file
       * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
       * @returns {Promise<Buffer>}
       */
      read(file) {
        const u = url.parse(file.url);
        if (process.browser && !u.protocol) {
          u.protocol = url.parse(location.href).protocol;
        }
        return download(u, this);
      }
    };
  }
});

// .api/apis/zklighter/node_modules/@readme/json-schema-ref-parser/lib/options.js
var require_options = __commonJS({
  ".api/apis/zklighter/node_modules/@readme/json-schema-ref-parser/lib/options.js"(exports, module2) {
    var binaryParser = require_binary();
    var jsonParser = require_json();
    var textParser = require_text();
    var yamlParser = require_yaml();
    var fileResolver = require_file();
    var httpResolver = require_http2();
    module2.exports = $RefParserOptions;
    function $RefParserOptions(options) {
      merge(this, $RefParserOptions.defaults);
      merge(this, options);
    }
    $RefParserOptions.defaults = {
      /**
       * Determines how different types of files will be parsed.
       *
       * You can add additional parsers of your own, replace an existing one with
       * your own implementation, or disable any parser by setting it to false.
       */
      parse: {
        json: jsonParser,
        yaml: yamlParser,
        text: textParser,
        binary: binaryParser
      },
      /**
       * Determines how JSON References will be resolved.
       *
       * You can add additional resolvers of your own, replace an existing one with
       * your own implementation, or disable any resolver by setting it to false.
       */
      resolve: {
        file: fileResolver,
        http: httpResolver,
        /**
         * Determines whether external $ref pointers will be resolved.
         * If this option is disabled, then none of above resolvers will be called.
         * Instead, external $ref pointers will simply be ignored.
         *
         * @type {boolean}
         */
        external: true
      },
      /**
       * By default, JSON Schema $Ref Parser throws the first error it encounters. Setting `continueOnError` to `true`
       * causes it to keep processing as much as possible and then throw a single error that contains all errors
       * that were encountered.
       */
      continueOnError: false,
      /**
       * Determines the types of JSON references that are allowed.
       */
      dereference: {
        /**
         * Dereference circular (recursive) JSON references?
         * If false, then a {@link ReferenceError} will be thrown if a circular reference is found.
         * If "ignore", then circular references will not be dereferenced.
         *
         * @type {boolean|string}
         */
        circular: true
      }
    };
    function merge(target, source) {
      if (isMergeable(source)) {
        const keys = Object.keys(source);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const sourceSetting = source[key];
          const targetSetting = target[key];
          if (isMergeable(sourceSetting)) {
            target[key] = merge(targetSetting || {}, sourceSetting);
          } else if (sourceSetting !== void 0) {
            target[key] = sourceSetting;
          }
        }
      }
      return target;
    }
    function isMergeable(val) {
      return val && typeof val === "object" && !Array.isArray(val) && !(val instanceof RegExp) && !(val instanceof Date);
    }
  }
});

// .api/apis/zklighter/node_modules/@readme/json-schema-ref-parser/lib/normalize-args.js
var require_normalize_args = __commonJS({
  ".api/apis/zklighter/node_modules/@readme/json-schema-ref-parser/lib/normalize-args.js"(exports, module2) {
    var Options = require_options();
    module2.exports = function normalizeArgs2(args) {
      let path;
      let schema;
      let options;
      let callback;
      args = Array.prototype.slice.call(args);
      if (typeof args[args.length - 1] === "function") {
        callback = args.pop();
      }
      if (typeof args[0] === "string") {
        path = args[0];
        if (typeof args[2] === "object") {
          schema = args[1];
          options = args[2];
        } else {
          schema = void 0;
          options = args[1];
        }
      } else {
        path = "";
        schema = args[0];
        options = args[1];
      }
      if (!(options instanceof Options)) {
        options = new Options(options);
      }
      return {
        path,
        schema,
        options,
        callback
      };
    };
  }
});

// .api/apis/zklighter/node_modules/@readme/json-schema-ref-parser/lib/util/plugins.js
var require_plugins = __commonJS({
  ".api/apis/zklighter/node_modules/@readme/json-schema-ref-parser/lib/util/plugins.js"(exports) {
    exports.all = function(plugins) {
      return Object.keys(plugins).filter((key) => {
        return typeof plugins[key] === "object";
      }).map((key) => {
        plugins[key].name = key;
        return plugins[key];
      });
    };
    exports.filter = function(plugins, method, file) {
      return plugins.filter((plugin) => {
        return !!getResult(plugin, method, file);
      });
    };
    exports.sort = function(plugins) {
      for (const plugin of plugins) {
        plugin.order = plugin.order || Number.MAX_SAFE_INTEGER;
      }
      return plugins.sort((a, b) => {
        return a.order - b.order;
      });
    };
    exports.run = function(plugins, method, file, $refs) {
      let plugin;
      let lastError;
      let index = 0;
      return new Promise((resolve, reject) => {
        runNextPlugin();
        function runNextPlugin() {
          plugin = plugins[index++];
          if (!plugin) {
            return reject(lastError);
          }
          try {
            const result = getResult(plugin, method, file, callback, $refs);
            if (result && typeof result.then === "function") {
              result.then(onSuccess, onError);
            } else if (result !== void 0) {
              onSuccess(result);
            } else if (index === plugins.length) {
              throw new Error("No promise has been returned or callback has been called.");
            }
          } catch (e) {
            onError(e);
          }
        }
        function callback(err, result) {
          if (err) {
            onError(err);
          } else {
            onSuccess(result);
          }
        }
        function onSuccess(result) {
          resolve({
            plugin,
            result
          });
        }
        function onError(error) {
          lastError = {
            plugin,
            error
          };
          runNextPlugin();
        }
      });
    };
    function getResult(obj, prop, file, callback, $refs) {
      const value = obj[prop];
      if (typeof value === "function") {
        return value.apply(obj, [file, callback, $refs]);
      }
      if (!callback) {
        if (value instanceof RegExp) {
          return value.test(file.url);
        } else if (typeof value === "string") {
          return value === file.extension;
        } else if (Array.isArray(value)) {
          return value.indexOf(file.extension) !== -1;
        }
      }
      return value;
    }
  }
});

// .api/apis/zklighter/node_modules/@readme/json-schema-ref-parser/lib/parse.js
var require_parse = __commonJS({
  ".api/apis/zklighter/node_modules/@readme/json-schema-ref-parser/lib/parse.js"(exports, module2) {
    var { ono: ono2 } = (init_esm(), __toCommonJS(esm_exports));
    var {
      ResolverError,
      ParserError,
      UnmatchedParserError,
      UnmatchedResolverError,
      isHandledError
    } = require_errors();
    var plugins = require_plugins();
    var url = require_url2();
    module2.exports = async function parse2(path, $refs, options) {
      path = url.stripHash(path);
      const $ref = $refs._add(path);
      const file = {
        url: path,
        extension: url.getExtension(path)
      };
      try {
        const resolver = await readFile(file, options, $refs);
        $ref.pathType = resolver.plugin.name;
        file.data = resolver.result;
        const parser = await parseFile(file, options, $refs);
        $ref.value = parser.result;
        return parser.result;
      } catch (err) {
        if (isHandledError(err)) {
          $ref.value = err;
        }
        throw err;
      }
    };
    function readFile(file, options, $refs) {
      return new Promise((resolve, reject) => {
        let resolvers = plugins.all(options.resolve);
        resolvers = plugins.filter(resolvers, "canRead", file);
        plugins.sort(resolvers);
        plugins.run(resolvers, "read", file, $refs).then(resolve, onError);
        function onError(err) {
          if (!err && options.continueOnError) {
            reject(new UnmatchedResolverError(file.url));
          } else if (!err || !("error" in err)) {
            reject(ono2.syntax(`Unable to resolve $ref pointer "${file.url}"`));
          } else if (err.error instanceof ResolverError) {
            reject(err.error);
          } else {
            reject(new ResolverError(err, file.url));
          }
        }
      });
    }
    function parseFile(file, options, $refs) {
      return new Promise((resolve, reject) => {
        const allParsers = plugins.all(options.parse);
        const filteredParsers = plugins.filter(allParsers, "canParse", file);
        const parsers = filteredParsers.length > 0 ? filteredParsers : allParsers;
        plugins.sort(parsers);
        plugins.run(parsers, "parse", file, $refs).then(onParsed, onError);
        function onParsed(parser) {
          if (!parser.plugin.allowEmpty && isEmpty(parser.result)) {
            reject(ono2.syntax(`Error parsing "${file.url}" as ${parser.plugin.name}. 
Parsed value is empty`));
          } else {
            resolve(parser);
          }
        }
        function onError(err) {
          if (!err && options.continueOnError) {
            reject(new UnmatchedParserError(file.url));
          } else if (!err || !("error" in err)) {
            reject(ono2.syntax(`Unable to parse ${file.url}`));
          } else if (err.error instanceof ParserError) {
            reject(err.error);
          } else {
            reject(new ParserError(err.error.message, file.url));
          }
        }
      });
    }
    function isEmpty(value) {
      return value === void 0 || typeof value === "object" && Object.keys(value).length === 0 || typeof value === "string" && value.trim().length === 0 || Buffer.isBuffer(value) && value.length === 0;
    }
  }
});

// .api/apis/zklighter/node_modules/@readme/json-schema-ref-parser/lib/refs.js
var require_refs = __commonJS({
  ".api/apis/zklighter/node_modules/@readme/json-schema-ref-parser/lib/refs.js"(exports, module2) {
    var { ono: ono2 } = (init_esm(), __toCommonJS(esm_exports));
    var $Ref = require_ref();
    var url = require_url2();
    module2.exports = $Refs;
    function $Refs() {
      this.circular = false;
      this.circularRefs = [];
      this._$refs = {};
      this._root$Ref = null;
    }
    $Refs.prototype.paths = function(types) {
      const paths = getPaths(this._$refs, arguments);
      return paths.map((path) => {
        return path.decoded;
      });
    };
    $Refs.prototype.values = function(types) {
      const $refs = this._$refs;
      const paths = getPaths($refs, arguments);
      return paths.reduce((obj, path) => {
        obj[path.decoded] = $refs[path.encoded].value;
        return obj;
      }, {});
    };
    $Refs.prototype.toJSON = $Refs.prototype.values;
    $Refs.prototype.exists = function(path, options) {
      try {
        this._resolve(path, "", options);
        return true;
      } catch (e) {
        return false;
      }
    };
    $Refs.prototype.get = function(path, options) {
      return this._resolve(path, "", options).value;
    };
    $Refs.prototype.set = function(path, value) {
      const absPath = url.resolve(this._root$Ref.path, path);
      const withoutHash = url.stripHash(absPath);
      const $ref = this._$refs[withoutHash];
      if (!$ref) {
        throw ono2(`Error resolving $ref pointer "${path}". 
"${withoutHash}" not found.`);
      }
      $ref.set(absPath, value);
    };
    $Refs.prototype._add = function(path) {
      const withoutHash = url.stripHash(path);
      const $ref = new $Ref();
      $ref.path = withoutHash;
      $ref.$refs = this;
      this._$refs[withoutHash] = $ref;
      this._root$Ref = this._root$Ref || $ref;
      return $ref;
    };
    $Refs.prototype._resolve = function(path, pathFromRoot, options) {
      const absPath = url.resolve(this._root$Ref.path, path);
      const withoutHash = url.stripHash(absPath);
      const $ref = this._$refs[withoutHash];
      if (!$ref) {
        throw ono2(`Error resolving $ref pointer "${path}". 
"${withoutHash}" not found.`);
      }
      return $ref.resolve(absPath, options, path, pathFromRoot);
    };
    $Refs.prototype._get$Ref = function(path) {
      path = url.resolve(this._root$Ref.path, path);
      const withoutHash = url.stripHash(path);
      return this._$refs[withoutHash];
    };
    function getPaths($refs, types) {
      let paths = Object.keys($refs);
      types = Array.isArray(types[0]) ? types[0] : Array.prototype.slice.call(types);
      if (types.length > 0 && types[0]) {
        paths = paths.filter((key) => {
          return types.indexOf($refs[key].pathType) !== -1;
        });
      }
      return paths.map((path) => {
        return {
          encoded: path,
          decoded: $refs[path].pathType === "file" ? url.toFileSystemPath(path, true) : path
        };
      });
    }
  }
});

// .api/apis/zklighter/node_modules/@readme/json-schema-ref-parser/lib/resolve-external.js
var require_resolve_external = __commonJS({
  ".api/apis/zklighter/node_modules/@readme/json-schema-ref-parser/lib/resolve-external.js"(exports, module2) {
    var parse2 = require_parse();
    var Pointer = require_pointer();
    var $Ref = require_ref();
    var { isHandledError } = require_errors();
    var url = require_url2();
    module2.exports = resolveExternal;
    function resolveExternal(parser, options) {
      if (!options.resolve.external) {
        return Promise.resolve();
      }
      try {
        const promises = crawl(parser.schema, `${parser.$refs._root$Ref.path}#`, parser.$refs, options);
        return Promise.all(promises);
      } catch (e) {
        return Promise.reject(e);
      }
    }
    function crawl(obj, path, $refs, options, seen) {
      seen = seen || /* @__PURE__ */ new Set();
      let promises = [];
      if (obj && typeof obj === "object" && !ArrayBuffer.isView(obj) && !seen.has(obj)) {
        seen.add(obj);
        if ($Ref.isExternal$Ref(obj)) {
          promises.push(resolve$Ref(obj, path, $refs, options));
        } else {
          for (const key of Object.keys(obj)) {
            const keyPath = Pointer.join(path, key);
            const value = obj[key];
            if ($Ref.isExternal$Ref(value)) {
              promises.push(resolve$Ref(value, keyPath, $refs, options));
            } else {
              promises = promises.concat(crawl(value, keyPath, $refs, options, seen));
            }
          }
        }
      }
      return promises;
    }
    async function resolve$Ref($ref, path, $refs, options) {
      const resolvedPath = url.resolve(path, $ref.$ref);
      const withoutHash = url.stripHash(resolvedPath);
      $ref = $refs._$refs[withoutHash];
      if ($ref) {
        return Promise.resolve($ref.value);
      }
      try {
        const result = await parse2(resolvedPath, $refs, options);
        const promises = crawl(result, `${withoutHash}#`, $refs, options);
        return Promise.all(promises);
      } catch (err) {
        if (!options.continueOnError || !isHandledError(err)) {
          throw err;
        }
        if ($refs._$refs[withoutHash]) {
          err.source = url.stripHash(path);
          err.path = url.safePointerToPath(url.getHash(path));
        }
        return [];
      }
    }
  }
});

// .api/apis/zklighter/node_modules/@readme/json-schema-ref-parser/lib/index.js
var require_lib = __commonJS({
  ".api/apis/zklighter/node_modules/@readme/json-schema-ref-parser/lib/index.js"(exports, module2) {
    var { ono: ono2 } = (init_esm(), __toCommonJS(esm_exports));
    var maybe = require_maybe();
    var _bundle = require_bundle();
    var _dereference = require_dereference();
    var normalizeArgs2 = require_normalize_args();
    var _parse = require_parse();
    var $Refs = require_refs();
    var resolveExternal = require_resolve_external();
    var {
      JSONParserError,
      InvalidPointerError,
      MissingPointerError,
      ResolverError,
      ParserError,
      UnmatchedParserError,
      UnmatchedResolverError,
      isHandledError,
      JSONParserErrorGroup
    } = require_errors();
    var url = require_url2();
    module2.exports = $RefParser;
    module2.exports.default = $RefParser;
    module2.exports.JSONParserError = JSONParserError;
    module2.exports.InvalidPointerError = InvalidPointerError;
    module2.exports.MissingPointerError = MissingPointerError;
    module2.exports.ResolverError = ResolverError;
    module2.exports.ParserError = ParserError;
    module2.exports.UnmatchedParserError = UnmatchedParserError;
    module2.exports.UnmatchedResolverError = UnmatchedResolverError;
    function $RefParser() {
      this.schema = null;
      this.$refs = new $Refs();
    }
    $RefParser.parse = function parse2(path, schema, options, callback) {
      const Class = this;
      const instance = new Class();
      return instance.parse.apply(instance, arguments);
    };
    $RefParser.prototype.parse = async function parse2(path, schema, options, callback) {
      const args = normalizeArgs2(arguments);
      let promise;
      if (!args.path && !args.schema) {
        const err = ono2(`Expected a file path, URL, or object. Got ${args.path || args.schema}`);
        return maybe(args.callback, Promise.reject(err));
      }
      this.schema = null;
      this.$refs = new $Refs();
      let pathType = "http";
      if (url.isFileSystemPath(args.path)) {
        args.path = url.fromFileSystemPath(args.path);
        pathType = "file";
      }
      args.path = url.resolve(url.cwd(), args.path);
      if (args.schema && typeof args.schema === "object") {
        const $ref = this.$refs._add(args.path);
        $ref.value = args.schema;
        $ref.pathType = pathType;
        promise = Promise.resolve(args.schema);
      } else {
        promise = _parse(args.path, this.$refs, args.options);
      }
      const me = this;
      try {
        const result = await promise;
        if (result !== null && typeof result === "object" && !Buffer.isBuffer(result)) {
          me.schema = result;
          return maybe(args.callback, Promise.resolve(me.schema));
        } else if (args.options.continueOnError) {
          me.schema = null;
          return maybe(args.callback, Promise.resolve(me.schema));
        }
        throw ono2.syntax(`"${me.$refs._root$Ref.path || result}" is not a valid JSON Schema`);
      } catch (err) {
        if (!args.options.continueOnError || !isHandledError(err)) {
          return maybe(args.callback, Promise.reject(err));
        }
        if (this.$refs._$refs[url.stripHash(args.path)]) {
          this.$refs._$refs[url.stripHash(args.path)].addError(err);
        }
        return maybe(args.callback, Promise.resolve(null));
      }
    };
    $RefParser.resolve = function resolve(path, schema, options, callback) {
      const Class = this;
      const instance = new Class();
      return instance.resolve.apply(instance, arguments);
    };
    $RefParser.prototype.resolve = async function resolve(path, schema, options, callback) {
      const me = this;
      const args = normalizeArgs2(arguments);
      try {
        await this.parse(args.path, args.schema, args.options);
        await resolveExternal(me, args.options);
        finalize(me);
        return maybe(args.callback, Promise.resolve(me.$refs));
      } catch (err) {
        return maybe(args.callback, Promise.reject(err));
      }
    };
    $RefParser.bundle = function bundle(path, schema, options, callback) {
      const Class = this;
      const instance = new Class();
      return instance.bundle.apply(instance, arguments);
    };
    $RefParser.prototype.bundle = async function bundle(path, schema, options, callback) {
      const me = this;
      const args = normalizeArgs2(arguments);
      try {
        await this.resolve(args.path, args.schema, args.options);
        _bundle(me, args.options);
        finalize(me);
        return maybe(args.callback, Promise.resolve(me.schema));
      } catch (err) {
        return maybe(args.callback, Promise.reject(err));
      }
    };
    $RefParser.dereference = function dereference(path, schema, options, callback) {
      const Class = this;
      const instance = new Class();
      return instance.dereference.apply(instance, arguments);
    };
    $RefParser.prototype.dereference = async function dereference(path, schema, options, callback) {
      const me = this;
      const args = normalizeArgs2(arguments);
      try {
        await this.resolve(args.path, args.schema, args.options);
        _dereference(me, args.options);
        finalize(me);
        return maybe(args.callback, Promise.resolve(me.schema));
      } catch (err) {
        return maybe(args.callback, Promise.reject(err));
      }
    };
    function finalize(parser) {
      const errors = JSONParserErrorGroup.getParserErrors(parser);
      if (errors.length > 0) {
        throw new JSONParserErrorGroup(parser);
      }
    }
  }
});

// .api/apis/zklighter/node_modules/path-to-regexp/dist.es2015/index.js
var dist_exports = {};
__export(dist_exports, {
  compile: () => compile,
  match: () => match,
  parse: () => parse,
  pathToRegexp: () => pathToRegexp,
  regexpToFunction: () => regexpToFunction,
  tokensToFunction: () => tokensToFunction,
  tokensToRegexp: () => tokensToRegexp
});
function lexer(str) {
  var tokens = [];
  var i = 0;
  while (i < str.length) {
    var char = str[i];
    if (char === "*" || char === "+" || char === "?") {
      tokens.push({ type: "MODIFIER", index: i, value: str[i++] });
      continue;
    }
    if (char === "\\") {
      tokens.push({ type: "ESCAPED_CHAR", index: i++, value: str[i++] });
      continue;
    }
    if (char === "{") {
      tokens.push({ type: "OPEN", index: i, value: str[i++] });
      continue;
    }
    if (char === "}") {
      tokens.push({ type: "CLOSE", index: i, value: str[i++] });
      continue;
    }
    if (char === ":") {
      var name = "";
      var j = i + 1;
      while (j < str.length) {
        var code = str.charCodeAt(j);
        if (
          // `0-9`
          code >= 48 && code <= 57 || // `A-Z`
          code >= 65 && code <= 90 || // `a-z`
          code >= 97 && code <= 122 || // `_`
          code === 95
        ) {
          name += str[j++];
          continue;
        }
        break;
      }
      if (!name)
        throw new TypeError("Missing parameter name at ".concat(i));
      tokens.push({ type: "NAME", index: i, value: name });
      i = j;
      continue;
    }
    if (char === "(") {
      var count = 1;
      var pattern = "";
      var j = i + 1;
      if (str[j] === "?") {
        throw new TypeError('Pattern cannot start with "?" at '.concat(j));
      }
      while (j < str.length) {
        if (str[j] === "\\") {
          pattern += str[j++] + str[j++];
          continue;
        }
        if (str[j] === ")") {
          count--;
          if (count === 0) {
            j++;
            break;
          }
        } else if (str[j] === "(") {
          count++;
          if (str[j + 1] !== "?") {
            throw new TypeError("Capturing groups are not allowed at ".concat(j));
          }
        }
        pattern += str[j++];
      }
      if (count)
        throw new TypeError("Unbalanced pattern at ".concat(i));
      if (!pattern)
        throw new TypeError("Missing pattern at ".concat(i));
      tokens.push({ type: "PATTERN", index: i, value: pattern });
      i = j;
      continue;
    }
    tokens.push({ type: "CHAR", index: i, value: str[i++] });
  }
  tokens.push({ type: "END", index: i, value: "" });
  return tokens;
}
function parse(str, options) {
  if (options === void 0) {
    options = {};
  }
  var tokens = lexer(str);
  var _a = options.prefixes, prefixes = _a === void 0 ? "./" : _a, _b = options.delimiter, delimiter = _b === void 0 ? "/#?" : _b;
  var result = [];
  var key = 0;
  var i = 0;
  var path = "";
  var tryConsume = function(type) {
    if (i < tokens.length && tokens[i].type === type)
      return tokens[i++].value;
  };
  var mustConsume = function(type) {
    var value2 = tryConsume(type);
    if (value2 !== void 0)
      return value2;
    var _a2 = tokens[i], nextType = _a2.type, index = _a2.index;
    throw new TypeError("Unexpected ".concat(nextType, " at ").concat(index, ", expected ").concat(type));
  };
  var consumeText = function() {
    var result2 = "";
    var value2;
    while (value2 = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR")) {
      result2 += value2;
    }
    return result2;
  };
  var isSafe = function(value2) {
    for (var _i = 0, delimiter_1 = delimiter; _i < delimiter_1.length; _i++) {
      var char2 = delimiter_1[_i];
      if (value2.indexOf(char2) > -1)
        return true;
    }
    return false;
  };
  var safePattern = function(prefix2) {
    var prev = result[result.length - 1];
    var prevText = prefix2 || (prev && typeof prev === "string" ? prev : "");
    if (prev && !prevText) {
      throw new TypeError('Must have text between two parameters, missing text after "'.concat(prev.name, '"'));
    }
    if (!prevText || isSafe(prevText))
      return "[^".concat(escapeString(delimiter), "]+?");
    return "(?:(?!".concat(escapeString(prevText), ")[^").concat(escapeString(delimiter), "])+?");
  };
  while (i < tokens.length) {
    var char = tryConsume("CHAR");
    var name = tryConsume("NAME");
    var pattern = tryConsume("PATTERN");
    if (name || pattern) {
      var prefix = char || "";
      if (prefixes.indexOf(prefix) === -1) {
        path += prefix;
        prefix = "";
      }
      if (path) {
        result.push(path);
        path = "";
      }
      result.push({
        name: name || key++,
        prefix,
        suffix: "",
        pattern: pattern || safePattern(prefix),
        modifier: tryConsume("MODIFIER") || ""
      });
      continue;
    }
    var value = char || tryConsume("ESCAPED_CHAR");
    if (value) {
      path += value;
      continue;
    }
    if (path) {
      result.push(path);
      path = "";
    }
    var open = tryConsume("OPEN");
    if (open) {
      var prefix = consumeText();
      var name_1 = tryConsume("NAME") || "";
      var pattern_1 = tryConsume("PATTERN") || "";
      var suffix = consumeText();
      mustConsume("CLOSE");
      result.push({
        name: name_1 || (pattern_1 ? key++ : ""),
        pattern: name_1 && !pattern_1 ? safePattern(prefix) : pattern_1,
        prefix,
        suffix,
        modifier: tryConsume("MODIFIER") || ""
      });
      continue;
    }
    mustConsume("END");
  }
  return result;
}
function compile(str, options) {
  return tokensToFunction(parse(str, options), options);
}
function tokensToFunction(tokens, options) {
  if (options === void 0) {
    options = {};
  }
  var reFlags = flags(options);
  var _a = options.encode, encode = _a === void 0 ? function(x) {
    return x;
  } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;
  var matches = tokens.map(function(token) {
    if (typeof token === "object") {
      return new RegExp("^(?:".concat(token.pattern, ")$"), reFlags);
    }
  });
  return function(data) {
    var path = "";
    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];
      if (typeof token === "string") {
        path += token;
        continue;
      }
      var value = data ? data[token.name] : void 0;
      var optional = token.modifier === "?" || token.modifier === "*";
      var repeat = token.modifier === "*" || token.modifier === "+";
      if (Array.isArray(value)) {
        if (!repeat) {
          throw new TypeError('Expected "'.concat(token.name, '" to not repeat, but got an array'));
        }
        if (value.length === 0) {
          if (optional)
            continue;
          throw new TypeError('Expected "'.concat(token.name, '" to not be empty'));
        }
        for (var j = 0; j < value.length; j++) {
          var segment = encode(value[j], token);
          if (validate && !matches[i].test(segment)) {
            throw new TypeError('Expected all "'.concat(token.name, '" to match "').concat(token.pattern, '", but got "').concat(segment, '"'));
          }
          path += token.prefix + segment + token.suffix;
        }
        continue;
      }
      if (typeof value === "string" || typeof value === "number") {
        var segment = encode(String(value), token);
        if (validate && !matches[i].test(segment)) {
          throw new TypeError('Expected "'.concat(token.name, '" to match "').concat(token.pattern, '", but got "').concat(segment, '"'));
        }
        path += token.prefix + segment + token.suffix;
        continue;
      }
      if (optional)
        continue;
      var typeOfMessage = repeat ? "an array" : "a string";
      throw new TypeError('Expected "'.concat(token.name, '" to be ').concat(typeOfMessage));
    }
    return path;
  };
}
function match(str, options) {
  var keys = [];
  var re = pathToRegexp(str, keys, options);
  return regexpToFunction(re, keys, options);
}
function regexpToFunction(re, keys, options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.decode, decode = _a === void 0 ? function(x) {
    return x;
  } : _a;
  return function(pathname) {
    var m = re.exec(pathname);
    if (!m)
      return false;
    var path = m[0], index = m.index;
    var params = /* @__PURE__ */ Object.create(null);
    var _loop_1 = function(i2) {
      if (m[i2] === void 0)
        return "continue";
      var key = keys[i2 - 1];
      if (key.modifier === "*" || key.modifier === "+") {
        params[key.name] = m[i2].split(key.prefix + key.suffix).map(function(value) {
          return decode(value, key);
        });
      } else {
        params[key.name] = decode(m[i2], key);
      }
    };
    for (var i = 1; i < m.length; i++) {
      _loop_1(i);
    }
    return { path, index, params };
  };
}
function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
}
function flags(options) {
  return options && options.sensitive ? "" : "i";
}
function regexpToRegexp(path, keys) {
  if (!keys)
    return path;
  var groupsRegex = /\((?:\?<(.*?)>)?(?!\?)/g;
  var index = 0;
  var execResult = groupsRegex.exec(path.source);
  while (execResult) {
    keys.push({
      // Use parenthesized substring match if available, index otherwise
      name: execResult[1] || index++,
      prefix: "",
      suffix: "",
      modifier: "",
      pattern: ""
    });
    execResult = groupsRegex.exec(path.source);
  }
  return path;
}
function arrayToRegexp(paths, keys, options) {
  var parts = paths.map(function(path) {
    return pathToRegexp(path, keys, options).source;
  });
  return new RegExp("(?:".concat(parts.join("|"), ")"), flags(options));
}
function stringToRegexp(path, keys, options) {
  return tokensToRegexp(parse(path, options), keys, options);
}
function tokensToRegexp(tokens, keys, options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function(x) {
    return x;
  } : _d, _e = options.delimiter, delimiter = _e === void 0 ? "/#?" : _e, _f = options.endsWith, endsWith = _f === void 0 ? "" : _f;
  var endsWithRe = "[".concat(escapeString(endsWith), "]|$");
  var delimiterRe = "[".concat(escapeString(delimiter), "]");
  var route = start ? "^" : "";
  for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
    var token = tokens_1[_i];
    if (typeof token === "string") {
      route += escapeString(encode(token));
    } else {
      var prefix = escapeString(encode(token.prefix));
      var suffix = escapeString(encode(token.suffix));
      if (token.pattern) {
        if (keys)
          keys.push(token);
        if (prefix || suffix) {
          if (token.modifier === "+" || token.modifier === "*") {
            var mod = token.modifier === "*" ? "?" : "";
            route += "(?:".concat(prefix, "((?:").concat(token.pattern, ")(?:").concat(suffix).concat(prefix, "(?:").concat(token.pattern, "))*)").concat(suffix, ")").concat(mod);
          } else {
            route += "(?:".concat(prefix, "(").concat(token.pattern, ")").concat(suffix, ")").concat(token.modifier);
          }
        } else {
          if (token.modifier === "+" || token.modifier === "*") {
            throw new TypeError('Can not repeat "'.concat(token.name, '" without a prefix and suffix'));
          }
          route += "(".concat(token.pattern, ")").concat(token.modifier);
        }
      } else {
        route += "(?:".concat(prefix).concat(suffix, ")").concat(token.modifier);
      }
    }
  }
  if (end) {
    if (!strict)
      route += "".concat(delimiterRe, "?");
    route += !options.endsWith ? "$" : "(?=".concat(endsWithRe, ")");
  } else {
    var endToken = tokens[tokens.length - 1];
    var isEndDelimited = typeof endToken === "string" ? delimiterRe.indexOf(endToken[endToken.length - 1]) > -1 : endToken === void 0;
    if (!strict) {
      route += "(?:".concat(delimiterRe, "(?=").concat(endsWithRe, "))?");
    }
    if (!isEndDelimited) {
      route += "(?=".concat(delimiterRe, "|").concat(endsWithRe, ")");
    }
  }
  return new RegExp(route, flags(options));
}
function pathToRegexp(path, keys, options) {
  if (path instanceof RegExp)
    return regexpToRegexp(path, keys);
  if (Array.isArray(path))
    return arrayToRegexp(path, keys, options);
  return stringToRegexp(path, keys, options);
}
var init_dist = __esm({
  ".api/apis/zklighter/node_modules/path-to-regexp/dist.es2015/index.js"() {
  }
});

// .api/apis/zklighter/node_modules/oas/dist/lib/get-auth.js
var require_get_auth = __commonJS({
  ".api/apis/zklighter/node_modules/oas/dist/lib/get-auth.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    exports.__esModule = true;
    exports.getByScheme = void 0;
    function getKey(user, scheme) {
      switch (scheme.type) {
        case "oauth2":
        case "apiKey":
          return user[scheme._key] || user.apiKey || scheme["x-default"] || null;
        case "http":
          if (scheme.scheme === "basic") {
            return user[scheme._key] || { user: user.user || null, pass: user.pass || null };
          }
          if (scheme.scheme === "bearer") {
            return user[scheme._key] || user.apiKey || null;
          }
          return null;
        default:
          return null;
      }
    }
    function getByScheme(user, scheme, selectedApp) {
      if (scheme === void 0) {
        scheme = {};
      }
      if ((user === null || user === void 0 ? void 0 : user.keys) && user.keys.length) {
        if (selectedApp) {
          return getKey(user.keys.find(function(key) {
            return key.name === selectedApp;
          }), scheme);
        }
        return getKey(user.keys[0], scheme);
      }
      return getKey(user, scheme);
    }
    exports.getByScheme = getByScheme;
    function getAuth(api, user, selectedApp) {
      var _a;
      return Object.keys(((_a = api === null || api === void 0 ? void 0 : api.components) === null || _a === void 0 ? void 0 : _a.securitySchemes) || {}).map(function(scheme) {
        var _a2;
        return _a2 = {}, _a2[scheme] = getByScheme(user, __assign(__assign({}, api.components.securitySchemes[scheme]), { _key: scheme }), selectedApp), _a2;
      }).reduce(function(prev, next) {
        return Object.assign(prev, next);
      }, {});
    }
    exports["default"] = getAuth;
  }
});

// .api/apis/zklighter/node_modules/oas/dist/lib/get-user-variable.js
var require_get_user_variable = __commonJS({
  ".api/apis/zklighter/node_modules/oas/dist/lib/get-user-variable.js"(exports) {
    "use strict";
    exports.__esModule = true;
    function getUserVariable(user, property, selectedApp) {
      var key = user;
      if ("keys" in user && Array.isArray(user.keys) && user.keys.length) {
        if (selectedApp) {
          key = user.keys.find(function(k) {
            return k.name === selectedApp;
          });
        } else {
          key = user.keys[0];
        }
      }
      return key[property] || null;
    }
    exports["default"] = getUserVariable;
  }
});

// .api/apis/zklighter/node_modules/oas/dist/rmoas.types.js
var require_rmoas_types = __commonJS({
  ".api/apis/zklighter/node_modules/oas/dist/rmoas.types.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.isSchema = exports.isOAS31 = exports.isRef = void 0;
    function isRef(check) {
      return check.$ref !== void 0;
    }
    exports.isRef = isRef;
    function isOAS31(check) {
      return check.openapi === "3.1.0";
    }
    exports.isOAS31 = isOAS31;
    function isSchema(check, isPolymorphicAllOfChild) {
      if (isPolymorphicAllOfChild === void 0) {
        isPolymorphicAllOfChild = false;
      }
      return check.type !== void 0 || check.allOf !== void 0 || check.anyOf !== void 0 || check.oneOf !== void 0 || isPolymorphicAllOfChild;
    }
    exports.isSchema = isSchema;
  }
});

// .api/apis/zklighter/node_modules/oas/dist/lib/dedupe-common-parameters.js
var require_dedupe_common_parameters = __commonJS({
  ".api/apis/zklighter/node_modules/oas/dist/lib/dedupe-common-parameters.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    exports.__esModule = true;
    var RMOAS = __importStar(require_rmoas_types());
    function dedupeCommonParameters(parameters, commonParameters) {
      return commonParameters.filter(function(param) {
        return !parameters.find(function(param2) {
          if (param.name && param2.name) {
            return param.name === param2.name && param["in"] === param2["in"];
          } else if (RMOAS.isRef(param) && RMOAS.isRef(param2)) {
            return param.$ref === param2.$ref;
          }
          return false;
        });
      });
    }
    exports["default"] = dedupeCommonParameters;
  }
});

// .api/apis/zklighter/node_modules/jsonpointer/jsonpointer.js
var require_jsonpointer = __commonJS({
  ".api/apis/zklighter/node_modules/jsonpointer/jsonpointer.js"(exports) {
    var hasExcape = /~/;
    var escapeMatcher = /~[01]/g;
    function escapeReplacer(m) {
      switch (m) {
        case "~1":
          return "/";
        case "~0":
          return "~";
      }
      throw new Error("Invalid tilde escape: " + m);
    }
    function untilde(str) {
      if (!hasExcape.test(str)) return str;
      return str.replace(escapeMatcher, escapeReplacer);
    }
    function setter(obj, pointer, value) {
      var part;
      var hasNextPart;
      for (var p = 1, len = pointer.length; p < len; ) {
        if (pointer[p] === "constructor" || pointer[p] === "prototype" || pointer[p] === "__proto__") return obj;
        part = untilde(pointer[p++]);
        hasNextPart = len > p;
        if (typeof obj[part] === "undefined") {
          if (Array.isArray(obj) && part === "-") {
            part = obj.length;
          }
          if (hasNextPart) {
            if (pointer[p] !== "" && pointer[p] < Infinity || pointer[p] === "-") obj[part] = [];
            else obj[part] = {};
          }
        }
        if (!hasNextPart) break;
        obj = obj[part];
      }
      var oldValue = obj[part];
      if (value === void 0) delete obj[part];
      else obj[part] = value;
      return oldValue;
    }
    function compilePointer(pointer) {
      if (typeof pointer === "string") {
        pointer = pointer.split("/");
        if (pointer[0] === "") return pointer;
        throw new Error("Invalid JSON pointer.");
      } else if (Array.isArray(pointer)) {
        for (const part of pointer) {
          if (typeof part !== "string" && typeof part !== "number") {
            throw new Error("Invalid JSON pointer. Must be of type string or number.");
          }
        }
        return pointer;
      }
      throw new Error("Invalid JSON pointer.");
    }
    function get(obj, pointer) {
      if (typeof obj !== "object") throw new Error("Invalid input object.");
      pointer = compilePointer(pointer);
      var len = pointer.length;
      if (len === 1) return obj;
      for (var p = 1; p < len; ) {
        obj = obj[untilde(pointer[p++])];
        if (len === p) return obj;
        if (typeof obj !== "object" || obj === null) return void 0;
      }
    }
    function set(obj, pointer, value) {
      if (typeof obj !== "object") throw new Error("Invalid input object.");
      pointer = compilePointer(pointer);
      if (pointer.length === 0) throw new Error("Invalid JSON pointer for set.");
      return setter(obj, pointer, value);
    }
    function compile2(pointer) {
      var compiled = compilePointer(pointer);
      return {
        get: function(object) {
          return get(object, compiled);
        },
        set: function(object, value) {
          return set(object, compiled, value);
        }
      };
    }
    exports.get = get;
    exports.set = set;
    exports.compile = compile2;
  }
});

// .api/apis/zklighter/node_modules/oas/dist/lib/find-schema-definition.js
var require_find_schema_definition = __commonJS({
  ".api/apis/zklighter/node_modules/oas/dist/lib/find-schema-definition.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    exports.__esModule = true;
    var jsonpointer_1 = __importDefault(require_jsonpointer());
    function findSchemaDefinition($ref, definition) {
      if (definition === void 0) {
        definition = {};
      }
      var origRef = $ref;
      $ref = $ref.trim();
      if ($ref === "") {
        return false;
      }
      if ($ref.startsWith("#")) {
        $ref = decodeURIComponent($ref.substring(1));
      } else {
        throw new Error("Could not find a definition for ".concat(origRef, "."));
      }
      var current = jsonpointer_1["default"].get(definition, $ref);
      if (current === void 0) {
        throw new Error("Could not find a definition for ".concat(origRef, "."));
      }
      return current;
    }
    exports["default"] = findSchemaDefinition;
  }
});

// .api/apis/zklighter/node_modules/oas/dist/lib/matches-mimetype.js
var require_matches_mimetype = __commonJS({
  ".api/apis/zklighter/node_modules/oas/dist/lib/matches-mimetype.js"(exports) {
    "use strict";
    exports.__esModule = true;
    function matchesMediaType(types, mediaType) {
      return types.some(function(type) {
        return mediaType.indexOf(type) > -1;
      });
    }
    exports["default"] = {
      formUrlEncoded: function(mimeType) {
        return matchesMediaType(["application/x-www-form-urlencoded"], mimeType);
      },
      json: function(contentType) {
        return matchesMediaType(["application/json", "application/x-json", "text/json", "text/x-json", "+json"], contentType);
      },
      multipart: function(contentType) {
        return matchesMediaType(["multipart/mixed", "multipart/related", "multipart/form-data", "multipart/alternative"], contentType);
      },
      wildcard: function(contentType) {
        return contentType === "*/*";
      },
      xml: function(contentType) {
        return matchesMediaType([
          "application/xml",
          "application/xml-external-parsed-entity",
          "application/xml-dtd",
          "text/xml",
          "text/xml-external-parsed-entity",
          "+xml"
        ], contentType);
      }
    };
  }
});

// .api/apis/zklighter/node_modules/lodash/_listCacheClear.js
var require_listCacheClear = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_listCacheClear.js"(exports, module2) {
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    module2.exports = listCacheClear;
  }
});

// .api/apis/zklighter/node_modules/lodash/eq.js
var require_eq = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/eq.js"(exports, module2) {
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    module2.exports = eq;
  }
});

// .api/apis/zklighter/node_modules/lodash/_assocIndexOf.js
var require_assocIndexOf = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_assocIndexOf.js"(exports, module2) {
    var eq = require_eq();
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    module2.exports = assocIndexOf;
  }
});

// .api/apis/zklighter/node_modules/lodash/_listCacheDelete.js
var require_listCacheDelete = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_listCacheDelete.js"(exports, module2) {
    var assocIndexOf = require_assocIndexOf();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    module2.exports = listCacheDelete;
  }
});

// .api/apis/zklighter/node_modules/lodash/_listCacheGet.js
var require_listCacheGet = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_listCacheGet.js"(exports, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    module2.exports = listCacheGet;
  }
});

// .api/apis/zklighter/node_modules/lodash/_listCacheHas.js
var require_listCacheHas = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_listCacheHas.js"(exports, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    module2.exports = listCacheHas;
  }
});

// .api/apis/zklighter/node_modules/lodash/_listCacheSet.js
var require_listCacheSet = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_listCacheSet.js"(exports, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    module2.exports = listCacheSet;
  }
});

// .api/apis/zklighter/node_modules/lodash/_ListCache.js
var require_ListCache = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_ListCache.js"(exports, module2) {
    var listCacheClear = require_listCacheClear();
    var listCacheDelete = require_listCacheDelete();
    var listCacheGet = require_listCacheGet();
    var listCacheHas = require_listCacheHas();
    var listCacheSet = require_listCacheSet();
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    module2.exports = ListCache;
  }
});

// .api/apis/zklighter/node_modules/lodash/_stackClear.js
var require_stackClear = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_stackClear.js"(exports, module2) {
    var ListCache = require_ListCache();
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    module2.exports = stackClear;
  }
});

// .api/apis/zklighter/node_modules/lodash/_stackDelete.js
var require_stackDelete = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_stackDelete.js"(exports, module2) {
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    module2.exports = stackDelete;
  }
});

// .api/apis/zklighter/node_modules/lodash/_stackGet.js
var require_stackGet = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_stackGet.js"(exports, module2) {
    function stackGet(key) {
      return this.__data__.get(key);
    }
    module2.exports = stackGet;
  }
});

// .api/apis/zklighter/node_modules/lodash/_stackHas.js
var require_stackHas = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_stackHas.js"(exports, module2) {
    function stackHas(key) {
      return this.__data__.has(key);
    }
    module2.exports = stackHas;
  }
});

// .api/apis/zklighter/node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_freeGlobal.js"(exports, module2) {
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module2.exports = freeGlobal;
  }
});

// .api/apis/zklighter/node_modules/lodash/_root.js
var require_root = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_root.js"(exports, module2) {
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module2.exports = root;
  }
});

// .api/apis/zklighter/node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_Symbol.js"(exports, module2) {
    var root = require_root();
    var Symbol2 = root.Symbol;
    module2.exports = Symbol2;
  }
});

// .api/apis/zklighter/node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_getRawTag.js"(exports, module2) {
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module2.exports = getRawTag;
  }
});

// .api/apis/zklighter/node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_objectToString.js"(exports, module2) {
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module2.exports = objectToString;
  }
});

// .api/apis/zklighter/node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_baseGetTag.js"(exports, module2) {
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module2.exports = baseGetTag;
  }
});

// .api/apis/zklighter/node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/isObject.js"(exports, module2) {
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    module2.exports = isObject;
  }
});

// .api/apis/zklighter/node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/isFunction.js"(exports, module2) {
    var baseGetTag = require_baseGetTag();
    var isObject = require_isObject();
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    module2.exports = isFunction;
  }
});

// .api/apis/zklighter/node_modules/lodash/_coreJsData.js
var require_coreJsData = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_coreJsData.js"(exports, module2) {
    var root = require_root();
    var coreJsData = root["__core-js_shared__"];
    module2.exports = coreJsData;
  }
});

// .api/apis/zklighter/node_modules/lodash/_isMasked.js
var require_isMasked = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_isMasked.js"(exports, module2) {
    var coreJsData = require_coreJsData();
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    module2.exports = isMasked;
  }
});

// .api/apis/zklighter/node_modules/lodash/_toSource.js
var require_toSource = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_toSource.js"(exports, module2) {
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    module2.exports = toSource;
  }
});

// .api/apis/zklighter/node_modules/lodash/_baseIsNative.js
var require_baseIsNative = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_baseIsNative.js"(exports, module2) {
    var isFunction = require_isFunction();
    var isMasked = require_isMasked();
    var isObject = require_isObject();
    var toSource = require_toSource();
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    module2.exports = baseIsNative;
  }
});

// .api/apis/zklighter/node_modules/lodash/_getValue.js
var require_getValue = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_getValue.js"(exports, module2) {
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    module2.exports = getValue;
  }
});

// .api/apis/zklighter/node_modules/lodash/_getNative.js
var require_getNative = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_getNative.js"(exports, module2) {
    var baseIsNative = require_baseIsNative();
    var getValue = require_getValue();
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    module2.exports = getNative;
  }
});

// .api/apis/zklighter/node_modules/lodash/_Map.js
var require_Map = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_Map.js"(exports, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Map2 = getNative(root, "Map");
    module2.exports = Map2;
  }
});

// .api/apis/zklighter/node_modules/lodash/_nativeCreate.js
var require_nativeCreate = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_nativeCreate.js"(exports, module2) {
    var getNative = require_getNative();
    var nativeCreate = getNative(Object, "create");
    module2.exports = nativeCreate;
  }
});

// .api/apis/zklighter/node_modules/lodash/_hashClear.js
var require_hashClear = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_hashClear.js"(exports, module2) {
    var nativeCreate = require_nativeCreate();
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    module2.exports = hashClear;
  }
});

// .api/apis/zklighter/node_modules/lodash/_hashDelete.js
var require_hashDelete = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_hashDelete.js"(exports, module2) {
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    module2.exports = hashDelete;
  }
});

// .api/apis/zklighter/node_modules/lodash/_hashGet.js
var require_hashGet = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_hashGet.js"(exports, module2) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty2.call(data, key) ? data[key] : void 0;
    }
    module2.exports = hashGet;
  }
});

// .api/apis/zklighter/node_modules/lodash/_hashHas.js
var require_hashHas = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_hashHas.js"(exports, module2) {
    var nativeCreate = require_nativeCreate();
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
    }
    module2.exports = hashHas;
  }
});

// .api/apis/zklighter/node_modules/lodash/_hashSet.js
var require_hashSet = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_hashSet.js"(exports, module2) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    module2.exports = hashSet;
  }
});

// .api/apis/zklighter/node_modules/lodash/_Hash.js
var require_Hash = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_Hash.js"(exports, module2) {
    var hashClear = require_hashClear();
    var hashDelete = require_hashDelete();
    var hashGet = require_hashGet();
    var hashHas = require_hashHas();
    var hashSet = require_hashSet();
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    module2.exports = Hash;
  }
});

// .api/apis/zklighter/node_modules/lodash/_mapCacheClear.js
var require_mapCacheClear = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_mapCacheClear.js"(exports, module2) {
    var Hash = require_Hash();
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    module2.exports = mapCacheClear;
  }
});

// .api/apis/zklighter/node_modules/lodash/_isKeyable.js
var require_isKeyable = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_isKeyable.js"(exports, module2) {
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    module2.exports = isKeyable;
  }
});

// .api/apis/zklighter/node_modules/lodash/_getMapData.js
var require_getMapData = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_getMapData.js"(exports, module2) {
    var isKeyable = require_isKeyable();
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    module2.exports = getMapData;
  }
});

// .api/apis/zklighter/node_modules/lodash/_mapCacheDelete.js
var require_mapCacheDelete = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_mapCacheDelete.js"(exports, module2) {
    var getMapData = require_getMapData();
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    module2.exports = mapCacheDelete;
  }
});

// .api/apis/zklighter/node_modules/lodash/_mapCacheGet.js
var require_mapCacheGet = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_mapCacheGet.js"(exports, module2) {
    var getMapData = require_getMapData();
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    module2.exports = mapCacheGet;
  }
});

// .api/apis/zklighter/node_modules/lodash/_mapCacheHas.js
var require_mapCacheHas = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_mapCacheHas.js"(exports, module2) {
    var getMapData = require_getMapData();
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    module2.exports = mapCacheHas;
  }
});

// .api/apis/zklighter/node_modules/lodash/_mapCacheSet.js
var require_mapCacheSet = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_mapCacheSet.js"(exports, module2) {
    var getMapData = require_getMapData();
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    module2.exports = mapCacheSet;
  }
});

// .api/apis/zklighter/node_modules/lodash/_MapCache.js
var require_MapCache = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_MapCache.js"(exports, module2) {
    var mapCacheClear = require_mapCacheClear();
    var mapCacheDelete = require_mapCacheDelete();
    var mapCacheGet = require_mapCacheGet();
    var mapCacheHas = require_mapCacheHas();
    var mapCacheSet = require_mapCacheSet();
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    module2.exports = MapCache;
  }
});

// .api/apis/zklighter/node_modules/lodash/_stackSet.js
var require_stackSet = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_stackSet.js"(exports, module2) {
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    var MapCache = require_MapCache();
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    module2.exports = stackSet;
  }
});

// .api/apis/zklighter/node_modules/lodash/_Stack.js
var require_Stack = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_Stack.js"(exports, module2) {
    var ListCache = require_ListCache();
    var stackClear = require_stackClear();
    var stackDelete = require_stackDelete();
    var stackGet = require_stackGet();
    var stackHas = require_stackHas();
    var stackSet = require_stackSet();
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    module2.exports = Stack;
  }
});

// .api/apis/zklighter/node_modules/lodash/_arrayEach.js
var require_arrayEach = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_arrayEach.js"(exports, module2) {
    function arrayEach(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    module2.exports = arrayEach;
  }
});

// .api/apis/zklighter/node_modules/lodash/_defineProperty.js
var require_defineProperty = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_defineProperty.js"(exports, module2) {
    var getNative = require_getNative();
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    module2.exports = defineProperty;
  }
});

// .api/apis/zklighter/node_modules/lodash/_baseAssignValue.js
var require_baseAssignValue = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_baseAssignValue.js"(exports, module2) {
    var defineProperty = require_defineProperty();
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key] = value;
      }
    }
    module2.exports = baseAssignValue;
  }
});

// .api/apis/zklighter/node_modules/lodash/_assignValue.js
var require_assignValue = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_assignValue.js"(exports, module2) {
    var baseAssignValue = require_baseAssignValue();
    var eq = require_eq();
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty2.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    module2.exports = assignValue;
  }
});

// .api/apis/zklighter/node_modules/lodash/_copyObject.js
var require_copyObject = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_copyObject.js"(exports, module2) {
    var assignValue = require_assignValue();
    var baseAssignValue = require_baseAssignValue();
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    module2.exports = copyObject;
  }
});

// .api/apis/zklighter/node_modules/lodash/_baseTimes.js
var require_baseTimes = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_baseTimes.js"(exports, module2) {
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    module2.exports = baseTimes;
  }
});

// .api/apis/zklighter/node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/isObjectLike.js"(exports, module2) {
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    module2.exports = isObjectLike;
  }
});

// .api/apis/zklighter/node_modules/lodash/_baseIsArguments.js
var require_baseIsArguments = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_baseIsArguments.js"(exports, module2) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    module2.exports = baseIsArguments;
  }
});

// .api/apis/zklighter/node_modules/lodash/isArguments.js
var require_isArguments = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/isArguments.js"(exports, module2) {
    var baseIsArguments = require_baseIsArguments();
    var isObjectLike = require_isObjectLike();
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    module2.exports = isArguments;
  }
});

// .api/apis/zklighter/node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/isArray.js"(exports, module2) {
    var isArray = Array.isArray;
    module2.exports = isArray;
  }
});

// .api/apis/zklighter/node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/stubFalse.js"(exports, module2) {
    function stubFalse() {
      return false;
    }
    module2.exports = stubFalse;
  }
});

// .api/apis/zklighter/node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/isBuffer.js"(exports, module2) {
    var root = require_root();
    var stubFalse = require_stubFalse();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    module2.exports = isBuffer;
  }
});

// .api/apis/zklighter/node_modules/lodash/_isIndex.js
var require_isIndex = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_isIndex.js"(exports, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    module2.exports = isIndex;
  }
});

// .api/apis/zklighter/node_modules/lodash/isLength.js
var require_isLength = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/isLength.js"(exports, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    module2.exports = isLength;
  }
});

// .api/apis/zklighter/node_modules/lodash/_baseIsTypedArray.js
var require_baseIsTypedArray = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_baseIsTypedArray.js"(exports, module2) {
    var baseGetTag = require_baseGetTag();
    var isLength = require_isLength();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    module2.exports = baseIsTypedArray;
  }
});

// .api/apis/zklighter/node_modules/lodash/_baseUnary.js
var require_baseUnary = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_baseUnary.js"(exports, module2) {
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    module2.exports = baseUnary;
  }
});

// .api/apis/zklighter/node_modules/lodash/_nodeUtil.js
var require_nodeUtil = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_nodeUtil.js"(exports, module2) {
    var freeGlobal = require_freeGlobal();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    module2.exports = nodeUtil;
  }
});

// .api/apis/zklighter/node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/isTypedArray.js"(exports, module2) {
    var baseIsTypedArray = require_baseIsTypedArray();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    module2.exports = isTypedArray;
  }
});

// .api/apis/zklighter/node_modules/lodash/_arrayLikeKeys.js
var require_arrayLikeKeys = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_arrayLikeKeys.js"(exports, module2) {
    var baseTimes = require_baseTimes();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isIndex = require_isIndex();
    var isTypedArray = require_isTypedArray();
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = arrayLikeKeys;
  }
});

// .api/apis/zklighter/node_modules/lodash/_isPrototype.js
var require_isPrototype = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_isPrototype.js"(exports, module2) {
    var objectProto = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    module2.exports = isPrototype;
  }
});

// .api/apis/zklighter/node_modules/lodash/_overArg.js
var require_overArg = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_overArg.js"(exports, module2) {
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    module2.exports = overArg;
  }
});

// .api/apis/zklighter/node_modules/lodash/_nativeKeys.js
var require_nativeKeys = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_nativeKeys.js"(exports, module2) {
    var overArg = require_overArg();
    var nativeKeys = overArg(Object.keys, Object);
    module2.exports = nativeKeys;
  }
});

// .api/apis/zklighter/node_modules/lodash/_baseKeys.js
var require_baseKeys = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_baseKeys.js"(exports, module2) {
    var isPrototype = require_isPrototype();
    var nativeKeys = require_nativeKeys();
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty2.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = baseKeys;
  }
});

// .api/apis/zklighter/node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/isArrayLike.js"(exports, module2) {
    var isFunction = require_isFunction();
    var isLength = require_isLength();
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    module2.exports = isArrayLike;
  }
});

// .api/apis/zklighter/node_modules/lodash/keys.js
var require_keys = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/keys.js"(exports, module2) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeys = require_baseKeys();
    var isArrayLike = require_isArrayLike();
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    module2.exports = keys;
  }
});

// .api/apis/zklighter/node_modules/lodash/_baseAssign.js
var require_baseAssign = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_baseAssign.js"(exports, module2) {
    var copyObject = require_copyObject();
    var keys = require_keys();
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    module2.exports = baseAssign;
  }
});

// .api/apis/zklighter/node_modules/lodash/_nativeKeysIn.js
var require_nativeKeysIn = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_nativeKeysIn.js"(exports, module2) {
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = nativeKeysIn;
  }
});

// .api/apis/zklighter/node_modules/lodash/_baseKeysIn.js
var require_baseKeysIn = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_baseKeysIn.js"(exports, module2) {
    var isObject = require_isObject();
    var isPrototype = require_isPrototype();
    var nativeKeysIn = require_nativeKeysIn();
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = baseKeysIn;
  }
});

// .api/apis/zklighter/node_modules/lodash/keysIn.js
var require_keysIn = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/keysIn.js"(exports, module2) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeysIn = require_baseKeysIn();
    var isArrayLike = require_isArrayLike();
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    module2.exports = keysIn;
  }
});

// .api/apis/zklighter/node_modules/lodash/_baseAssignIn.js
var require_baseAssignIn = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_baseAssignIn.js"(exports, module2) {
    var copyObject = require_copyObject();
    var keysIn = require_keysIn();
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }
    module2.exports = baseAssignIn;
  }
});

// .api/apis/zklighter/node_modules/lodash/_cloneBuffer.js
var require_cloneBuffer = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_cloneBuffer.js"(exports, module2) {
    var root = require_root();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      buffer.copy(result);
      return result;
    }
    module2.exports = cloneBuffer;
  }
});

// .api/apis/zklighter/node_modules/lodash/_copyArray.js
var require_copyArray = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_copyArray.js"(exports, module2) {
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    module2.exports = copyArray;
  }
});

// .api/apis/zklighter/node_modules/lodash/_arrayFilter.js
var require_arrayFilter = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_arrayFilter.js"(exports, module2) {
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    module2.exports = arrayFilter;
  }
});

// .api/apis/zklighter/node_modules/lodash/stubArray.js
var require_stubArray = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/stubArray.js"(exports, module2) {
    function stubArray() {
      return [];
    }
    module2.exports = stubArray;
  }
});

// .api/apis/zklighter/node_modules/lodash/_getSymbols.js
var require_getSymbols = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_getSymbols.js"(exports, module2) {
    var arrayFilter = require_arrayFilter();
    var stubArray = require_stubArray();
    var objectProto = Object.prototype;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    module2.exports = getSymbols;
  }
});

// .api/apis/zklighter/node_modules/lodash/_copySymbols.js
var require_copySymbols = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_copySymbols.js"(exports, module2) {
    var copyObject = require_copyObject();
    var getSymbols = require_getSymbols();
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    module2.exports = copySymbols;
  }
});

// .api/apis/zklighter/node_modules/lodash/_arrayPush.js
var require_arrayPush = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_arrayPush.js"(exports, module2) {
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    module2.exports = arrayPush;
  }
});

// .api/apis/zklighter/node_modules/lodash/_getPrototype.js
var require_getPrototype = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_getPrototype.js"(exports, module2) {
    var overArg = require_overArg();
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    module2.exports = getPrototype;
  }
});

// .api/apis/zklighter/node_modules/lodash/_getSymbolsIn.js
var require_getSymbolsIn = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_getSymbolsIn.js"(exports, module2) {
    var arrayPush = require_arrayPush();
    var getPrototype = require_getPrototype();
    var getSymbols = require_getSymbols();
    var stubArray = require_stubArray();
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };
    module2.exports = getSymbolsIn;
  }
});

// .api/apis/zklighter/node_modules/lodash/_copySymbolsIn.js
var require_copySymbolsIn = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_copySymbolsIn.js"(exports, module2) {
    var copyObject = require_copyObject();
    var getSymbolsIn = require_getSymbolsIn();
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }
    module2.exports = copySymbolsIn;
  }
});

// .api/apis/zklighter/node_modules/lodash/_baseGetAllKeys.js
var require_baseGetAllKeys = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_baseGetAllKeys.js"(exports, module2) {
    var arrayPush = require_arrayPush();
    var isArray = require_isArray();
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    module2.exports = baseGetAllKeys;
  }
});

// .api/apis/zklighter/node_modules/lodash/_getAllKeys.js
var require_getAllKeys = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_getAllKeys.js"(exports, module2) {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbols = require_getSymbols();
    var keys = require_keys();
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    module2.exports = getAllKeys;
  }
});

// .api/apis/zklighter/node_modules/lodash/_getAllKeysIn.js
var require_getAllKeysIn = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_getAllKeysIn.js"(exports, module2) {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbolsIn = require_getSymbolsIn();
    var keysIn = require_keysIn();
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }
    module2.exports = getAllKeysIn;
  }
});

// .api/apis/zklighter/node_modules/lodash/_DataView.js
var require_DataView = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_DataView.js"(exports, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var DataView = getNative(root, "DataView");
    module2.exports = DataView;
  }
});

// .api/apis/zklighter/node_modules/lodash/_Promise.js
var require_Promise = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_Promise.js"(exports, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Promise2 = getNative(root, "Promise");
    module2.exports = Promise2;
  }
});

// .api/apis/zklighter/node_modules/lodash/_Set.js
var require_Set = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_Set.js"(exports, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Set2 = getNative(root, "Set");
    module2.exports = Set2;
  }
});

// .api/apis/zklighter/node_modules/lodash/_WeakMap.js
var require_WeakMap = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_WeakMap.js"(exports, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var WeakMap = getNative(root, "WeakMap");
    module2.exports = WeakMap;
  }
});

// .api/apis/zklighter/node_modules/lodash/_getTag.js
var require_getTag = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_getTag.js"(exports, module2) {
    var DataView = require_DataView();
    var Map2 = require_Map();
    var Promise2 = require_Promise();
    var Set2 = require_Set();
    var WeakMap = require_WeakMap();
    var baseGetTag = require_baseGetTag();
    var toSource = require_toSource();
    var mapTag = "[object Map]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var setTag = "[object Set]";
    var weakMapTag = "[object WeakMap]";
    var dataViewTag = "[object DataView]";
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap);
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    module2.exports = getTag;
  }
});

// .api/apis/zklighter/node_modules/lodash/_initCloneArray.js
var require_initCloneArray = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_initCloneArray.js"(exports, module2) {
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    function initCloneArray(array) {
      var length = array.length, result = new array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    module2.exports = initCloneArray;
  }
});

// .api/apis/zklighter/node_modules/lodash/_Uint8Array.js
var require_Uint8Array = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_Uint8Array.js"(exports, module2) {
    var root = require_root();
    var Uint8Array2 = root.Uint8Array;
    module2.exports = Uint8Array2;
  }
});

// .api/apis/zklighter/node_modules/lodash/_cloneArrayBuffer.js
var require_cloneArrayBuffer = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_cloneArrayBuffer.js"(exports, module2) {
    var Uint8Array2 = require_Uint8Array();
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    module2.exports = cloneArrayBuffer;
  }
});

// .api/apis/zklighter/node_modules/lodash/_cloneDataView.js
var require_cloneDataView = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_cloneDataView.js"(exports, module2) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    module2.exports = cloneDataView;
  }
});

// .api/apis/zklighter/node_modules/lodash/_cloneRegExp.js
var require_cloneRegExp = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_cloneRegExp.js"(exports, module2) {
    var reFlags = /\w*$/;
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    module2.exports = cloneRegExp;
  }
});

// .api/apis/zklighter/node_modules/lodash/_cloneSymbol.js
var require_cloneSymbol = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_cloneSymbol.js"(exports, module2) {
    var Symbol2 = require_Symbol();
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    module2.exports = cloneSymbol;
  }
});

// .api/apis/zklighter/node_modules/lodash/_cloneTypedArray.js
var require_cloneTypedArray = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_cloneTypedArray.js"(exports, module2) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    module2.exports = cloneTypedArray;
  }
});

// .api/apis/zklighter/node_modules/lodash/_initCloneByTag.js
var require_initCloneByTag = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_initCloneByTag.js"(exports, module2) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    var cloneDataView = require_cloneDataView();
    var cloneRegExp = require_cloneRegExp();
    var cloneSymbol = require_cloneSymbol();
    var cloneTypedArray = require_cloneTypedArray();
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return new Ctor();
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return new Ctor();
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    module2.exports = initCloneByTag;
  }
});

// .api/apis/zklighter/node_modules/lodash/_baseCreate.js
var require_baseCreate = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_baseCreate.js"(exports, module2) {
    var isObject = require_isObject();
    var objectCreate = Object.create;
    var baseCreate = /* @__PURE__ */ function() {
      function object() {
      }
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    module2.exports = baseCreate;
  }
});

// .api/apis/zklighter/node_modules/lodash/_initCloneObject.js
var require_initCloneObject = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_initCloneObject.js"(exports, module2) {
    var baseCreate = require_baseCreate();
    var getPrototype = require_getPrototype();
    var isPrototype = require_isPrototype();
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    module2.exports = initCloneObject;
  }
});

// .api/apis/zklighter/node_modules/lodash/_baseIsMap.js
var require_baseIsMap = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_baseIsMap.js"(exports, module2) {
    var getTag = require_getTag();
    var isObjectLike = require_isObjectLike();
    var mapTag = "[object Map]";
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }
    module2.exports = baseIsMap;
  }
});

// .api/apis/zklighter/node_modules/lodash/isMap.js
var require_isMap = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/isMap.js"(exports, module2) {
    var baseIsMap = require_baseIsMap();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsMap = nodeUtil && nodeUtil.isMap;
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
    module2.exports = isMap;
  }
});

// .api/apis/zklighter/node_modules/lodash/_baseIsSet.js
var require_baseIsSet = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_baseIsSet.js"(exports, module2) {
    var getTag = require_getTag();
    var isObjectLike = require_isObjectLike();
    var setTag = "[object Set]";
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }
    module2.exports = baseIsSet;
  }
});

// .api/apis/zklighter/node_modules/lodash/isSet.js
var require_isSet = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/isSet.js"(exports, module2) {
    var baseIsSet = require_baseIsSet();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsSet = nodeUtil && nodeUtil.isSet;
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
    module2.exports = isSet;
  }
});

// .api/apis/zklighter/node_modules/lodash/_baseClone.js
var require_baseClone = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_baseClone.js"(exports, module2) {
    var Stack = require_Stack();
    var arrayEach = require_arrayEach();
    var assignValue = require_assignValue();
    var baseAssign = require_baseAssign();
    var baseAssignIn = require_baseAssignIn();
    var cloneBuffer = require_cloneBuffer();
    var copyArray = require_copyArray();
    var copySymbols = require_copySymbols();
    var copySymbolsIn = require_copySymbolsIn();
    var getAllKeys = require_getAllKeys();
    var getAllKeysIn = require_getAllKeysIn();
    var getTag = require_getTag();
    var initCloneArray = require_initCloneArray();
    var initCloneByTag = require_initCloneByTag();
    var initCloneObject = require_initCloneObject();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isMap = require_isMap();
    var isObject = require_isObject();
    var isSet = require_isSet();
    var keys = require_keys();
    var keysIn = require_keysIn();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_FLAT_FLAG = 2;
    var CLONE_SYMBOLS_FLAG = 4;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          result = isFlat || isFunc ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key2) {
          result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
      }
      var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
      var props = isArr ? void 0 : keysFunc(value);
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
      });
      return result;
    }
    module2.exports = baseClone;
  }
});

// .api/apis/zklighter/node_modules/lodash/cloneDeep.js
var require_cloneDeep = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/cloneDeep.js"(exports, module2) {
    var baseClone = require_baseClone();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_SYMBOLS_FLAG = 4;
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }
    module2.exports = cloneDeep;
  }
});

// .api/apis/zklighter/node_modules/lodash/_setCacheAdd.js
var require_setCacheAdd = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_setCacheAdd.js"(exports, module2) {
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    module2.exports = setCacheAdd;
  }
});

// .api/apis/zklighter/node_modules/lodash/_setCacheHas.js
var require_setCacheHas = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_setCacheHas.js"(exports, module2) {
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    module2.exports = setCacheHas;
  }
});

// .api/apis/zklighter/node_modules/lodash/_SetCache.js
var require_SetCache = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_SetCache.js"(exports, module2) {
    var MapCache = require_MapCache();
    var setCacheAdd = require_setCacheAdd();
    var setCacheHas = require_setCacheHas();
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    module2.exports = SetCache;
  }
});

// .api/apis/zklighter/node_modules/lodash/_arraySome.js
var require_arraySome = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_arraySome.js"(exports, module2) {
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    module2.exports = arraySome;
  }
});

// .api/apis/zklighter/node_modules/lodash/_cacheHas.js
var require_cacheHas = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_cacheHas.js"(exports, module2) {
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    module2.exports = cacheHas;
  }
});

// .api/apis/zklighter/node_modules/lodash/_equalArrays.js
var require_equalArrays = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_equalArrays.js"(exports, module2) {
    var SetCache = require_SetCache();
    var arraySome = require_arraySome();
    var cacheHas = require_cacheHas();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack.get(array);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    module2.exports = equalArrays;
  }
});

// .api/apis/zklighter/node_modules/lodash/_mapToArray.js
var require_mapToArray = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_mapToArray.js"(exports, module2) {
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    module2.exports = mapToArray;
  }
});

// .api/apis/zklighter/node_modules/lodash/_setToArray.js
var require_setToArray = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_setToArray.js"(exports, module2) {
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    module2.exports = setToArray;
  }
});

// .api/apis/zklighter/node_modules/lodash/_equalByTag.js
var require_equalByTag = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_equalByTag.js"(exports, module2) {
    var Symbol2 = require_Symbol();
    var Uint8Array2 = require_Uint8Array();
    var eq = require_eq();
    var equalArrays = require_equalArrays();
    var mapToArray = require_mapToArray();
    var setToArray = require_setToArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    module2.exports = equalByTag;
  }
});

// .api/apis/zklighter/node_modules/lodash/_equalObjects.js
var require_equalObjects = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_equalObjects.js"(exports, module2) {
    var getAllKeys = require_getAllKeys();
    var COMPARE_PARTIAL_FLAG = 1;
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
          return false;
        }
      }
      var objStacked = stack.get(object);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    module2.exports = equalObjects;
  }
});

// .api/apis/zklighter/node_modules/lodash/_baseIsEqualDeep.js
var require_baseIsEqualDeep = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_baseIsEqualDeep.js"(exports, module2) {
    var Stack = require_Stack();
    var equalArrays = require_equalArrays();
    var equalByTag = require_equalByTag();
    var equalObjects = require_equalObjects();
    var getTag = require_getTag();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isTypedArray = require_isTypedArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var objectTag = "[object Object]";
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    module2.exports = baseIsEqualDeep;
  }
});

// .api/apis/zklighter/node_modules/lodash/_baseIsEqual.js
var require_baseIsEqual = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_baseIsEqual.js"(exports, module2) {
    var baseIsEqualDeep = require_baseIsEqualDeep();
    var isObjectLike = require_isObjectLike();
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    module2.exports = baseIsEqual;
  }
});

// .api/apis/zklighter/node_modules/lodash/isEqual.js
var require_isEqual = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/isEqual.js"(exports, module2) {
    var baseIsEqual = require_baseIsEqual();
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }
    module2.exports = isEqual;
  }
});

// .api/apis/zklighter/node_modules/lodash/_isFlattenable.js
var require_isFlattenable = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_isFlattenable.js"(exports, module2) {
    var Symbol2 = require_Symbol();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    module2.exports = isFlattenable;
  }
});

// .api/apis/zklighter/node_modules/lodash/_baseFlatten.js
var require_baseFlatten = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_baseFlatten.js"(exports, module2) {
    var arrayPush = require_arrayPush();
    var isFlattenable = require_isFlattenable();
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    module2.exports = baseFlatten;
  }
});

// .api/apis/zklighter/node_modules/lodash/_arrayMap.js
var require_arrayMap = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_arrayMap.js"(exports, module2) {
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    module2.exports = arrayMap;
  }
});

// .api/apis/zklighter/node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/isSymbol.js"(exports, module2) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var symbolTag = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    module2.exports = isSymbol;
  }
});

// .api/apis/zklighter/node_modules/lodash/_isKey.js
var require_isKey = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_isKey.js"(exports, module2) {
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    module2.exports = isKey;
  }
});

// .api/apis/zklighter/node_modules/lodash/memoize.js
var require_memoize = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/memoize.js"(exports, module2) {
    var MapCache = require_MapCache();
    var FUNC_ERROR_TEXT = "Expected a function";
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    module2.exports = memoize;
  }
});

// .api/apis/zklighter/node_modules/lodash/_memoizeCapped.js
var require_memoizeCapped = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_memoizeCapped.js"(exports, module2) {
    var memoize = require_memoize();
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });
      var cache = result.cache;
      return result;
    }
    module2.exports = memoizeCapped;
  }
});

// .api/apis/zklighter/node_modules/lodash/_stringToPath.js
var require_stringToPath = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_stringToPath.js"(exports, module2) {
    var memoizeCapped = require_memoizeCapped();
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46) {
        result.push("");
      }
      string.replace(rePropName, function(match2, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match2);
      });
      return result;
    });
    module2.exports = stringToPath;
  }
});

// .api/apis/zklighter/node_modules/lodash/_baseToString.js
var require_baseToString = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_baseToString.js"(exports, module2) {
    var Symbol2 = require_Symbol();
    var arrayMap = require_arrayMap();
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module2.exports = baseToString;
  }
});

// .api/apis/zklighter/node_modules/lodash/toString.js
var require_toString = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/toString.js"(exports, module2) {
    var baseToString = require_baseToString();
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    module2.exports = toString;
  }
});

// .api/apis/zklighter/node_modules/lodash/_castPath.js
var require_castPath = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_castPath.js"(exports, module2) {
    var isArray = require_isArray();
    var isKey = require_isKey();
    var stringToPath = require_stringToPath();
    var toString = require_toString();
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }
    module2.exports = castPath;
  }
});

// .api/apis/zklighter/node_modules/lodash/_toKey.js
var require_toKey = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_toKey.js"(exports, module2) {
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module2.exports = toKey;
  }
});

// .api/apis/zklighter/node_modules/lodash/_baseGet.js
var require_baseGet = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_baseGet.js"(exports, module2) {
    var castPath = require_castPath();
    var toKey = require_toKey();
    function baseGet(object, path) {
      path = castPath(path, object);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    module2.exports = baseGet;
  }
});

// .api/apis/zklighter/node_modules/lodash/_baseIsMatch.js
var require_baseIsMatch = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_baseIsMatch.js"(exports, module2) {
    var Stack = require_Stack();
    var baseIsEqual = require_baseIsEqual();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length, length = index, noCustomizer = !customizer;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    module2.exports = baseIsMatch;
  }
});

// .api/apis/zklighter/node_modules/lodash/_isStrictComparable.js
var require_isStrictComparable = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_isStrictComparable.js"(exports, module2) {
    var isObject = require_isObject();
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }
    module2.exports = isStrictComparable;
  }
});

// .api/apis/zklighter/node_modules/lodash/_getMatchData.js
var require_getMatchData = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_getMatchData.js"(exports, module2) {
    var isStrictComparable = require_isStrictComparable();
    var keys = require_keys();
    function getMatchData(object) {
      var result = keys(object), length = result.length;
      while (length--) {
        var key = result[length], value = object[key];
        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    module2.exports = getMatchData;
  }
});

// .api/apis/zklighter/node_modules/lodash/_matchesStrictComparable.js
var require_matchesStrictComparable = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_matchesStrictComparable.js"(exports, module2) {
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
      };
    }
    module2.exports = matchesStrictComparable;
  }
});

// .api/apis/zklighter/node_modules/lodash/_baseMatches.js
var require_baseMatches = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_baseMatches.js"(exports, module2) {
    var baseIsMatch = require_baseIsMatch();
    var getMatchData = require_getMatchData();
    var matchesStrictComparable = require_matchesStrictComparable();
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    module2.exports = baseMatches;
  }
});

// .api/apis/zklighter/node_modules/lodash/get.js
var require_get = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/get.js"(exports, module2) {
    var baseGet = require_baseGet();
    function get(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    module2.exports = get;
  }
});

// .api/apis/zklighter/node_modules/lodash/_baseHasIn.js
var require_baseHasIn = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_baseHasIn.js"(exports, module2) {
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }
    module2.exports = baseHasIn;
  }
});

// .api/apis/zklighter/node_modules/lodash/_hasPath.js
var require_hasPath = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_hasPath.js"(exports, module2) {
    var castPath = require_castPath();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isIndex = require_isIndex();
    var isLength = require_isLength();
    var toKey = require_toKey();
    function hasPath(object, path, hasFunc) {
      path = castPath(path, object);
      var index = -1, length = path.length, result = false;
      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
    }
    module2.exports = hasPath;
  }
});

// .api/apis/zklighter/node_modules/lodash/hasIn.js
var require_hasIn = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/hasIn.js"(exports, module2) {
    var baseHasIn = require_baseHasIn();
    var hasPath = require_hasPath();
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }
    module2.exports = hasIn;
  }
});

// .api/apis/zklighter/node_modules/lodash/_baseMatchesProperty.js
var require_baseMatchesProperty = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_baseMatchesProperty.js"(exports, module2) {
    var baseIsEqual = require_baseIsEqual();
    var get = require_get();
    var hasIn = require_hasIn();
    var isKey = require_isKey();
    var isStrictComparable = require_isStrictComparable();
    var matchesStrictComparable = require_matchesStrictComparable();
    var toKey = require_toKey();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }
    module2.exports = baseMatchesProperty;
  }
});

// .api/apis/zklighter/node_modules/lodash/identity.js
var require_identity = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/identity.js"(exports, module2) {
    function identity(value) {
      return value;
    }
    module2.exports = identity;
  }
});

// .api/apis/zklighter/node_modules/lodash/_baseProperty.js
var require_baseProperty = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_baseProperty.js"(exports, module2) {
    function baseProperty(key) {
      return function(object) {
        return object == null ? void 0 : object[key];
      };
    }
    module2.exports = baseProperty;
  }
});

// .api/apis/zklighter/node_modules/lodash/_basePropertyDeep.js
var require_basePropertyDeep = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_basePropertyDeep.js"(exports, module2) {
    var baseGet = require_baseGet();
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }
    module2.exports = basePropertyDeep;
  }
});

// .api/apis/zklighter/node_modules/lodash/property.js
var require_property = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/property.js"(exports, module2) {
    var baseProperty = require_baseProperty();
    var basePropertyDeep = require_basePropertyDeep();
    var isKey = require_isKey();
    var toKey = require_toKey();
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    module2.exports = property;
  }
});

// .api/apis/zklighter/node_modules/lodash/_baseIteratee.js
var require_baseIteratee = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_baseIteratee.js"(exports, module2) {
    var baseMatches = require_baseMatches();
    var baseMatchesProperty = require_baseMatchesProperty();
    var identity = require_identity();
    var isArray = require_isArray();
    var property = require_property();
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    module2.exports = baseIteratee;
  }
});

// .api/apis/zklighter/node_modules/lodash/_createBaseFor.js
var require_createBaseFor = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_createBaseFor.js"(exports, module2) {
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    module2.exports = createBaseFor;
  }
});

// .api/apis/zklighter/node_modules/lodash/_baseFor.js
var require_baseFor = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_baseFor.js"(exports, module2) {
    var createBaseFor = require_createBaseFor();
    var baseFor = createBaseFor();
    module2.exports = baseFor;
  }
});

// .api/apis/zklighter/node_modules/lodash/_baseForOwn.js
var require_baseForOwn = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_baseForOwn.js"(exports, module2) {
    var baseFor = require_baseFor();
    var keys = require_keys();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    module2.exports = baseForOwn;
  }
});

// .api/apis/zklighter/node_modules/lodash/_createBaseEach.js
var require_createBaseEach = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_createBaseEach.js"(exports, module2) {
    var isArrayLike = require_isArrayLike();
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index-- : ++index < length) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    module2.exports = createBaseEach;
  }
});

// .api/apis/zklighter/node_modules/lodash/_baseEach.js
var require_baseEach = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_baseEach.js"(exports, module2) {
    var baseForOwn = require_baseForOwn();
    var createBaseEach = require_createBaseEach();
    var baseEach = createBaseEach(baseForOwn);
    module2.exports = baseEach;
  }
});

// .api/apis/zklighter/node_modules/lodash/_baseMap.js
var require_baseMap = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_baseMap.js"(exports, module2) {
    var baseEach = require_baseEach();
    var isArrayLike = require_isArrayLike();
    function baseMap(collection, iteratee) {
      var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
      baseEach(collection, function(value, key, collection2) {
        result[++index] = iteratee(value, key, collection2);
      });
      return result;
    }
    module2.exports = baseMap;
  }
});

// .api/apis/zklighter/node_modules/lodash/_baseSortBy.js
var require_baseSortBy = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_baseSortBy.js"(exports, module2) {
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    module2.exports = baseSortBy;
  }
});

// .api/apis/zklighter/node_modules/lodash/_compareAscending.js
var require_compareAscending = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_compareAscending.js"(exports, module2) {
    var isSymbol = require_isSymbol();
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
        var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
        if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
          return 1;
        }
        if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }
    module2.exports = compareAscending;
  }
});

// .api/apis/zklighter/node_modules/lodash/_compareMultiple.js
var require_compareMultiple = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_compareMultiple.js"(exports, module2) {
    var compareAscending = require_compareAscending();
    function compareMultiple(object, other, orders) {
      var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
      while (++index < length) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          var order = orders[index];
          return result * (order == "desc" ? -1 : 1);
        }
      }
      return object.index - other.index;
    }
    module2.exports = compareMultiple;
  }
});

// .api/apis/zklighter/node_modules/lodash/_baseOrderBy.js
var require_baseOrderBy = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_baseOrderBy.js"(exports, module2) {
    var arrayMap = require_arrayMap();
    var baseGet = require_baseGet();
    var baseIteratee = require_baseIteratee();
    var baseMap = require_baseMap();
    var baseSortBy = require_baseSortBy();
    var baseUnary = require_baseUnary();
    var compareMultiple = require_compareMultiple();
    var identity = require_identity();
    var isArray = require_isArray();
    function baseOrderBy(collection, iteratees, orders) {
      if (iteratees.length) {
        iteratees = arrayMap(iteratees, function(iteratee) {
          if (isArray(iteratee)) {
            return function(value) {
              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
            };
          }
          return iteratee;
        });
      } else {
        iteratees = [identity];
      }
      var index = -1;
      iteratees = arrayMap(iteratees, baseUnary(baseIteratee));
      var result = baseMap(collection, function(value, key, collection2) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { "criteria": criteria, "index": ++index, "value": value };
      });
      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }
    module2.exports = baseOrderBy;
  }
});

// .api/apis/zklighter/node_modules/lodash/_apply.js
var require_apply = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_apply.js"(exports, module2) {
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    module2.exports = apply;
  }
});

// .api/apis/zklighter/node_modules/lodash/_overRest.js
var require_overRest = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_overRest.js"(exports, module2) {
    var apply = require_apply();
    var nativeMax = Math.max;
    function overRest(func, start, transform) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }
    module2.exports = overRest;
  }
});

// .api/apis/zklighter/node_modules/lodash/constant.js
var require_constant = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/constant.js"(exports, module2) {
    function constant(value) {
      return function() {
        return value;
      };
    }
    module2.exports = constant;
  }
});

// .api/apis/zklighter/node_modules/lodash/_baseSetToString.js
var require_baseSetToString = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_baseSetToString.js"(exports, module2) {
    var constant = require_constant();
    var defineProperty = require_defineProperty();
    var identity = require_identity();
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string),
        "writable": true
      });
    };
    module2.exports = baseSetToString;
  }
});

// .api/apis/zklighter/node_modules/lodash/_shortOut.js
var require_shortOut = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_shortOut.js"(exports, module2) {
    var HOT_COUNT = 800;
    var HOT_SPAN = 16;
    var nativeNow = Date.now;
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    module2.exports = shortOut;
  }
});

// .api/apis/zklighter/node_modules/lodash/_setToString.js
var require_setToString = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_setToString.js"(exports, module2) {
    var baseSetToString = require_baseSetToString();
    var shortOut = require_shortOut();
    var setToString = shortOut(baseSetToString);
    module2.exports = setToString;
  }
});

// .api/apis/zklighter/node_modules/lodash/_baseRest.js
var require_baseRest = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_baseRest.js"(exports, module2) {
    var identity = require_identity();
    var overRest = require_overRest();
    var setToString = require_setToString();
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + "");
    }
    module2.exports = baseRest;
  }
});

// .api/apis/zklighter/node_modules/lodash/_isIterateeCall.js
var require_isIterateeCall = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_isIterateeCall.js"(exports, module2) {
    var eq = require_eq();
    var isArrayLike = require_isArrayLike();
    var isIndex = require_isIndex();
    var isObject = require_isObject();
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    module2.exports = isIterateeCall;
  }
});

// .api/apis/zklighter/node_modules/lodash/sortBy.js
var require_sortBy = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/sortBy.js"(exports, module2) {
    var baseFlatten = require_baseFlatten();
    var baseOrderBy = require_baseOrderBy();
    var baseRest = require_baseRest();
    var isIterateeCall = require_isIterateeCall();
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });
    module2.exports = sortBy;
  }
});

// .api/apis/zklighter/node_modules/lodash/_baseFindIndex.js
var require_baseFindIndex = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_baseFindIndex.js"(exports, module2) {
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    module2.exports = baseFindIndex;
  }
});

// .api/apis/zklighter/node_modules/lodash/_baseIsNaN.js
var require_baseIsNaN = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_baseIsNaN.js"(exports, module2) {
    function baseIsNaN(value) {
      return value !== value;
    }
    module2.exports = baseIsNaN;
  }
});

// .api/apis/zklighter/node_modules/lodash/_strictIndexOf.js
var require_strictIndexOf = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_strictIndexOf.js"(exports, module2) {
    function strictIndexOf(array, value, fromIndex) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    module2.exports = strictIndexOf;
  }
});

// .api/apis/zklighter/node_modules/lodash/_baseIndexOf.js
var require_baseIndexOf = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_baseIndexOf.js"(exports, module2) {
    var baseFindIndex = require_baseFindIndex();
    var baseIsNaN = require_baseIsNaN();
    var strictIndexOf = require_strictIndexOf();
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    module2.exports = baseIndexOf;
  }
});

// .api/apis/zklighter/node_modules/lodash/_arrayIncludes.js
var require_arrayIncludes = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_arrayIncludes.js"(exports, module2) {
    var baseIndexOf = require_baseIndexOf();
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    module2.exports = arrayIncludes;
  }
});

// .api/apis/zklighter/node_modules/lodash/_arrayIncludesWith.js
var require_arrayIncludesWith = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_arrayIncludesWith.js"(exports, module2) {
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    module2.exports = arrayIncludesWith;
  }
});

// .api/apis/zklighter/node_modules/lodash/noop.js
var require_noop = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/noop.js"(exports, module2) {
    function noop() {
    }
    module2.exports = noop;
  }
});

// .api/apis/zklighter/node_modules/lodash/_createSet.js
var require_createSet = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_createSet.js"(exports, module2) {
    var Set2 = require_Set();
    var noop = require_noop();
    var setToArray = require_setToArray();
    var INFINITY = 1 / 0;
    var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values) {
      return new Set2(values);
    };
    module2.exports = createSet;
  }
});

// .api/apis/zklighter/node_modules/lodash/_baseUniq.js
var require_baseUniq = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_baseUniq.js"(exports, module2) {
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var cacheHas = require_cacheHas();
    var createSet = require_createSet();
    var setToArray = require_setToArray();
    var LARGE_ARRAY_SIZE = 200;
    function baseUniq(array, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      } else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache();
      } else {
        seen = iteratee ? [] : result;
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while (seenIndex--) {
              if (seen[seenIndex] === computed) {
                continue outer;
              }
            }
            if (iteratee) {
              seen.push(computed);
            }
            result.push(value);
          } else if (!includes(seen, computed, comparator)) {
            if (seen !== result) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
      return result;
    }
    module2.exports = baseUniq;
  }
});

// .api/apis/zklighter/node_modules/lodash/uniq.js
var require_uniq = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/uniq.js"(exports, module2) {
    var baseUniq = require_baseUniq();
    function uniq(array) {
      return array && array.length ? baseUniq(array) : [];
    }
    module2.exports = uniq;
  }
});

// .api/apis/zklighter/node_modules/lodash/uniqWith.js
var require_uniqWith = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/uniqWith.js"(exports, module2) {
    var baseUniq = require_baseUniq();
    function uniqWith(array, comparator) {
      comparator = typeof comparator == "function" ? comparator : void 0;
      return array && array.length ? baseUniq(array, void 0, comparator) : [];
    }
    module2.exports = uniqWith;
  }
});

// .api/apis/zklighter/node_modules/lodash/defaults.js
var require_defaults = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/defaults.js"(exports, module2) {
    var baseRest = require_baseRest();
    var eq = require_eq();
    var isIterateeCall = require_isIterateeCall();
    var keysIn = require_keysIn();
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var defaults = baseRest(function(object, sources) {
      object = Object(object);
      var index = -1;
      var length = sources.length;
      var guard = length > 2 ? sources[2] : void 0;
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length = 1;
      }
      while (++index < length) {
        var source = sources[index];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;
        while (++propsIndex < propsLength) {
          var key = props[propsIndex];
          var value = object[key];
          if (value === void 0 || eq(value, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
            object[key] = source[key];
          }
        }
      }
      return object;
    });
    module2.exports = defaults;
  }
});

// .api/apis/zklighter/node_modules/lodash/_baseIntersection.js
var require_baseIntersection = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_baseIntersection.js"(exports, module2) {
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var arrayMap = require_arrayMap();
    var baseUnary = require_baseUnary();
    var cacheHas = require_cacheHas();
    var nativeMin = Math.min;
    function baseIntersection(arrays, iteratee, comparator) {
      var includes = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = Infinity, result = [];
      while (othIndex--) {
        var array = arrays[othIndex];
        if (othIndex && iteratee) {
          array = arrayMap(array, baseUnary(iteratee));
        }
        maxLength = nativeMin(array.length, maxLength);
        caches[othIndex] = !comparator && (iteratee || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : void 0;
      }
      array = arrays[0];
      var index = -1, seen = caches[0];
      outer:
        while (++index < length && result.length < maxLength) {
          var value = array[index], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (!(seen ? cacheHas(seen, computed) : includes(result, computed, comparator))) {
            othIndex = othLength;
            while (--othIndex) {
              var cache = caches[othIndex];
              if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator))) {
                continue outer;
              }
            }
            if (seen) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
      return result;
    }
    module2.exports = baseIntersection;
  }
});

// .api/apis/zklighter/node_modules/lodash/isArrayLikeObject.js
var require_isArrayLikeObject = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/isArrayLikeObject.js"(exports, module2) {
    var isArrayLike = require_isArrayLike();
    var isObjectLike = require_isObjectLike();
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    module2.exports = isArrayLikeObject;
  }
});

// .api/apis/zklighter/node_modules/lodash/_castArrayLikeObject.js
var require_castArrayLikeObject = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_castArrayLikeObject.js"(exports, module2) {
    var isArrayLikeObject = require_isArrayLikeObject();
    function castArrayLikeObject(value) {
      return isArrayLikeObject(value) ? value : [];
    }
    module2.exports = castArrayLikeObject;
  }
});

// .api/apis/zklighter/node_modules/lodash/last.js
var require_last = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/last.js"(exports, module2) {
    function last(array) {
      var length = array == null ? 0 : array.length;
      return length ? array[length - 1] : void 0;
    }
    module2.exports = last;
  }
});

// .api/apis/zklighter/node_modules/lodash/intersectionWith.js
var require_intersectionWith = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/intersectionWith.js"(exports, module2) {
    var arrayMap = require_arrayMap();
    var baseIntersection = require_baseIntersection();
    var baseRest = require_baseRest();
    var castArrayLikeObject = require_castArrayLikeObject();
    var last = require_last();
    var intersectionWith = baseRest(function(arrays) {
      var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
      comparator = typeof comparator == "function" ? comparator : void 0;
      if (comparator) {
        mapped.pop();
      }
      return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, void 0, comparator) : [];
    });
    module2.exports = intersectionWith;
  }
});

// .api/apis/zklighter/node_modules/lodash/isPlainObject.js
var require_isPlainObject = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/isPlainObject.js"(exports, module2) {
    var baseGetTag = require_baseGetTag();
    var getPrototype = require_getPrototype();
    var isObjectLike = require_isObjectLike();
    var objectTag = "[object Object]";
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    module2.exports = isPlainObject;
  }
});

// .api/apis/zklighter/node_modules/lodash/isBoolean.js
var require_isBoolean = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/isBoolean.js"(exports, module2) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var boolTag = "[object Boolean]";
    function isBoolean(value) {
      return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
    }
    module2.exports = isBoolean;
  }
});

// .api/apis/zklighter/node_modules/json-schema-compare/src/index.js
var require_src = __commonJS({
  ".api/apis/zklighter/node_modules/json-schema-compare/src/index.js"(exports, module2) {
    var isEqual = require_isEqual();
    var sortBy = require_sortBy();
    var uniq = require_uniq();
    var uniqWith = require_uniqWith();
    var defaults = require_defaults();
    var intersectionWith = require_intersectionWith();
    var isPlainObject = require_isPlainObject();
    var isBoolean = require_isBoolean();
    var normalizeArray = (val) => Array.isArray(val) ? val : [val];
    var undef = (val) => val === void 0;
    var keys = (obj) => isPlainObject(obj) || Array.isArray(obj) ? Object.keys(obj) : [];
    var has = (obj, key) => obj.hasOwnProperty(key);
    var stringArray = (arr) => sortBy(uniq(arr));
    var undefEmpty = (val) => undef(val) || Array.isArray(val) && val.length === 0;
    var keyValEqual = (a, b, key, compare2) => b && has(b, key) && a && has(a, key) && compare2(a[key], b[key]);
    var undefAndZero = (a, b) => undef(a) && b === 0 || undef(b) && a === 0 || isEqual(a, b);
    var falseUndefined = (a, b) => undef(a) && b === false || undef(b) && a === false || isEqual(a, b);
    var emptySchema = (schema) => undef(schema) || isEqual(schema, {}) || schema === true;
    var emptyObjUndef = (schema) => undef(schema) || isEqual(schema, {});
    var isSchema = (val) => undef(val) || isPlainObject(val) || val === true || val === false;
    function undefArrayEqual(a, b) {
      if (undefEmpty(a) && undefEmpty(b)) {
        return true;
      } else {
        return isEqual(stringArray(a), stringArray(b));
      }
    }
    function unsortedNormalizedArray(a, b) {
      a = normalizeArray(a);
      b = normalizeArray(b);
      return isEqual(stringArray(a), stringArray(b));
    }
    function schemaGroup(a, b, key, compare2) {
      var allProps = uniq(keys(a).concat(keys(b)));
      if (emptyObjUndef(a) && emptyObjUndef(b)) {
        return true;
      } else if (emptyObjUndef(a) && keys(b).length) {
        return false;
      } else if (emptyObjUndef(b) && keys(a).length) {
        return false;
      }
      return allProps.every(function(key2) {
        var aVal = a[key2];
        var bVal = b[key2];
        if (Array.isArray(aVal) && Array.isArray(bVal)) {
          return isEqual(stringArray(a), stringArray(b));
        } else if (Array.isArray(aVal) && !Array.isArray(bVal)) {
          return false;
        } else if (Array.isArray(bVal) && !Array.isArray(aVal)) {
          return false;
        }
        return keyValEqual(a, b, key2, compare2);
      });
    }
    function items(a, b, key, compare2) {
      if (isPlainObject(a) && isPlainObject(b)) {
        return compare2(a, b);
      } else if (Array.isArray(a) && Array.isArray(b)) {
        return schemaGroup(a, b, key, compare2);
      } else {
        return isEqual(a, b);
      }
    }
    function unsortedArray(a, b, key, compare2) {
      var uniqueA = uniqWith(a, compare2);
      var uniqueB = uniqWith(b, compare2);
      var inter = intersectionWith(uniqueA, uniqueB, compare2);
      return inter.length === Math.max(uniqueA.length, uniqueB.length);
    }
    var comparers = {
      title: isEqual,
      uniqueItems: falseUndefined,
      minLength: undefAndZero,
      minItems: undefAndZero,
      minProperties: undefAndZero,
      required: undefArrayEqual,
      enum: undefArrayEqual,
      type: unsortedNormalizedArray,
      items,
      anyOf: unsortedArray,
      allOf: unsortedArray,
      oneOf: unsortedArray,
      properties: schemaGroup,
      patternProperties: schemaGroup,
      dependencies: schemaGroup
    };
    var acceptsUndefined = [
      "properties",
      "patternProperties",
      "dependencies",
      "uniqueItems",
      "minLength",
      "minItems",
      "minProperties",
      "required"
    ];
    var schemaProps = ["additionalProperties", "additionalItems", "contains", "propertyNames", "not"];
    function compare(a, b, options) {
      options = defaults(options, {
        ignore: []
      });
      if (emptySchema(a) && emptySchema(b)) {
        return true;
      }
      if (!isSchema(a) || !isSchema(b)) {
        throw new Error("Either of the values are not a JSON schema.");
      }
      if (a === b) {
        return true;
      }
      if (isBoolean(a) && isBoolean(b)) {
        return a === b;
      }
      if (a === void 0 && b === false || b === void 0 && a === false) {
        return false;
      }
      if (undef(a) && !undef(b) || !undef(a) && undef(b)) {
        return false;
      }
      var allKeys = uniq(Object.keys(a).concat(Object.keys(b)));
      if (options.ignore.length) {
        allKeys = allKeys.filter((k) => options.ignore.indexOf(k) === -1);
      }
      if (!allKeys.length) {
        return true;
      }
      function innerCompare(a2, b2) {
        return compare(a2, b2, options);
      }
      return allKeys.every(function(key) {
        var aValue = a[key];
        var bValue = b[key];
        if (schemaProps.indexOf(key) !== -1) {
          return compare(aValue, bValue, options);
        }
        var comparer = comparers[key];
        if (!comparer) {
          comparer = isEqual;
        }
        if (isEqual(aValue, bValue)) {
          return true;
        }
        if (acceptsUndefined.indexOf(key) === -1) {
          if (!has(a, key) && has(b, key) || has(a, key) && !has(b, key)) {
            return aValue === bValue;
          }
        }
        var result = comparer(aValue, bValue, key, innerCompare);
        if (!isBoolean(result)) {
          throw new Error("Comparer must return true or false");
        }
        return result;
      });
    }
    module2.exports = compare;
  }
});

// .api/apis/zklighter/node_modules/validate.io-array/lib/index.js
var require_lib2 = __commonJS({
  ".api/apis/zklighter/node_modules/validate.io-array/lib/index.js"(exports, module2) {
    "use strict";
    function isArray(value) {
      return Object.prototype.toString.call(value) === "[object Array]";
    }
    module2.exports = Array.isArray || isArray;
  }
});

// .api/apis/zklighter/node_modules/validate.io-number/lib/index.js
var require_lib3 = __commonJS({
  ".api/apis/zklighter/node_modules/validate.io-number/lib/index.js"(exports, module2) {
    "use strict";
    function isNumber(value) {
      return (typeof value === "number" || Object.prototype.toString.call(value) === "[object Number]") && value.valueOf() === value.valueOf();
    }
    module2.exports = isNumber;
  }
});

// .api/apis/zklighter/node_modules/validate.io-integer/lib/index.js
var require_lib4 = __commonJS({
  ".api/apis/zklighter/node_modules/validate.io-integer/lib/index.js"(exports, module2) {
    "use strict";
    var isNumber = require_lib3();
    function isInteger(value) {
      return isNumber(value) && value % 1 === 0;
    }
    module2.exports = isInteger;
  }
});

// .api/apis/zklighter/node_modules/validate.io-integer-array/lib/index.js
var require_lib5 = __commonJS({
  ".api/apis/zklighter/node_modules/validate.io-integer-array/lib/index.js"(exports, module2) {
    "use strict";
    var isArray = require_lib2();
    var isInteger = require_lib4();
    function isIntegerArray(value) {
      var len;
      if (!isArray(value)) {
        return false;
      }
      len = value.length;
      if (!len) {
        return false;
      }
      for (var i = 0; i < len; i++) {
        if (!isInteger(value[i])) {
          return false;
        }
      }
      return true;
    }
    module2.exports = isIntegerArray;
  }
});

// .api/apis/zklighter/node_modules/validate.io-function/lib/index.js
var require_lib6 = __commonJS({
  ".api/apis/zklighter/node_modules/validate.io-function/lib/index.js"(exports, module2) {
    "use strict";
    function isFunction(value) {
      return typeof value === "function";
    }
    module2.exports = isFunction;
  }
});

// .api/apis/zklighter/node_modules/compute-gcd/lib/index.js
var require_lib7 = __commonJS({
  ".api/apis/zklighter/node_modules/compute-gcd/lib/index.js"(exports, module2) {
    "use strict";
    var isArray = require_lib2();
    var isIntegerArray = require_lib5();
    var isFunction = require_lib6();
    var MAXINT = Math.pow(2, 31) - 1;
    function gcd(a, b) {
      var k = 1, t;
      if (a === 0) {
        return b;
      }
      if (b === 0) {
        return a;
      }
      while (a % 2 === 0 && b % 2 === 0) {
        a = a / 2;
        b = b / 2;
        k = k * 2;
      }
      while (a % 2 === 0) {
        a = a / 2;
      }
      while (b) {
        while (b % 2 === 0) {
          b = b / 2;
        }
        if (a > b) {
          t = b;
          b = a;
          a = t;
        }
        b = b - a;
      }
      return k * a;
    }
    function bitwise(a, b) {
      var k = 0, t;
      if (a === 0) {
        return b;
      }
      if (b === 0) {
        return a;
      }
      while ((a & 1) === 0 && (b & 1) === 0) {
        a >>>= 1;
        b >>>= 1;
        k++;
      }
      while ((a & 1) === 0) {
        a >>>= 1;
      }
      while (b) {
        while ((b & 1) === 0) {
          b >>>= 1;
        }
        if (a > b) {
          t = b;
          b = a;
          a = t;
        }
        b = b - a;
      }
      return a << k;
    }
    function compute() {
      var nargs = arguments.length, args, clbk, arr, len, a, b, i;
      args = new Array(nargs);
      for (i = 0; i < nargs; i++) {
        args[i] = arguments[i];
      }
      if (isIntegerArray(args)) {
        if (nargs === 2) {
          a = args[0];
          b = args[1];
          if (a < 0) {
            a = -a;
          }
          if (b < 0) {
            b = -b;
          }
          if (a <= MAXINT && b <= MAXINT) {
            return bitwise(a, b);
          } else {
            return gcd(a, b);
          }
        }
        arr = args;
      } else if (!isArray(args[0])) {
        throw new TypeError("gcd()::invalid input argument. Must provide an array of integers. Value: `" + args[0] + "`.");
      } else if (nargs > 1) {
        arr = args[0];
        clbk = args[1];
        if (!isFunction(clbk)) {
          throw new TypeError("gcd()::invalid input argument. Accessor must be a function. Value: `" + clbk + "`.");
        }
      } else {
        arr = args[0];
      }
      len = arr.length;
      if (len < 2) {
        return null;
      }
      if (clbk) {
        a = new Array(len);
        for (i = 0; i < len; i++) {
          a[i] = clbk(arr[i], i);
        }
        arr = a;
      }
      if (nargs < 3) {
        if (!isIntegerArray(arr)) {
          throw new TypeError("gcd()::invalid input argument. Accessed array values must be integers. Value: `" + arr + "`.");
        }
      }
      for (i = 0; i < len; i++) {
        a = arr[i];
        if (a < 0) {
          arr[i] = -a;
        }
      }
      a = arr[0];
      for (i = 1; i < len; i++) {
        b = arr[i];
        if (b <= MAXINT && a <= MAXINT) {
          a = bitwise(a, b);
        } else {
          a = gcd(a, b);
        }
      }
      return a;
    }
    module2.exports = compute;
  }
});

// .api/apis/zklighter/node_modules/compute-lcm/lib/index.js
var require_lib8 = __commonJS({
  ".api/apis/zklighter/node_modules/compute-lcm/lib/index.js"(exports, module2) {
    "use strict";
    var gcd = require_lib7();
    var isArray = require_lib2();
    var isIntegerArray = require_lib5();
    var isFunction = require_lib6();
    function lcm() {
      var nargs = arguments.length, args, clbk, arr, len, a, b, i;
      args = new Array(nargs);
      for (i = 0; i < nargs; i++) {
        args[i] = arguments[i];
      }
      if (isIntegerArray(args)) {
        if (nargs === 2) {
          a = args[0];
          b = args[1];
          if (a < 0) {
            a = -a;
          }
          if (b < 0) {
            b = -b;
          }
          if (a === 0 || b === 0) {
            return 0;
          }
          return a / gcd(a, b) * b;
        }
        arr = args;
      } else if (!isArray(args[0])) {
        throw new TypeError("lcm()::invalid input argument. Must provide an array of integers. Value: `" + args[0] + "`.");
      } else if (nargs > 1) {
        arr = args[0];
        clbk = args[1];
        if (!isFunction(clbk)) {
          throw new TypeError("lcm()::invalid input argument. Accessor must be a function. Value: `" + clbk + "`.");
        }
      } else {
        arr = args[0];
      }
      len = arr.length;
      if (len < 2) {
        return null;
      }
      if (clbk) {
        a = new Array(len);
        for (i = 0; i < len; i++) {
          a[i] = clbk(arr[i], i);
        }
        arr = a;
      }
      if (nargs < 3) {
        if (!isIntegerArray(arr)) {
          throw new TypeError("lcm()::invalid input argument. Accessed array values must be integers. Value: `" + arr + "`.");
        }
      }
      for (i = 0; i < len; i++) {
        a = arr[i];
        if (a < 0) {
          arr[i] = -a;
        }
      }
      a = arr[0];
      for (i = 1; i < len; i++) {
        b = arr[i];
        if (a === 0 || b === 0) {
          return 0;
        }
        a = a / gcd(a, b) * b;
      }
      return a;
    }
    module2.exports = lcm;
  }
});

// .api/apis/zklighter/node_modules/lodash/_assignMergeValue.js
var require_assignMergeValue = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_assignMergeValue.js"(exports, module2) {
    var baseAssignValue = require_baseAssignValue();
    var eq = require_eq();
    function assignMergeValue(object, key, value) {
      if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    module2.exports = assignMergeValue;
  }
});

// .api/apis/zklighter/node_modules/lodash/_safeGet.js
var require_safeGet = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_safeGet.js"(exports, module2) {
    function safeGet(object, key) {
      if (key === "constructor" && typeof object[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object[key];
    }
    module2.exports = safeGet;
  }
});

// .api/apis/zklighter/node_modules/lodash/toPlainObject.js
var require_toPlainObject = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/toPlainObject.js"(exports, module2) {
    var copyObject = require_copyObject();
    var keysIn = require_keysIn();
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    module2.exports = toPlainObject;
  }
});

// .api/apis/zklighter/node_modules/lodash/_baseMergeDeep.js
var require_baseMergeDeep = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_baseMergeDeep.js"(exports, module2) {
    var assignMergeValue = require_assignMergeValue();
    var cloneBuffer = require_cloneBuffer();
    var cloneTypedArray = require_cloneTypedArray();
    var copyArray = require_copyArray();
    var initCloneObject = require_initCloneObject();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isArrayLikeObject = require_isArrayLikeObject();
    var isBuffer = require_isBuffer();
    var isFunction = require_isFunction();
    var isObject = require_isObject();
    var isPlainObject = require_isPlainObject();
    var isTypedArray = require_isTypedArray();
    var safeGet = require_safeGet();
    var toPlainObject = require_toPlainObject();
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack["delete"](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }
    module2.exports = baseMergeDeep;
  }
});

// .api/apis/zklighter/node_modules/lodash/_baseMerge.js
var require_baseMerge = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_baseMerge.js"(exports, module2) {
    var Stack = require_Stack();
    var assignMergeValue = require_assignMergeValue();
    var baseFor = require_baseFor();
    var baseMergeDeep = require_baseMergeDeep();
    var isObject = require_isObject();
    var keysIn = require_keysIn();
    var safeGet = require_safeGet();
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack());
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        } else {
          var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }
    module2.exports = baseMerge;
  }
});

// .api/apis/zklighter/node_modules/lodash/_customDefaultsMerge.js
var require_customDefaultsMerge = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_customDefaultsMerge.js"(exports, module2) {
    var baseMerge = require_baseMerge();
    var isObject = require_isObject();
    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
      if (isObject(objValue) && isObject(srcValue)) {
        stack.set(srcValue, objValue);
        baseMerge(objValue, srcValue, void 0, customDefaultsMerge, stack);
        stack["delete"](srcValue);
      }
      return objValue;
    }
    module2.exports = customDefaultsMerge;
  }
});

// .api/apis/zklighter/node_modules/lodash/_createAssigner.js
var require_createAssigner = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_createAssigner.js"(exports, module2) {
    var baseRest = require_baseRest();
    var isIterateeCall = require_isIterateeCall();
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    module2.exports = createAssigner;
  }
});

// .api/apis/zklighter/node_modules/lodash/mergeWith.js
var require_mergeWith = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/mergeWith.js"(exports, module2) {
    var baseMerge = require_baseMerge();
    var createAssigner = require_createAssigner();
    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
      baseMerge(object, source, srcIndex, customizer);
    });
    module2.exports = mergeWith;
  }
});

// .api/apis/zklighter/node_modules/lodash/defaultsDeep.js
var require_defaultsDeep = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/defaultsDeep.js"(exports, module2) {
    var apply = require_apply();
    var baseRest = require_baseRest();
    var customDefaultsMerge = require_customDefaultsMerge();
    var mergeWith = require_mergeWith();
    var defaultsDeep = baseRest(function(args) {
      args.push(void 0, customDefaultsMerge);
      return apply(mergeWith, void 0, args);
    });
    module2.exports = defaultsDeep;
  }
});

// .api/apis/zklighter/node_modules/lodash/flatten.js
var require_flatten = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/flatten.js"(exports, module2) {
    var baseFlatten = require_baseFlatten();
    function flatten(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, 1) : [];
    }
    module2.exports = flatten;
  }
});

// .api/apis/zklighter/node_modules/lodash/flattenDeep.js
var require_flattenDeep = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/flattenDeep.js"(exports, module2) {
    var baseFlatten = require_baseFlatten();
    var INFINITY = 1 / 0;
    function flattenDeep(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, INFINITY) : [];
    }
    module2.exports = flattenDeep;
  }
});

// .api/apis/zklighter/node_modules/lodash/intersection.js
var require_intersection = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/intersection.js"(exports, module2) {
    var arrayMap = require_arrayMap();
    var baseIntersection = require_baseIntersection();
    var baseRest = require_baseRest();
    var castArrayLikeObject = require_castArrayLikeObject();
    var intersection = baseRest(function(arrays) {
      var mapped = arrayMap(arrays, castArrayLikeObject);
      return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
    });
    module2.exports = intersection;
  }
});

// .api/apis/zklighter/node_modules/lodash/_baseIndexOfWith.js
var require_baseIndexOfWith = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_baseIndexOfWith.js"(exports, module2) {
    function baseIndexOfWith(array, value, fromIndex, comparator) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (comparator(array[index], value)) {
          return index;
        }
      }
      return -1;
    }
    module2.exports = baseIndexOfWith;
  }
});

// .api/apis/zklighter/node_modules/lodash/_basePullAll.js
var require_basePullAll = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_basePullAll.js"(exports, module2) {
    var arrayMap = require_arrayMap();
    var baseIndexOf = require_baseIndexOf();
    var baseIndexOfWith = require_baseIndexOfWith();
    var baseUnary = require_baseUnary();
    var copyArray = require_copyArray();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function basePullAll(array, values, iteratee, comparator) {
      var indexOf = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values.length, seen = array;
      if (array === values) {
        values = copyArray(values);
      }
      if (iteratee) {
        seen = arrayMap(array, baseUnary(iteratee));
      }
      while (++index < length) {
        var fromIndex = 0, value = values[index], computed = iteratee ? iteratee(value) : value;
        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
          if (seen !== array) {
            splice.call(seen, fromIndex, 1);
          }
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }
    module2.exports = basePullAll;
  }
});

// .api/apis/zklighter/node_modules/lodash/pullAll.js
var require_pullAll = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/pullAll.js"(exports, module2) {
    var basePullAll = require_basePullAll();
    function pullAll(array, values) {
      return array && array.length && values && values.length ? basePullAll(array, values) : array;
    }
    module2.exports = pullAll;
  }
});

// .api/apis/zklighter/node_modules/lodash/_castFunction.js
var require_castFunction = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_castFunction.js"(exports, module2) {
    var identity = require_identity();
    function castFunction(value) {
      return typeof value == "function" ? value : identity;
    }
    module2.exports = castFunction;
  }
});

// .api/apis/zklighter/node_modules/lodash/forEach.js
var require_forEach = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/forEach.js"(exports, module2) {
    var arrayEach = require_arrayEach();
    var baseEach = require_baseEach();
    var castFunction = require_castFunction();
    var isArray = require_isArray();
    function forEach(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach;
      return func(collection, castFunction(iteratee));
    }
    module2.exports = forEach;
  }
});

// .api/apis/zklighter/node_modules/lodash/_baseDifference.js
var require_baseDifference = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/_baseDifference.js"(exports, module2) {
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var arrayMap = require_arrayMap();
    var baseUnary = require_baseUnary();
    var cacheHas = require_cacheHas();
    var LARGE_ARRAY_SIZE = 200;
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      } else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee == null ? value : iteratee(value);
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var valuesIndex = valuesLength;
            while (valuesIndex--) {
              if (values[valuesIndex] === computed) {
                continue outer;
              }
            }
            result.push(value);
          } else if (!includes(values, computed, comparator)) {
            result.push(value);
          }
        }
      return result;
    }
    module2.exports = baseDifference;
  }
});

// .api/apis/zklighter/node_modules/lodash/without.js
var require_without = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/without.js"(exports, module2) {
    var baseDifference = require_baseDifference();
    var baseRest = require_baseRest();
    var isArrayLikeObject = require_isArrayLikeObject();
    var without = baseRest(function(array, values) {
      return isArrayLikeObject(array) ? baseDifference(array, values) : [];
    });
    module2.exports = without;
  }
});

// .api/apis/zklighter/node_modules/json-schema-merge-allof/src/common.js
var require_common2 = __commonJS({
  ".api/apis/zklighter/node_modules/json-schema-merge-allof/src/common.js"(exports, module2) {
    var flatten = require_flatten();
    var flattenDeep = require_flattenDeep();
    var isPlainObject = require_isPlainObject();
    var uniq = require_uniq();
    var uniqWith = require_uniqWith();
    var without = require_without();
    function deleteUndefinedProps(returnObject) {
      for (const prop in returnObject) {
        if (has(returnObject, prop) && isEmptySchema(returnObject[prop])) {
          delete returnObject[prop];
        }
      }
      return returnObject;
    }
    var allUniqueKeys = (arr) => uniq(flattenDeep(arr.map(keys)));
    var getValues = (schemas, key) => schemas.map((schema) => schema && schema[key]);
    var has = (obj, propName) => Object.prototype.hasOwnProperty.call(obj, propName);
    var keys = (obj) => {
      if (isPlainObject(obj) || Array.isArray(obj)) {
        return Object.keys(obj);
      } else {
        return [];
      }
    };
    var notUndefined = (val) => val !== void 0;
    var isSchema = (val) => isPlainObject(val) || val === true || val === false;
    var isEmptySchema = (obj) => !keys(obj).length && obj !== false && obj !== true;
    var withoutArr = (arr, ...rest) => without.apply(null, [arr].concat(flatten(rest)));
    module2.exports = {
      allUniqueKeys,
      deleteUndefinedProps,
      getValues,
      has,
      isEmptySchema,
      isSchema,
      keys,
      notUndefined,
      uniqWith,
      withoutArr
    };
  }
});

// .api/apis/zklighter/node_modules/json-schema-merge-allof/src/complex-resolvers/properties.js
var require_properties = __commonJS({
  ".api/apis/zklighter/node_modules/json-schema-merge-allof/src/complex-resolvers/properties.js"(exports, module2) {
    var compare = require_src();
    var forEach = require_forEach();
    var {
      allUniqueKeys,
      deleteUndefinedProps,
      getValues,
      keys,
      notUndefined,
      uniqWith,
      withoutArr
    } = require_common2();
    function removeFalseSchemas(target) {
      forEach(target, function(schema, prop) {
        if (schema === false) {
          delete target[prop];
        }
      });
    }
    function mergeSchemaGroup(group, mergeSchemas) {
      const allKeys = allUniqueKeys(group);
      return allKeys.reduce(function(all, key) {
        const schemas = getValues(group, key);
        const compacted = uniqWith(schemas.filter(notUndefined), compare);
        all[key] = mergeSchemas(compacted, key);
        return all;
      }, {});
    }
    module2.exports = {
      keywords: ["properties", "patternProperties", "additionalProperties"],
      resolver(values, parents, mergers, options) {
        if (!options.ignoreAdditionalProperties) {
          values.forEach(function(subSchema) {
            const otherSubSchemas = values.filter((s) => s !== subSchema);
            const ownKeys = keys(subSchema.properties);
            const ownPatternKeys = keys(subSchema.patternProperties);
            const ownPatterns = ownPatternKeys.map((k) => new RegExp(k));
            otherSubSchemas.forEach(function(other) {
              const allOtherKeys = keys(other.properties);
              const keysMatchingPattern = allOtherKeys.filter((k) => ownPatterns.some((pk) => pk.test(k)));
              const additionalKeys = withoutArr(allOtherKeys, ownKeys, keysMatchingPattern);
              additionalKeys.forEach(function(key) {
                other.properties[key] = mergers.properties([
                  other.properties[key],
                  subSchema.additionalProperties
                ], key);
              });
            });
          });
          values.forEach(function(subSchema) {
            const otherSubSchemas = values.filter((s) => s !== subSchema);
            const ownPatternKeys = keys(subSchema.patternProperties);
            if (subSchema.additionalProperties === false) {
              otherSubSchemas.forEach(function(other) {
                const allOtherPatterns = keys(other.patternProperties);
                const additionalPatternKeys = withoutArr(allOtherPatterns, ownPatternKeys);
                additionalPatternKeys.forEach((key) => delete other.patternProperties[key]);
              });
            }
          });
        }
        const returnObject = {
          additionalProperties: mergers.additionalProperties(values.map((s) => s.additionalProperties)),
          patternProperties: mergeSchemaGroup(values.map((s) => s.patternProperties), mergers.patternProperties),
          properties: mergeSchemaGroup(values.map((s) => s.properties), mergers.properties)
        };
        if (returnObject.additionalProperties === false) {
          removeFalseSchemas(returnObject.properties);
        }
        return deleteUndefinedProps(returnObject);
      }
    };
  }
});

// .api/apis/zklighter/node_modules/json-schema-merge-allof/src/complex-resolvers/items.js
var require_items = __commonJS({
  ".api/apis/zklighter/node_modules/json-schema-merge-allof/src/complex-resolvers/items.js"(exports, module2) {
    var compare = require_src();
    var forEach = require_forEach();
    var {
      allUniqueKeys,
      deleteUndefinedProps,
      has,
      isSchema,
      notUndefined,
      uniqWith
    } = require_common2();
    function removeFalseSchemasFromArray(target) {
      forEach(target, function(schema, index) {
        if (schema === false) {
          target.splice(index, 1);
        }
      });
    }
    function getItemSchemas(subSchemas, key) {
      return subSchemas.map(function(sub) {
        if (!sub) {
          return void 0;
        }
        if (Array.isArray(sub.items)) {
          const schemaAtPos = sub.items[key];
          if (isSchema(schemaAtPos)) {
            return schemaAtPos;
          } else if (has(sub, "additionalItems")) {
            return sub.additionalItems;
          }
        } else {
          return sub.items;
        }
        return void 0;
      });
    }
    function getAdditionalSchemas(subSchemas) {
      return subSchemas.map(function(sub) {
        if (!sub) {
          return void 0;
        }
        if (Array.isArray(sub.items)) {
          return sub.additionalItems;
        }
        return sub.items;
      });
    }
    function mergeItems(group, mergeSchemas, items) {
      const allKeys = allUniqueKeys(items);
      return allKeys.reduce(function(all, key) {
        const schemas = getItemSchemas(group, key);
        const compacted = uniqWith(schemas.filter(notUndefined), compare);
        all[key] = mergeSchemas(compacted, key);
        return all;
      }, []);
    }
    module2.exports = {
      keywords: ["items", "additionalItems"],
      resolver(values, parents, mergers) {
        const items = values.map((s) => s.items);
        const itemsCompacted = items.filter(notUndefined);
        const returnObject = {};
        if (itemsCompacted.every(isSchema)) {
          returnObject.items = mergers.items(items);
        } else {
          returnObject.items = mergeItems(values, mergers.items, items);
        }
        let schemasAtLastPos;
        if (itemsCompacted.every(Array.isArray)) {
          schemasAtLastPos = values.map((s) => s.additionalItems);
        } else if (itemsCompacted.some(Array.isArray)) {
          schemasAtLastPos = getAdditionalSchemas(values);
        }
        if (schemasAtLastPos) {
          returnObject.additionalItems = mergers.additionalItems(schemasAtLastPos);
        }
        if (returnObject.additionalItems === false && Array.isArray(returnObject.items)) {
          removeFalseSchemasFromArray(returnObject.items);
        }
        return deleteUndefinedProps(returnObject);
      }
    };
  }
});

// .api/apis/zklighter/node_modules/json-schema-merge-allof/src/index.js
var require_src2 = __commonJS({
  ".api/apis/zklighter/node_modules/json-schema-merge-allof/src/index.js"(exports, module2) {
    var cloneDeep = require_cloneDeep();
    var compare = require_src();
    var computeLcm = require_lib8();
    var defaultsDeep = require_defaultsDeep();
    var flatten = require_flatten();
    var flattenDeep = require_flattenDeep();
    var intersection = require_intersection();
    var intersectionWith = require_intersectionWith();
    var isEqual = require_isEqual();
    var isPlainObject = require_isPlainObject();
    var pullAll = require_pullAll();
    var sortBy = require_sortBy();
    var uniq = require_uniq();
    var uniqWith = require_uniqWith();
    var propertiesResolver = require_properties();
    var itemsResolver = require_items();
    var contains = (arr, val) => arr.indexOf(val) !== -1;
    var isSchema = (val) => isPlainObject(val) || val === true || val === false;
    var isFalse = (val) => val === false;
    var isTrue = (val) => val === true;
    var schemaResolver = (compacted, key, mergeSchemas) => mergeSchemas(compacted);
    var stringArray = (values) => sortBy(uniq(flattenDeep(values)));
    var notUndefined = (val) => val !== void 0;
    var allUniqueKeys = (arr) => uniq(flattenDeep(arr.map(keys)));
    var first = (compacted) => compacted[0];
    var required = (compacted) => stringArray(compacted);
    var maximumValue = (compacted) => Math.max.apply(Math, compacted);
    var minimumValue = (compacted) => Math.min.apply(Math, compacted);
    var uniqueItems = (compacted) => compacted.some(isTrue);
    var examples = (compacted) => uniqWith(flatten(compacted), isEqual);
    function compareProp(key) {
      return function(a, b) {
        return compare({
          [key]: a
        }, { [key]: b });
      };
    }
    function getAllOf(schema) {
      let { allOf = [], ...copy } = schema;
      copy = isPlainObject(schema) ? copy : schema;
      return [copy, ...allOf.map(getAllOf)];
    }
    function getValues(schemas, key) {
      return schemas.map((schema) => schema && schema[key]);
    }
    function tryMergeSchemaGroups(schemaGroups, mergeSchemas) {
      return schemaGroups.map(function(schemas, index) {
        try {
          return mergeSchemas(schemas, index);
        } catch (e) {
          return void 0;
        }
      }).filter(notUndefined);
    }
    function keys(obj) {
      if (isPlainObject(obj) || Array.isArray(obj)) {
        return Object.keys(obj);
      } else {
        return [];
      }
    }
    function getAnyOfCombinations(arrOfArrays, combinations) {
      combinations = combinations || [];
      if (!arrOfArrays.length) {
        return combinations;
      }
      const values = arrOfArrays.slice(0).shift();
      const rest = arrOfArrays.slice(1);
      if (combinations.length) {
        return getAnyOfCombinations(rest, flatten(combinations.map((combination) => values.map((item) => [item].concat(combination)))));
      }
      return getAnyOfCombinations(rest, values.map((item) => item));
    }
    function throwIncompatible(values, paths) {
      let asJSON;
      try {
        asJSON = values.map(function(val) {
          return JSON.stringify(val, null, 2);
        }).join("\n");
      } catch (variable) {
        asJSON = values.join(", ");
      }
      throw new Error('Could not resolve values for path:"' + paths.join(".") + '". They are probably incompatible. Values: \n' + asJSON);
    }
    function callGroupResolver(complexKeywords, resolverName, schemas, mergeSchemas, options, parents) {
      if (complexKeywords.length) {
        const resolverConfig = options.complexResolvers[resolverName];
        if (!resolverConfig || !resolverConfig.resolver) {
          throw new Error("No resolver found for " + resolverName);
        }
        const extractedKeywordsOnly = schemas.map((schema) => complexKeywords.reduce((all, key) => {
          if (schema[key] !== void 0) all[key] = schema[key];
          return all;
        }, {}));
        const unique = uniqWith(extractedKeywordsOnly, compare);
        const mergers = resolverConfig.keywords.reduce((all, key) => ({
          ...all,
          [key]: (schemas2, extraKey = []) => mergeSchemas(schemas2, null, parents.concat(key, extraKey))
        }), {});
        const result = resolverConfig.resolver(unique, parents.concat(resolverName), mergers, options);
        if (!isPlainObject(result)) {
          throwIncompatible(unique, parents.concat(resolverName));
        }
        return result;
      }
    }
    function createRequiredMetaArray(arr) {
      return { required: arr };
    }
    var schemaGroupProps = ["properties", "patternProperties", "definitions", "dependencies"];
    var schemaArrays = ["anyOf", "oneOf"];
    var schemaProps = [
      "additionalProperties",
      "additionalItems",
      "contains",
      "propertyNames",
      "not",
      "items"
    ];
    var defaultResolvers = {
      type(compacted) {
        if (compacted.some(Array.isArray)) {
          const normalized = compacted.map(function(val) {
            return Array.isArray(val) ? val : [val];
          });
          const common = intersection.apply(null, normalized);
          if (common.length === 1) {
            return common[0];
          } else if (common.length > 1) {
            return uniq(common);
          }
        }
      },
      dependencies(compacted, paths, mergeSchemas) {
        const allChildren = allUniqueKeys(compacted);
        return allChildren.reduce(function(all, childKey) {
          const childSchemas = getValues(compacted, childKey);
          let innerCompacted = uniqWith(childSchemas.filter(notUndefined), isEqual);
          const innerArrays = innerCompacted.filter(Array.isArray);
          if (innerArrays.length) {
            if (innerArrays.length === innerCompacted.length) {
              all[childKey] = stringArray(innerCompacted);
            } else {
              const innerSchemas = innerCompacted.filter(isSchema);
              const arrayMetaScheams = innerArrays.map(createRequiredMetaArray);
              all[childKey] = mergeSchemas(innerSchemas.concat(arrayMetaScheams), childKey);
            }
            return all;
          }
          innerCompacted = uniqWith(innerCompacted, compare);
          all[childKey] = mergeSchemas(innerCompacted, childKey);
          return all;
        }, {});
      },
      oneOf(compacted, paths, mergeSchemas) {
        const combinations = getAnyOfCombinations(cloneDeep(compacted));
        const result = tryMergeSchemaGroups(combinations, mergeSchemas);
        const unique = uniqWith(result, compare);
        if (unique.length) {
          return unique;
        }
      },
      not(compacted) {
        return { anyOf: compacted };
      },
      pattern(compacted) {
        return compacted.map((r) => "(?=" + r + ")").join("");
      },
      multipleOf(compacted) {
        let integers = compacted.slice(0);
        let factor = 1;
        while (integers.some((n) => !Number.isInteger(n))) {
          integers = integers.map((n) => n * 10);
          factor = factor * 10;
        }
        return computeLcm(integers) / factor;
      },
      enum(compacted) {
        const enums = intersectionWith.apply(null, compacted.concat(isEqual));
        if (enums.length) {
          return sortBy(enums);
        }
      }
    };
    defaultResolvers.$id = first;
    defaultResolvers.$ref = first;
    defaultResolvers.$schema = first;
    defaultResolvers.additionalItems = schemaResolver;
    defaultResolvers.additionalProperties = schemaResolver;
    defaultResolvers.anyOf = defaultResolvers.oneOf;
    defaultResolvers.contains = schemaResolver;
    defaultResolvers.default = first;
    defaultResolvers.definitions = defaultResolvers.dependencies;
    defaultResolvers.description = first;
    defaultResolvers.examples = examples;
    defaultResolvers.exclusiveMaximum = minimumValue;
    defaultResolvers.exclusiveMinimum = maximumValue;
    defaultResolvers.items = itemsResolver;
    defaultResolvers.maximum = minimumValue;
    defaultResolvers.maxItems = minimumValue;
    defaultResolvers.maxLength = minimumValue;
    defaultResolvers.maxProperties = minimumValue;
    defaultResolvers.minimum = maximumValue;
    defaultResolvers.minItems = maximumValue;
    defaultResolvers.minLength = maximumValue;
    defaultResolvers.minProperties = maximumValue;
    defaultResolvers.properties = propertiesResolver;
    defaultResolvers.propertyNames = schemaResolver;
    defaultResolvers.required = required;
    defaultResolvers.title = first;
    defaultResolvers.uniqueItems = uniqueItems;
    var defaultComplexResolvers = {
      properties: propertiesResolver,
      items: itemsResolver
    };
    function merger(rootSchema, options, totalSchemas) {
      totalSchemas = totalSchemas || [];
      options = defaultsDeep(options, {
        ignoreAdditionalProperties: false,
        resolvers: defaultResolvers,
        complexResolvers: defaultComplexResolvers,
        deep: true
      });
      const complexResolvers = Object.entries(options.complexResolvers);
      function mergeSchemas(schemas, base, parents) {
        schemas = cloneDeep(schemas.filter(notUndefined));
        parents = parents || [];
        const merged2 = isPlainObject(base) ? base : {};
        if (!schemas.length) {
          return;
        }
        if (schemas.some(isFalse)) {
          return false;
        }
        if (schemas.every(isTrue)) {
          return true;
        }
        schemas = schemas.filter(isPlainObject);
        const allKeys = allUniqueKeys(schemas);
        if (options.deep && contains(allKeys, "allOf")) {
          return merger({
            allOf: schemas
          }, options, totalSchemas);
        }
        const complexKeysArr = complexResolvers.map(([mainKeyWord, resolverConf]) => allKeys.filter((k) => resolverConf.keywords.includes(k)));
        complexKeysArr.forEach((keys2) => pullAll(allKeys, keys2));
        allKeys.forEach(function(key) {
          const values = getValues(schemas, key);
          const compacted = uniqWith(values.filter(notUndefined), compareProp(key));
          if (compacted.length === 1 && contains(schemaArrays, key)) {
            merged2[key] = compacted[0].map((schema) => mergeSchemas([schema], schema));
          } else if (compacted.length === 1 && !contains(schemaGroupProps, key) && !contains(schemaProps, key)) {
            merged2[key] = compacted[0];
          } else {
            const resolver = options.resolvers[key] || options.resolvers.defaultResolver;
            if (!resolver) throw new Error("No resolver found for key " + key + ". You can provide a resolver for this keyword in the options, or provide a default resolver.");
            const merger2 = (schemas2, extraKey = []) => mergeSchemas(schemas2, null, parents.concat(key, extraKey));
            merged2[key] = resolver(compacted, parents.concat(key), merger2, options);
            if (merged2[key] === void 0) {
              throwIncompatible(compacted, parents.concat(key));
            } else if (merged2[key] === void 0) {
              delete merged2[key];
            }
          }
        });
        return complexResolvers.reduce((all, [resolverKeyword, config], index) => ({
          ...all,
          ...callGroupResolver(complexKeysArr[index], resolverKeyword, schemas, mergeSchemas, options, parents)
        }), merged2);
      }
      const allSchemas = flattenDeep(getAllOf(rootSchema));
      const merged = mergeSchemas(allSchemas);
      return merged;
    }
    merger.options = {
      resolvers: defaultResolvers
    };
    module2.exports = merger;
  }
});

// .api/apis/zklighter/node_modules/es5-ext/function/noop.js
var require_noop2 = __commonJS({
  ".api/apis/zklighter/node_modules/es5-ext/function/noop.js"(exports, module2) {
    "use strict";
    module2.exports = function() {
    };
  }
});

// .api/apis/zklighter/node_modules/es5-ext/object/is-value.js
var require_is_value = __commonJS({
  ".api/apis/zklighter/node_modules/es5-ext/object/is-value.js"(exports, module2) {
    "use strict";
    var _undefined = require_noop2()();
    module2.exports = function(val) {
      return val !== _undefined && val !== null;
    };
  }
});

// .api/apis/zklighter/node_modules/es5-ext/object/normalize-options.js
var require_normalize_options = __commonJS({
  ".api/apis/zklighter/node_modules/es5-ext/object/normalize-options.js"(exports, module2) {
    "use strict";
    var isValue = require_is_value();
    var forEach = Array.prototype.forEach;
    var create = Object.create;
    var process2 = function(src, obj) {
      var key;
      for (key in src) obj[key] = src[key];
    };
    module2.exports = function(opts1) {
      var result = create(null);
      forEach.call(arguments, function(options) {
        if (!isValue(options)) return;
        process2(Object(options), result);
      });
      return result;
    };
  }
});

// .api/apis/zklighter/node_modules/es5-ext/math/sign/is-implemented.js
var require_is_implemented = __commonJS({
  ".api/apis/zklighter/node_modules/es5-ext/math/sign/is-implemented.js"(exports, module2) {
    "use strict";
    module2.exports = function() {
      var sign = Math.sign;
      if (typeof sign !== "function") return false;
      return sign(10) === 1 && sign(-20) === -1;
    };
  }
});

// .api/apis/zklighter/node_modules/es5-ext/math/sign/shim.js
var require_shim = __commonJS({
  ".api/apis/zklighter/node_modules/es5-ext/math/sign/shim.js"(exports, module2) {
    "use strict";
    module2.exports = function(value) {
      value = Number(value);
      if (isNaN(value) || value === 0) return value;
      return value > 0 ? 1 : -1;
    };
  }
});

// .api/apis/zklighter/node_modules/es5-ext/math/sign/index.js
var require_sign = __commonJS({
  ".api/apis/zklighter/node_modules/es5-ext/math/sign/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_is_implemented()() ? Math.sign : require_shim();
  }
});

// .api/apis/zklighter/node_modules/es5-ext/number/to-integer.js
var require_to_integer = __commonJS({
  ".api/apis/zklighter/node_modules/es5-ext/number/to-integer.js"(exports, module2) {
    "use strict";
    var sign = require_sign();
    var abs = Math.abs;
    var floor = Math.floor;
    module2.exports = function(value) {
      if (isNaN(value)) return 0;
      value = Number(value);
      if (value === 0 || !isFinite(value)) return value;
      return sign(value) * floor(abs(value));
    };
  }
});

// .api/apis/zklighter/node_modules/es5-ext/number/to-pos-integer.js
var require_to_pos_integer = __commonJS({
  ".api/apis/zklighter/node_modules/es5-ext/number/to-pos-integer.js"(exports, module2) {
    "use strict";
    var toInteger = require_to_integer();
    var max = Math.max;
    module2.exports = function(value) {
      return max(0, toInteger(value));
    };
  }
});

// .api/apis/zklighter/node_modules/memoizee/lib/resolve-length.js
var require_resolve_length = __commonJS({
  ".api/apis/zklighter/node_modules/memoizee/lib/resolve-length.js"(exports, module2) {
    "use strict";
    var toPosInt = require_to_pos_integer();
    module2.exports = function(optsLength, fnLength, isAsync) {
      var length;
      if (isNaN(optsLength)) {
        length = fnLength;
        if (!(length >= 0)) return 1;
        if (isAsync && length) return length - 1;
        return length;
      }
      if (optsLength === false) return false;
      return toPosInt(optsLength);
    };
  }
});

// .api/apis/zklighter/node_modules/es5-ext/object/valid-callable.js
var require_valid_callable = __commonJS({
  ".api/apis/zklighter/node_modules/es5-ext/object/valid-callable.js"(exports, module2) {
    "use strict";
    module2.exports = function(fn) {
      if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
      return fn;
    };
  }
});

// .api/apis/zklighter/node_modules/es5-ext/object/valid-value.js
var require_valid_value = __commonJS({
  ".api/apis/zklighter/node_modules/es5-ext/object/valid-value.js"(exports, module2) {
    "use strict";
    var isValue = require_is_value();
    module2.exports = function(value) {
      if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
      return value;
    };
  }
});

// .api/apis/zklighter/node_modules/es5-ext/object/_iterate.js
var require_iterate = __commonJS({
  ".api/apis/zklighter/node_modules/es5-ext/object/_iterate.js"(exports, module2) {
    "use strict";
    var callable = require_valid_callable();
    var value = require_valid_value();
    var bind = Function.prototype.bind;
    var call = Function.prototype.call;
    var keys = Object.keys;
    var objPropertyIsEnumerable = Object.prototype.propertyIsEnumerable;
    module2.exports = function(method, defVal) {
      return function(obj, cb) {
        var list, thisArg = arguments[2], compareFn = arguments[3];
        obj = Object(value(obj));
        callable(cb);
        list = keys(obj);
        if (compareFn) {
          list.sort(typeof compareFn === "function" ? bind.call(compareFn, obj) : void 0);
        }
        if (typeof method !== "function") method = list[method];
        return call.call(method, list, function(key, index) {
          if (!objPropertyIsEnumerable.call(obj, key)) return defVal;
          return call.call(cb, thisArg, obj[key], key, obj, index);
        });
      };
    };
  }
});

// .api/apis/zklighter/node_modules/es5-ext/object/for-each.js
var require_for_each = __commonJS({
  ".api/apis/zklighter/node_modules/es5-ext/object/for-each.js"(exports, module2) {
    "use strict";
    module2.exports = require_iterate()("forEach");
  }
});

// .api/apis/zklighter/node_modules/memoizee/lib/registered-extensions.js
var require_registered_extensions = __commonJS({
  ".api/apis/zklighter/node_modules/memoizee/lib/registered-extensions.js"() {
    "use strict";
  }
});

// .api/apis/zklighter/node_modules/es5-ext/object/assign/is-implemented.js
var require_is_implemented2 = __commonJS({
  ".api/apis/zklighter/node_modules/es5-ext/object/assign/is-implemented.js"(exports, module2) {
    "use strict";
    module2.exports = function() {
      var assign = Object.assign, obj;
      if (typeof assign !== "function") return false;
      obj = { foo: "raz" };
      assign(obj, { bar: "dwa" }, { trzy: "trzy" });
      return obj.foo + obj.bar + obj.trzy === "razdwatrzy";
    };
  }
});

// .api/apis/zklighter/node_modules/es5-ext/object/keys/is-implemented.js
var require_is_implemented3 = __commonJS({
  ".api/apis/zklighter/node_modules/es5-ext/object/keys/is-implemented.js"(exports, module2) {
    "use strict";
    module2.exports = function() {
      try {
        Object.keys("primitive");
        return true;
      } catch (e) {
        return false;
      }
    };
  }
});

// .api/apis/zklighter/node_modules/es5-ext/object/keys/shim.js
var require_shim2 = __commonJS({
  ".api/apis/zklighter/node_modules/es5-ext/object/keys/shim.js"(exports, module2) {
    "use strict";
    var isValue = require_is_value();
    var keys = Object.keys;
    module2.exports = function(object) {
      return keys(isValue(object) ? Object(object) : object);
    };
  }
});

// .api/apis/zklighter/node_modules/es5-ext/object/keys/index.js
var require_keys2 = __commonJS({
  ".api/apis/zklighter/node_modules/es5-ext/object/keys/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_is_implemented3()() ? Object.keys : require_shim2();
  }
});

// .api/apis/zklighter/node_modules/es5-ext/object/assign/shim.js
var require_shim3 = __commonJS({
  ".api/apis/zklighter/node_modules/es5-ext/object/assign/shim.js"(exports, module2) {
    "use strict";
    var keys = require_keys2();
    var value = require_valid_value();
    var max = Math.max;
    module2.exports = function(dest, src) {
      var error, i, length = max(arguments.length, 2), assign;
      dest = Object(value(dest));
      assign = function(key) {
        try {
          dest[key] = src[key];
        } catch (e) {
          if (!error) error = e;
        }
      };
      for (i = 1; i < length; ++i) {
        src = arguments[i];
        keys(src).forEach(assign);
      }
      if (error !== void 0) throw error;
      return dest;
    };
  }
});

// .api/apis/zklighter/node_modules/es5-ext/object/assign/index.js
var require_assign = __commonJS({
  ".api/apis/zklighter/node_modules/es5-ext/object/assign/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_is_implemented2()() ? Object.assign : require_shim3();
  }
});

// .api/apis/zklighter/node_modules/es5-ext/object/is-object.js
var require_is_object = __commonJS({
  ".api/apis/zklighter/node_modules/es5-ext/object/is-object.js"(exports, module2) {
    "use strict";
    var isValue = require_is_value();
    var map = { function: true, object: true };
    module2.exports = function(value) {
      return isValue(value) && map[typeof value] || false;
    };
  }
});

// .api/apis/zklighter/node_modules/es5-ext/error/custom.js
var require_custom = __commonJS({
  ".api/apis/zklighter/node_modules/es5-ext/error/custom.js"(exports, module2) {
    "use strict";
    var assign = require_assign();
    var isObject = require_is_object();
    var isValue = require_is_value();
    var captureStackTrace = Error.captureStackTrace;
    module2.exports = function(message) {
      var err = new Error(message), code = arguments[1], ext = arguments[2];
      if (!isValue(ext)) {
        if (isObject(code)) {
          ext = code;
          code = null;
        }
      }
      if (isValue(ext)) assign(err, ext);
      if (isValue(code)) err.code = code;
      if (captureStackTrace) captureStackTrace(err, module2.exports);
      return err;
    };
  }
});

// .api/apis/zklighter/node_modules/es5-ext/object/mixin.js
var require_mixin = __commonJS({
  ".api/apis/zklighter/node_modules/es5-ext/object/mixin.js"(exports, module2) {
    "use strict";
    var value = require_valid_value();
    var defineProperty = Object.defineProperty;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var getOwnPropertyNames = Object.getOwnPropertyNames;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    module2.exports = function(target, source) {
      var error, sourceObject = Object(value(source));
      target = Object(value(target));
      getOwnPropertyNames(sourceObject).forEach(function(name) {
        try {
          defineProperty(target, name, getOwnPropertyDescriptor(source, name));
        } catch (e) {
          error = e;
        }
      });
      if (typeof getOwnPropertySymbols === "function") {
        getOwnPropertySymbols(sourceObject).forEach(function(symbol) {
          try {
            defineProperty(target, symbol, getOwnPropertyDescriptor(source, symbol));
          } catch (e) {
            error = e;
          }
        });
      }
      if (error !== void 0) throw error;
      return target;
    };
  }
});

// .api/apis/zklighter/node_modules/es5-ext/function/_define-length.js
var require_define_length = __commonJS({
  ".api/apis/zklighter/node_modules/es5-ext/function/_define-length.js"(exports, module2) {
    "use strict";
    var toPosInt = require_to_pos_integer();
    var test = function(arg1, arg2) {
      return arg2;
    };
    var desc;
    var defineProperty;
    var generate;
    var mixin;
    try {
      Object.defineProperty(test, "length", {
        configurable: true,
        writable: false,
        enumerable: false,
        value: 1
      });
    } catch (ignore) {
    }
    if (test.length === 1) {
      desc = { configurable: true, writable: false, enumerable: false };
      defineProperty = Object.defineProperty;
      module2.exports = function(fn, length) {
        length = toPosInt(length);
        if (fn.length === length) return fn;
        desc.value = length;
        return defineProperty(fn, "length", desc);
      };
    } else {
      mixin = require_mixin();
      generate = /* @__PURE__ */ function() {
        var cache = [];
        return function(length) {
          var args, i = 0;
          if (cache[length]) return cache[length];
          args = [];
          while (length--) args.push("a" + (++i).toString(36));
          return new Function(
            "fn",
            "return function (" + args.join(", ") + ") { return fn.apply(this, arguments); };"
          );
        };
      }();
      module2.exports = function(src, length) {
        var target;
        length = toPosInt(length);
        if (src.length === length) return src;
        target = generate(length)(src);
        try {
          mixin(target, src);
        } catch (ignore) {
        }
        return target;
      };
    }
  }
});

// .api/apis/zklighter/node_modules/type/value/is.js
var require_is = __commonJS({
  ".api/apis/zklighter/node_modules/type/value/is.js"(exports, module2) {
    "use strict";
    var _undefined = void 0;
    module2.exports = function(value) {
      return value !== _undefined && value !== null;
    };
  }
});

// .api/apis/zklighter/node_modules/type/object/is.js
var require_is2 = __commonJS({
  ".api/apis/zklighter/node_modules/type/object/is.js"(exports, module2) {
    "use strict";
    var isValue = require_is();
    var possibleTypes = {
      "object": true,
      "function": true,
      "undefined": true
      /* document.all */
    };
    module2.exports = function(value) {
      if (!isValue(value)) return false;
      return hasOwnProperty.call(possibleTypes, typeof value);
    };
  }
});

// .api/apis/zklighter/node_modules/type/prototype/is.js
var require_is3 = __commonJS({
  ".api/apis/zklighter/node_modules/type/prototype/is.js"(exports, module2) {
    "use strict";
    var isObject = require_is2();
    module2.exports = function(value) {
      if (!isObject(value)) return false;
      try {
        if (!value.constructor) return false;
        return value.constructor.prototype === value;
      } catch (error) {
        return false;
      }
    };
  }
});

// .api/apis/zklighter/node_modules/type/function/is.js
var require_is4 = __commonJS({
  ".api/apis/zklighter/node_modules/type/function/is.js"(exports, module2) {
    "use strict";
    var isPrototype = require_is3();
    module2.exports = function(value) {
      if (typeof value !== "function") return false;
      if (!hasOwnProperty.call(value, "length")) return false;
      try {
        if (typeof value.length !== "number") return false;
        if (typeof value.call !== "function") return false;
        if (typeof value.apply !== "function") return false;
      } catch (error) {
        return false;
      }
      return !isPrototype(value);
    };
  }
});

// .api/apis/zklighter/node_modules/type/plain-function/is.js
var require_is5 = __commonJS({
  ".api/apis/zklighter/node_modules/type/plain-function/is.js"(exports, module2) {
    "use strict";
    var isFunction = require_is4();
    var classRe = /^\s*class[\s{/}]/;
    var functionToString = Function.prototype.toString;
    module2.exports = function(value) {
      if (!isFunction(value)) return false;
      if (classRe.test(functionToString.call(value))) return false;
      return true;
    };
  }
});

// .api/apis/zklighter/node_modules/es5-ext/string/#/contains/is-implemented.js
var require_is_implemented4 = __commonJS({
  ".api/apis/zklighter/node_modules/es5-ext/string/#/contains/is-implemented.js"(exports, module2) {
    "use strict";
    var str = "razdwatrzy";
    module2.exports = function() {
      if (typeof str.contains !== "function") return false;
      return str.contains("dwa") === true && str.contains("foo") === false;
    };
  }
});

// .api/apis/zklighter/node_modules/es5-ext/string/#/contains/shim.js
var require_shim4 = __commonJS({
  ".api/apis/zklighter/node_modules/es5-ext/string/#/contains/shim.js"(exports, module2) {
    "use strict";
    var indexOf = String.prototype.indexOf;
    module2.exports = function(searchString) {
      return indexOf.call(this, searchString, arguments[1]) > -1;
    };
  }
});

// .api/apis/zklighter/node_modules/es5-ext/string/#/contains/index.js
var require_contains = __commonJS({
  ".api/apis/zklighter/node_modules/es5-ext/string/#/contains/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_is_implemented4()() ? String.prototype.contains : require_shim4();
  }
});

// .api/apis/zklighter/node_modules/d/index.js
var require_d = __commonJS({
  ".api/apis/zklighter/node_modules/d/index.js"(exports, module2) {
    "use strict";
    var isValue = require_is();
    var isPlainFunction = require_is5();
    var assign = require_assign();
    var normalizeOpts = require_normalize_options();
    var contains = require_contains();
    var d = module2.exports = function(dscr, value) {
      var c, e, w, options, desc;
      if (arguments.length < 2 || typeof dscr !== "string") {
        options = value;
        value = dscr;
        dscr = null;
      } else {
        options = arguments[2];
      }
      if (isValue(dscr)) {
        c = contains.call(dscr, "c");
        e = contains.call(dscr, "e");
        w = contains.call(dscr, "w");
      } else {
        c = w = true;
        e = false;
      }
      desc = { value, configurable: c, enumerable: e, writable: w };
      return !options ? desc : assign(normalizeOpts(options), desc);
    };
    d.gs = function(dscr, get, set) {
      var c, e, options, desc;
      if (typeof dscr !== "string") {
        options = set;
        set = get;
        get = dscr;
        dscr = null;
      } else {
        options = arguments[3];
      }
      if (!isValue(get)) {
        get = void 0;
      } else if (!isPlainFunction(get)) {
        options = get;
        get = set = void 0;
      } else if (!isValue(set)) {
        set = void 0;
      } else if (!isPlainFunction(set)) {
        options = set;
        set = void 0;
      }
      if (isValue(dscr)) {
        c = contains.call(dscr, "c");
        e = contains.call(dscr, "e");
      } else {
        c = true;
        e = false;
      }
      desc = { get, set, configurable: c, enumerable: e };
      return !options ? desc : assign(normalizeOpts(options), desc);
    };
  }
});

// .api/apis/zklighter/node_modules/event-emitter/index.js
var require_event_emitter = __commonJS({
  ".api/apis/zklighter/node_modules/event-emitter/index.js"(exports, module2) {
    "use strict";
    var d = require_d();
    var callable = require_valid_callable();
    var apply = Function.prototype.apply;
    var call = Function.prototype.call;
    var create = Object.create;
    var defineProperty = Object.defineProperty;
    var defineProperties = Object.defineProperties;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var descriptor = { configurable: true, enumerable: false, writable: true };
    var on;
    var once;
    var off;
    var emit;
    var methods;
    var descriptors;
    var base;
    on = function(type, listener) {
      var data;
      callable(listener);
      if (!hasOwnProperty2.call(this, "__ee__")) {
        data = descriptor.value = create(null);
        defineProperty(this, "__ee__", descriptor);
        descriptor.value = null;
      } else {
        data = this.__ee__;
      }
      if (!data[type]) data[type] = listener;
      else if (typeof data[type] === "object") data[type].push(listener);
      else data[type] = [data[type], listener];
      return this;
    };
    once = function(type, listener) {
      var once2, self2;
      callable(listener);
      self2 = this;
      on.call(this, type, once2 = function() {
        off.call(self2, type, once2);
        apply.call(listener, this, arguments);
      });
      once2.__eeOnceListener__ = listener;
      return this;
    };
    off = function(type, listener) {
      var data, listeners, candidate, i;
      callable(listener);
      if (!hasOwnProperty2.call(this, "__ee__")) return this;
      data = this.__ee__;
      if (!data[type]) return this;
      listeners = data[type];
      if (typeof listeners === "object") {
        for (i = 0; candidate = listeners[i]; ++i) {
          if (candidate === listener || candidate.__eeOnceListener__ === listener) {
            if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
            else listeners.splice(i, 1);
          }
        }
      } else {
        if (listeners === listener || listeners.__eeOnceListener__ === listener) {
          delete data[type];
        }
      }
      return this;
    };
    emit = function(type) {
      var i, l, listener, listeners, args;
      if (!hasOwnProperty2.call(this, "__ee__")) return;
      listeners = this.__ee__[type];
      if (!listeners) return;
      if (typeof listeners === "object") {
        l = arguments.length;
        args = new Array(l - 1);
        for (i = 1; i < l; ++i) args[i - 1] = arguments[i];
        listeners = listeners.slice();
        for (i = 0; listener = listeners[i]; ++i) {
          apply.call(listener, this, args);
        }
      } else {
        switch (arguments.length) {
          case 1:
            call.call(listeners, this);
            break;
          case 2:
            call.call(listeners, this, arguments[1]);
            break;
          case 3:
            call.call(listeners, this, arguments[1], arguments[2]);
            break;
          default:
            l = arguments.length;
            args = new Array(l - 1);
            for (i = 1; i < l; ++i) {
              args[i - 1] = arguments[i];
            }
            apply.call(listeners, this, args);
        }
      }
    };
    methods = {
      on,
      once,
      off,
      emit
    };
    descriptors = {
      on: d(on),
      once: d(once),
      off: d(off),
      emit: d(emit)
    };
    base = defineProperties({}, descriptors);
    module2.exports = exports = function(o) {
      return o == null ? create(base) : defineProperties(Object(o), descriptors);
    };
    exports.methods = methods;
  }
});

// .api/apis/zklighter/node_modules/es5-ext/array/from/is-implemented.js
var require_is_implemented5 = __commonJS({
  ".api/apis/zklighter/node_modules/es5-ext/array/from/is-implemented.js"(exports, module2) {
    "use strict";
    module2.exports = function() {
      var from = Array.from, arr, result;
      if (typeof from !== "function") return false;
      arr = ["raz", "dwa"];
      result = from(arr);
      return Boolean(result && result !== arr && result[1] === "dwa");
    };
  }
});

// .api/apis/zklighter/node_modules/ext/global-this/is-implemented.js
var require_is_implemented6 = __commonJS({
  ".api/apis/zklighter/node_modules/ext/global-this/is-implemented.js"(exports, module2) {
    "use strict";
    module2.exports = function() {
      if (typeof globalThis !== "object") return false;
      if (!globalThis) return false;
      return globalThis.Array === Array;
    };
  }
});

// .api/apis/zklighter/node_modules/ext/global-this/implementation.js
var require_implementation = __commonJS({
  ".api/apis/zklighter/node_modules/ext/global-this/implementation.js"(exports, module2) {
    var naiveFallback = function() {
      if (typeof self === "object" && self) return self;
      if (typeof window === "object" && window) return window;
      throw new Error("Unable to resolve global `this`");
    };
    module2.exports = function() {
      if (this) return this;
      try {
        Object.defineProperty(Object.prototype, "__global__", {
          get: function() {
            return this;
          },
          configurable: true
        });
      } catch (error) {
        return naiveFallback();
      }
      try {
        if (!__global__) return naiveFallback();
        return __global__;
      } finally {
        delete Object.prototype.__global__;
      }
    }();
  }
});

// .api/apis/zklighter/node_modules/ext/global-this/index.js
var require_global_this = __commonJS({
  ".api/apis/zklighter/node_modules/ext/global-this/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_is_implemented6()() ? globalThis : require_implementation();
  }
});

// .api/apis/zklighter/node_modules/es6-symbol/is-implemented.js
var require_is_implemented7 = __commonJS({
  ".api/apis/zklighter/node_modules/es6-symbol/is-implemented.js"(exports, module2) {
    "use strict";
    var global2 = require_global_this();
    var validTypes = { object: true, symbol: true };
    module2.exports = function() {
      var Symbol2 = global2.Symbol;
      var symbol;
      if (typeof Symbol2 !== "function") return false;
      symbol = Symbol2("test symbol");
      try {
        String(symbol);
      } catch (e) {
        return false;
      }
      if (!validTypes[typeof Symbol2.iterator]) return false;
      if (!validTypes[typeof Symbol2.toPrimitive]) return false;
      if (!validTypes[typeof Symbol2.toStringTag]) return false;
      return true;
    };
  }
});

// .api/apis/zklighter/node_modules/es6-symbol/is-symbol.js
var require_is_symbol = __commonJS({
  ".api/apis/zklighter/node_modules/es6-symbol/is-symbol.js"(exports, module2) {
    "use strict";
    module2.exports = function(value) {
      if (!value) return false;
      if (typeof value === "symbol") return true;
      if (!value.constructor) return false;
      if (value.constructor.name !== "Symbol") return false;
      return value[value.constructor.toStringTag] === "Symbol";
    };
  }
});

// .api/apis/zklighter/node_modules/es6-symbol/validate-symbol.js
var require_validate_symbol = __commonJS({
  ".api/apis/zklighter/node_modules/es6-symbol/validate-symbol.js"(exports, module2) {
    "use strict";
    var isSymbol = require_is_symbol();
    module2.exports = function(value) {
      if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
      return value;
    };
  }
});

// .api/apis/zklighter/node_modules/es6-symbol/lib/private/generate-name.js
var require_generate_name = __commonJS({
  ".api/apis/zklighter/node_modules/es6-symbol/lib/private/generate-name.js"(exports, module2) {
    "use strict";
    var d = require_d();
    var create = Object.create;
    var defineProperty = Object.defineProperty;
    var objPrototype = Object.prototype;
    var created = create(null);
    module2.exports = function(desc) {
      var postfix = 0, name, ie11BugWorkaround;
      while (created[desc + (postfix || "")]) ++postfix;
      desc += postfix || "";
      created[desc] = true;
      name = "@@" + desc;
      defineProperty(
        objPrototype,
        name,
        d.gs(null, function(value) {
          if (ie11BugWorkaround) return;
          ie11BugWorkaround = true;
          defineProperty(this, name, d(value));
          ie11BugWorkaround = false;
        })
      );
      return name;
    };
  }
});

// .api/apis/zklighter/node_modules/es6-symbol/lib/private/setup/standard-symbols.js
var require_standard_symbols = __commonJS({
  ".api/apis/zklighter/node_modules/es6-symbol/lib/private/setup/standard-symbols.js"(exports, module2) {
    "use strict";
    var d = require_d();
    var NativeSymbol = require_global_this().Symbol;
    module2.exports = function(SymbolPolyfill) {
      return Object.defineProperties(SymbolPolyfill, {
        // To ensure proper interoperability with other native functions (e.g. Array.from)
        // fallback to eventual native implementation of given symbol
        hasInstance: d(
          "",
          NativeSymbol && NativeSymbol.hasInstance || SymbolPolyfill("hasInstance")
        ),
        isConcatSpreadable: d(
          "",
          NativeSymbol && NativeSymbol.isConcatSpreadable || SymbolPolyfill("isConcatSpreadable")
        ),
        iterator: d("", NativeSymbol && NativeSymbol.iterator || SymbolPolyfill("iterator")),
        match: d("", NativeSymbol && NativeSymbol.match || SymbolPolyfill("match")),
        replace: d("", NativeSymbol && NativeSymbol.replace || SymbolPolyfill("replace")),
        search: d("", NativeSymbol && NativeSymbol.search || SymbolPolyfill("search")),
        species: d("", NativeSymbol && NativeSymbol.species || SymbolPolyfill("species")),
        split: d("", NativeSymbol && NativeSymbol.split || SymbolPolyfill("split")),
        toPrimitive: d(
          "",
          NativeSymbol && NativeSymbol.toPrimitive || SymbolPolyfill("toPrimitive")
        ),
        toStringTag: d(
          "",
          NativeSymbol && NativeSymbol.toStringTag || SymbolPolyfill("toStringTag")
        ),
        unscopables: d(
          "",
          NativeSymbol && NativeSymbol.unscopables || SymbolPolyfill("unscopables")
        )
      });
    };
  }
});

// .api/apis/zklighter/node_modules/es6-symbol/lib/private/setup/symbol-registry.js
var require_symbol_registry = __commonJS({
  ".api/apis/zklighter/node_modules/es6-symbol/lib/private/setup/symbol-registry.js"(exports, module2) {
    "use strict";
    var d = require_d();
    var validateSymbol = require_validate_symbol();
    var registry = /* @__PURE__ */ Object.create(null);
    module2.exports = function(SymbolPolyfill) {
      return Object.defineProperties(SymbolPolyfill, {
        for: d(function(key) {
          if (registry[key]) return registry[key];
          return registry[key] = SymbolPolyfill(String(key));
        }),
        keyFor: d(function(symbol) {
          var key;
          validateSymbol(symbol);
          for (key in registry) {
            if (registry[key] === symbol) return key;
          }
          return void 0;
        })
      });
    };
  }
});

// .api/apis/zklighter/node_modules/es6-symbol/polyfill.js
var require_polyfill = __commonJS({
  ".api/apis/zklighter/node_modules/es6-symbol/polyfill.js"(exports, module2) {
    "use strict";
    var d = require_d();
    var validateSymbol = require_validate_symbol();
    var NativeSymbol = require_global_this().Symbol;
    var generateName = require_generate_name();
    var setupStandardSymbols = require_standard_symbols();
    var setupSymbolRegistry = require_symbol_registry();
    var create = Object.create;
    var defineProperties = Object.defineProperties;
    var defineProperty = Object.defineProperty;
    var SymbolPolyfill;
    var HiddenSymbol;
    var isNativeSafe;
    if (typeof NativeSymbol === "function") {
      try {
        String(NativeSymbol());
        isNativeSafe = true;
      } catch (ignore) {
      }
    } else {
      NativeSymbol = null;
    }
    HiddenSymbol = function Symbol2(description) {
      if (this instanceof HiddenSymbol) throw new TypeError("Symbol is not a constructor");
      return SymbolPolyfill(description);
    };
    module2.exports = SymbolPolyfill = function Symbol2(description) {
      var symbol;
      if (this instanceof Symbol2) throw new TypeError("Symbol is not a constructor");
      if (isNativeSafe) return NativeSymbol(description);
      symbol = create(HiddenSymbol.prototype);
      description = description === void 0 ? "" : String(description);
      return defineProperties(symbol, {
        __description__: d("", description),
        __name__: d("", generateName(description))
      });
    };
    setupStandardSymbols(SymbolPolyfill);
    setupSymbolRegistry(SymbolPolyfill);
    defineProperties(HiddenSymbol.prototype, {
      constructor: d(SymbolPolyfill),
      toString: d("", function() {
        return this.__name__;
      })
    });
    defineProperties(SymbolPolyfill.prototype, {
      toString: d(function() {
        return "Symbol (" + validateSymbol(this).__description__ + ")";
      }),
      valueOf: d(function() {
        return validateSymbol(this);
      })
    });
    defineProperty(
      SymbolPolyfill.prototype,
      SymbolPolyfill.toPrimitive,
      d("", function() {
        var symbol = validateSymbol(this);
        if (typeof symbol === "symbol") return symbol;
        return symbol.toString();
      })
    );
    defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d("c", "Symbol"));
    defineProperty(
      HiddenSymbol.prototype,
      SymbolPolyfill.toStringTag,
      d("c", SymbolPolyfill.prototype[SymbolPolyfill.toStringTag])
    );
    defineProperty(
      HiddenSymbol.prototype,
      SymbolPolyfill.toPrimitive,
      d("c", SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive])
    );
  }
});

// .api/apis/zklighter/node_modules/es6-symbol/index.js
var require_es6_symbol = __commonJS({
  ".api/apis/zklighter/node_modules/es6-symbol/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_is_implemented7()() ? require_global_this().Symbol : require_polyfill();
  }
});

// .api/apis/zklighter/node_modules/es5-ext/function/is-arguments.js
var require_is_arguments = __commonJS({
  ".api/apis/zklighter/node_modules/es5-ext/function/is-arguments.js"(exports, module2) {
    "use strict";
    var objToString = Object.prototype.toString;
    var id = objToString.call(/* @__PURE__ */ function() {
      return arguments;
    }());
    module2.exports = function(value) {
      return objToString.call(value) === id;
    };
  }
});

// .api/apis/zklighter/node_modules/es5-ext/function/is-function.js
var require_is_function = __commonJS({
  ".api/apis/zklighter/node_modules/es5-ext/function/is-function.js"(exports, module2) {
    "use strict";
    var objToString = Object.prototype.toString;
    var isFunctionStringTag = RegExp.prototype.test.bind(/^[object [A-Za-z0-9]*Function]$/);
    module2.exports = function(value) {
      return typeof value === "function" && isFunctionStringTag(objToString.call(value));
    };
  }
});

// .api/apis/zklighter/node_modules/es5-ext/string/is-string.js
var require_is_string = __commonJS({
  ".api/apis/zklighter/node_modules/es5-ext/string/is-string.js"(exports, module2) {
    "use strict";
    var objToString = Object.prototype.toString;
    var id = objToString.call("");
    module2.exports = function(value) {
      return typeof value === "string" || value && typeof value === "object" && (value instanceof String || objToString.call(value) === id) || false;
    };
  }
});

// .api/apis/zklighter/node_modules/es5-ext/array/from/shim.js
var require_shim5 = __commonJS({
  ".api/apis/zklighter/node_modules/es5-ext/array/from/shim.js"(exports, module2) {
    "use strict";
    var iteratorSymbol = require_es6_symbol().iterator;
    var isArguments = require_is_arguments();
    var isFunction = require_is_function();
    var toPosInt = require_to_pos_integer();
    var callable = require_valid_callable();
    var validValue = require_valid_value();
    var isValue = require_is_value();
    var isString = require_is_string();
    var isArray = Array.isArray;
    var call = Function.prototype.call;
    var desc = { configurable: true, enumerable: true, writable: true, value: null };
    var defineProperty = Object.defineProperty;
    module2.exports = function(arrayLike) {
      var mapFn = arguments[1], thisArg = arguments[2], Context, i, j, arr, length, code, iterator, result, getIterator, value;
      arrayLike = Object(validValue(arrayLike));
      if (isValue(mapFn)) callable(mapFn);
      if (!this || this === Array || !isFunction(this)) {
        if (!mapFn) {
          if (isArguments(arrayLike)) {
            length = arrayLike.length;
            if (length !== 1) return Array.apply(null, arrayLike);
            arr = new Array(1);
            arr[0] = arrayLike[0];
            return arr;
          }
          if (isArray(arrayLike)) {
            arr = new Array(length = arrayLike.length);
            for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
            return arr;
          }
        }
        arr = [];
      } else {
        Context = this;
      }
      if (!isArray(arrayLike)) {
        if ((getIterator = arrayLike[iteratorSymbol]) !== void 0) {
          iterator = callable(getIterator).call(arrayLike);
          if (Context) arr = new Context();
          result = iterator.next();
          i = 0;
          while (!result.done) {
            value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
            if (Context) {
              desc.value = value;
              defineProperty(arr, i, desc);
            } else {
              arr[i] = value;
            }
            result = iterator.next();
            ++i;
          }
          length = i;
        } else if (isString(arrayLike)) {
          length = arrayLike.length;
          if (Context) arr = new Context();
          for (i = 0, j = 0; i < length; ++i) {
            value = arrayLike[i];
            if (i + 1 < length) {
              code = value.charCodeAt(0);
              if (code >= 55296 && code <= 56319) value += arrayLike[++i];
            }
            value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
            if (Context) {
              desc.value = value;
              defineProperty(arr, j, desc);
            } else {
              arr[j] = value;
            }
            ++j;
          }
          length = j;
        }
      }
      if (length === void 0) {
        length = toPosInt(arrayLike.length);
        if (Context) arr = new Context(length);
        for (i = 0; i < length; ++i) {
          value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
          if (Context) {
            desc.value = value;
            defineProperty(arr, i, desc);
          } else {
            arr[i] = value;
          }
        }
      }
      if (Context) {
        desc.value = null;
        arr.length = length;
      }
      return arr;
    };
  }
});

// .api/apis/zklighter/node_modules/es5-ext/array/from/index.js
var require_from = __commonJS({
  ".api/apis/zklighter/node_modules/es5-ext/array/from/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_is_implemented5()() ? Array.from : require_shim5();
  }
});

// .api/apis/zklighter/node_modules/es5-ext/array/to-array.js
var require_to_array = __commonJS({
  ".api/apis/zklighter/node_modules/es5-ext/array/to-array.js"(exports, module2) {
    "use strict";
    var from = require_from();
    var isArray = Array.isArray;
    module2.exports = function(arrayLike) {
      return isArray(arrayLike) ? arrayLike : from(arrayLike);
    };
  }
});

// .api/apis/zklighter/node_modules/memoizee/lib/resolve-resolve.js
var require_resolve_resolve = __commonJS({
  ".api/apis/zklighter/node_modules/memoizee/lib/resolve-resolve.js"(exports, module2) {
    "use strict";
    var toArray = require_to_array();
    var isValue = require_is_value();
    var callable = require_valid_callable();
    var slice = Array.prototype.slice;
    var resolveArgs;
    resolveArgs = function(args) {
      return this.map(function(resolve, i) {
        return resolve ? resolve(args[i]) : args[i];
      }).concat(
        slice.call(args, this.length)
      );
    };
    module2.exports = function(resolvers) {
      resolvers = toArray(resolvers);
      resolvers.forEach(function(resolve) {
        if (isValue(resolve)) callable(resolve);
      });
      return resolveArgs.bind(resolvers);
    };
  }
});

// .api/apis/zklighter/node_modules/memoizee/lib/resolve-normalize.js
var require_resolve_normalize = __commonJS({
  ".api/apis/zklighter/node_modules/memoizee/lib/resolve-normalize.js"(exports, module2) {
    "use strict";
    var callable = require_valid_callable();
    module2.exports = function(userNormalizer) {
      var normalizer;
      if (typeof userNormalizer === "function") return { set: userNormalizer, get: userNormalizer };
      normalizer = { get: callable(userNormalizer.get) };
      if (userNormalizer.set !== void 0) {
        normalizer.set = callable(userNormalizer.set);
        if (userNormalizer.delete) normalizer.delete = callable(userNormalizer.delete);
        if (userNormalizer.clear) normalizer.clear = callable(userNormalizer.clear);
        return normalizer;
      }
      normalizer.set = normalizer.get;
      return normalizer;
    };
  }
});

// .api/apis/zklighter/node_modules/memoizee/lib/configure-map.js
var require_configure_map = __commonJS({
  ".api/apis/zklighter/node_modules/memoizee/lib/configure-map.js"(exports, module2) {
    "use strict";
    var customError = require_custom();
    var defineLength = require_define_length();
    var d = require_d();
    var ee = require_event_emitter().methods;
    var resolveResolve = require_resolve_resolve();
    var resolveNormalize = require_resolve_normalize();
    var apply = Function.prototype.apply;
    var call = Function.prototype.call;
    var create = Object.create;
    var defineProperties = Object.defineProperties;
    var on = ee.on;
    var emit = ee.emit;
    module2.exports = function(original, length, options) {
      var cache = create(null), conf, memLength, get, set, del, clear, extDel, extGet, extHas, normalizer, getListeners, setListeners, deleteListeners, memoized, resolve;
      if (length !== false) memLength = length;
      else if (isNaN(original.length)) memLength = 1;
      else memLength = original.length;
      if (options.normalizer) {
        normalizer = resolveNormalize(options.normalizer);
        get = normalizer.get;
        set = normalizer.set;
        del = normalizer.delete;
        clear = normalizer.clear;
      }
      if (options.resolvers != null) resolve = resolveResolve(options.resolvers);
      if (get) {
        memoized = defineLength(function(arg) {
          var id, result, args = arguments;
          if (resolve) args = resolve(args);
          id = get(args);
          if (id !== null) {
            if (hasOwnProperty.call(cache, id)) {
              if (getListeners) conf.emit("get", id, args, this);
              return cache[id];
            }
          }
          if (args.length === 1) result = call.call(original, this, args[0]);
          else result = apply.call(original, this, args);
          if (id === null) {
            id = get(args);
            if (id !== null) throw customError("Circular invocation", "CIRCULAR_INVOCATION");
            id = set(args);
          } else if (hasOwnProperty.call(cache, id)) {
            throw customError("Circular invocation", "CIRCULAR_INVOCATION");
          }
          cache[id] = result;
          if (setListeners) conf.emit("set", id, null, result);
          return result;
        }, memLength);
      } else if (length === 0) {
        memoized = function() {
          var result;
          if (hasOwnProperty.call(cache, "data")) {
            if (getListeners) conf.emit("get", "data", arguments, this);
            return cache.data;
          }
          if (arguments.length) result = apply.call(original, this, arguments);
          else result = call.call(original, this);
          if (hasOwnProperty.call(cache, "data")) {
            throw customError("Circular invocation", "CIRCULAR_INVOCATION");
          }
          cache.data = result;
          if (setListeners) conf.emit("set", "data", null, result);
          return result;
        };
      } else {
        memoized = function(arg) {
          var result, args = arguments, id;
          if (resolve) args = resolve(arguments);
          id = String(args[0]);
          if (hasOwnProperty.call(cache, id)) {
            if (getListeners) conf.emit("get", id, args, this);
            return cache[id];
          }
          if (args.length === 1) result = call.call(original, this, args[0]);
          else result = apply.call(original, this, args);
          if (hasOwnProperty.call(cache, id)) {
            throw customError("Circular invocation", "CIRCULAR_INVOCATION");
          }
          cache[id] = result;
          if (setListeners) conf.emit("set", id, null, result);
          return result;
        };
      }
      conf = {
        original,
        memoized,
        profileName: options.profileName,
        get: function(args) {
          if (resolve) args = resolve(args);
          if (get) return get(args);
          return String(args[0]);
        },
        has: function(id) {
          return hasOwnProperty.call(cache, id);
        },
        delete: function(id) {
          var result;
          if (!hasOwnProperty.call(cache, id)) return;
          if (del) del(id);
          result = cache[id];
          delete cache[id];
          if (deleteListeners) conf.emit("delete", id, result);
        },
        clear: function() {
          var oldCache = cache;
          if (clear) clear();
          cache = create(null);
          conf.emit("clear", oldCache);
        },
        on: function(type, listener) {
          if (type === "get") getListeners = true;
          else if (type === "set") setListeners = true;
          else if (type === "delete") deleteListeners = true;
          return on.call(this, type, listener);
        },
        emit,
        updateEnv: function() {
          original = conf.original;
        }
      };
      if (get) {
        extDel = defineLength(function(arg) {
          var id, args = arguments;
          if (resolve) args = resolve(args);
          id = get(args);
          if (id === null) return;
          conf.delete(id);
        }, memLength);
      } else if (length === 0) {
        extDel = function() {
          return conf.delete("data");
        };
      } else {
        extDel = function(arg) {
          if (resolve) arg = resolve(arguments)[0];
          return conf.delete(arg);
        };
      }
      extGet = defineLength(function() {
        var id, args = arguments;
        if (length === 0) return cache.data;
        if (resolve) args = resolve(args);
        if (get) id = get(args);
        else id = String(args[0]);
        return cache[id];
      });
      extHas = defineLength(function() {
        var id, args = arguments;
        if (length === 0) return conf.has("data");
        if (resolve) args = resolve(args);
        if (get) id = get(args);
        else id = String(args[0]);
        if (id === null) return false;
        return conf.has(id);
      });
      defineProperties(memoized, {
        __memoized__: d(true),
        delete: d(extDel),
        clear: d(conf.clear),
        _get: d(extGet),
        _has: d(extHas)
      });
      return conf;
    };
  }
});

// .api/apis/zklighter/node_modules/memoizee/plain.js
var require_plain = __commonJS({
  ".api/apis/zklighter/node_modules/memoizee/plain.js"(exports, module2) {
    "use strict";
    var callable = require_valid_callable();
    var forEach = require_for_each();
    var extensions = require_registered_extensions();
    var configure = require_configure_map();
    var resolveLength = require_resolve_length();
    module2.exports = function self2(fn) {
      var options, length, conf;
      callable(fn);
      options = Object(arguments[1]);
      if (options.async && options.promise) {
        throw new Error("Options 'async' and 'promise' cannot be used together");
      }
      if (hasOwnProperty.call(fn, "__memoized__") && !options.force) return fn;
      length = resolveLength(options.length, fn.length, options.async && extensions.async);
      conf = configure(fn, length, options);
      forEach(extensions, function(extFn, name) {
        if (options[name]) extFn(options[name], conf, options);
      });
      if (self2.__profiler__) self2.__profiler__(conf);
      conf.updateEnv();
      return conf.memoized;
    };
  }
});

// .api/apis/zklighter/node_modules/memoizee/normalizers/primitive.js
var require_primitive = __commonJS({
  ".api/apis/zklighter/node_modules/memoizee/normalizers/primitive.js"(exports, module2) {
    "use strict";
    module2.exports = function(args) {
      var id, i, length = args.length;
      if (!length) return "";
      id = String(args[i = 0]);
      while (--length) id += "" + args[++i];
      return id;
    };
  }
});

// .api/apis/zklighter/node_modules/memoizee/normalizers/get-primitive-fixed.js
var require_get_primitive_fixed = __commonJS({
  ".api/apis/zklighter/node_modules/memoizee/normalizers/get-primitive-fixed.js"(exports, module2) {
    "use strict";
    module2.exports = function(length) {
      if (!length) {
        return function() {
          return "";
        };
      }
      return function(args) {
        var id = String(args[0]), i = 0, currentLength = length;
        while (--currentLength) {
          id += "" + args[++i];
        }
        return id;
      };
    };
  }
});

// .api/apis/zklighter/node_modules/es5-ext/number/is-nan/is-implemented.js
var require_is_implemented8 = __commonJS({
  ".api/apis/zklighter/node_modules/es5-ext/number/is-nan/is-implemented.js"(exports, module2) {
    "use strict";
    module2.exports = function() {
      var numberIsNaN = Number.isNaN;
      if (typeof numberIsNaN !== "function") return false;
      return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
    };
  }
});

// .api/apis/zklighter/node_modules/es5-ext/number/is-nan/shim.js
var require_shim6 = __commonJS({
  ".api/apis/zklighter/node_modules/es5-ext/number/is-nan/shim.js"(exports, module2) {
    "use strict";
    module2.exports = function(value) {
      return value !== value;
    };
  }
});

// .api/apis/zklighter/node_modules/es5-ext/number/is-nan/index.js
var require_is_nan = __commonJS({
  ".api/apis/zklighter/node_modules/es5-ext/number/is-nan/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_is_implemented8()() ? Number.isNaN : require_shim6();
  }
});

// .api/apis/zklighter/node_modules/es5-ext/array/#/e-index-of.js
var require_e_index_of = __commonJS({
  ".api/apis/zklighter/node_modules/es5-ext/array/#/e-index-of.js"(exports, module2) {
    "use strict";
    var numberIsNaN = require_is_nan();
    var toPosInt = require_to_pos_integer();
    var value = require_valid_value();
    var indexOf = Array.prototype.indexOf;
    var objHasOwnProperty = Object.prototype.hasOwnProperty;
    var abs = Math.abs;
    var floor = Math.floor;
    module2.exports = function(searchElement) {
      var i, length, fromIndex, val;
      if (!numberIsNaN(searchElement)) return indexOf.apply(this, arguments);
      length = toPosInt(value(this).length);
      fromIndex = arguments[1];
      if (isNaN(fromIndex)) fromIndex = 0;
      else if (fromIndex >= 0) fromIndex = floor(fromIndex);
      else fromIndex = toPosInt(this.length) - floor(abs(fromIndex));
      for (i = fromIndex; i < length; ++i) {
        if (objHasOwnProperty.call(this, i)) {
          val = this[i];
          if (numberIsNaN(val)) return i;
        }
      }
      return -1;
    };
  }
});

// .api/apis/zklighter/node_modules/memoizee/normalizers/get.js
var require_get2 = __commonJS({
  ".api/apis/zklighter/node_modules/memoizee/normalizers/get.js"(exports, module2) {
    "use strict";
    var indexOf = require_e_index_of();
    var create = Object.create;
    module2.exports = function() {
      var lastId = 0, map = [], cache = create(null);
      return {
        get: function(args) {
          var index = 0, set = map, i, length = args.length;
          if (length === 0) return set[length] || null;
          if (set = set[length]) {
            while (index < length - 1) {
              i = indexOf.call(set[0], args[index]);
              if (i === -1) return null;
              set = set[1][i];
              ++index;
            }
            i = indexOf.call(set[0], args[index]);
            if (i === -1) return null;
            return set[1][i] || null;
          }
          return null;
        },
        set: function(args) {
          var index = 0, set = map, i, length = args.length;
          if (length === 0) {
            set[length] = ++lastId;
          } else {
            if (!set[length]) {
              set[length] = [[], []];
            }
            set = set[length];
            while (index < length - 1) {
              i = indexOf.call(set[0], args[index]);
              if (i === -1) {
                i = set[0].push(args[index]) - 1;
                set[1].push([[], []]);
              }
              set = set[1][i];
              ++index;
            }
            i = indexOf.call(set[0], args[index]);
            if (i === -1) {
              i = set[0].push(args[index]) - 1;
            }
            set[1][i] = ++lastId;
          }
          cache[lastId] = args;
          return lastId;
        },
        delete: function(id) {
          var index = 0, set = map, i, args = cache[id], length = args.length, path = [];
          if (length === 0) {
            delete set[length];
          } else if (set = set[length]) {
            while (index < length - 1) {
              i = indexOf.call(set[0], args[index]);
              if (i === -1) {
                return;
              }
              path.push(set, i);
              set = set[1][i];
              ++index;
            }
            i = indexOf.call(set[0], args[index]);
            if (i === -1) {
              return;
            }
            id = set[1][i];
            set[0].splice(i, 1);
            set[1].splice(i, 1);
            while (!set[0].length && path.length) {
              i = path.pop();
              set = path.pop();
              set[0].splice(i, 1);
              set[1].splice(i, 1);
            }
          }
          delete cache[id];
        },
        clear: function() {
          map = [];
          cache = create(null);
        }
      };
    };
  }
});

// .api/apis/zklighter/node_modules/memoizee/normalizers/get-1.js
var require_get_1 = __commonJS({
  ".api/apis/zklighter/node_modules/memoizee/normalizers/get-1.js"(exports, module2) {
    "use strict";
    var indexOf = require_e_index_of();
    module2.exports = function() {
      var lastId = 0, argsMap = [], cache = [];
      return {
        get: function(args) {
          var index = indexOf.call(argsMap, args[0]);
          return index === -1 ? null : cache[index];
        },
        set: function(args) {
          argsMap.push(args[0]);
          cache.push(++lastId);
          return lastId;
        },
        delete: function(id) {
          var index = indexOf.call(cache, id);
          if (index !== -1) {
            argsMap.splice(index, 1);
            cache.splice(index, 1);
          }
        },
        clear: function() {
          argsMap = [];
          cache = [];
        }
      };
    };
  }
});

// .api/apis/zklighter/node_modules/memoizee/normalizers/get-fixed.js
var require_get_fixed = __commonJS({
  ".api/apis/zklighter/node_modules/memoizee/normalizers/get-fixed.js"(exports, module2) {
    "use strict";
    var indexOf = require_e_index_of();
    var create = Object.create;
    module2.exports = function(length) {
      var lastId = 0, map = [[], []], cache = create(null);
      return {
        get: function(args) {
          var index = 0, set = map, i;
          while (index < length - 1) {
            i = indexOf.call(set[0], args[index]);
            if (i === -1) return null;
            set = set[1][i];
            ++index;
          }
          i = indexOf.call(set[0], args[index]);
          if (i === -1) return null;
          return set[1][i] || null;
        },
        set: function(args) {
          var index = 0, set = map, i;
          while (index < length - 1) {
            i = indexOf.call(set[0], args[index]);
            if (i === -1) {
              i = set[0].push(args[index]) - 1;
              set[1].push([[], []]);
            }
            set = set[1][i];
            ++index;
          }
          i = indexOf.call(set[0], args[index]);
          if (i === -1) {
            i = set[0].push(args[index]) - 1;
          }
          set[1][i] = ++lastId;
          cache[lastId] = args;
          return lastId;
        },
        delete: function(id) {
          var index = 0, set = map, i, path = [], args = cache[id];
          while (index < length - 1) {
            i = indexOf.call(set[0], args[index]);
            if (i === -1) {
              return;
            }
            path.push(set, i);
            set = set[1][i];
            ++index;
          }
          i = indexOf.call(set[0], args[index]);
          if (i === -1) {
            return;
          }
          id = set[1][i];
          set[0].splice(i, 1);
          set[1].splice(i, 1);
          while (!set[0].length && path.length) {
            i = path.pop();
            set = path.pop();
            set[0].splice(i, 1);
            set[1].splice(i, 1);
          }
          delete cache[id];
        },
        clear: function() {
          map = [[], []];
          cache = create(null);
        }
      };
    };
  }
});

// .api/apis/zklighter/node_modules/es5-ext/object/map.js
var require_map2 = __commonJS({
  ".api/apis/zklighter/node_modules/es5-ext/object/map.js"(exports, module2) {
    "use strict";
    var callable = require_valid_callable();
    var forEach = require_for_each();
    var call = Function.prototype.call;
    module2.exports = function(obj, cb) {
      var result = {}, thisArg = arguments[2];
      callable(cb);
      forEach(obj, function(value, key, targetObj, index) {
        result[key] = call.call(cb, thisArg, value, key, targetObj, index);
      });
      return result;
    };
  }
});

// .api/apis/zklighter/node_modules/next-tick/index.js
var require_next_tick = __commonJS({
  ".api/apis/zklighter/node_modules/next-tick/index.js"(exports, module2) {
    "use strict";
    var ensureCallable = function(fn) {
      if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
      return fn;
    };
    var byObserver = function(Observer) {
      var node = document.createTextNode(""), queue, currentQueue, i = 0;
      new Observer(function() {
        var callback;
        if (!queue) {
          if (!currentQueue) return;
          queue = currentQueue;
        } else if (currentQueue) {
          queue = currentQueue.concat(queue);
        }
        currentQueue = queue;
        queue = null;
        if (typeof currentQueue === "function") {
          callback = currentQueue;
          currentQueue = null;
          callback();
          return;
        }
        node.data = i = ++i % 2;
        while (currentQueue) {
          callback = currentQueue.shift();
          if (!currentQueue.length) currentQueue = null;
          callback();
        }
      }).observe(node, { characterData: true });
      return function(fn) {
        ensureCallable(fn);
        if (queue) {
          if (typeof queue === "function") queue = [queue, fn];
          else queue.push(fn);
          return;
        }
        queue = fn;
        node.data = i = ++i % 2;
      };
    };
    module2.exports = function() {
      if (typeof process === "object" && process && typeof process.nextTick === "function") {
        return process.nextTick;
      }
      if (typeof queueMicrotask === "function") {
        return function(cb) {
          queueMicrotask(ensureCallable(cb));
        };
      }
      if (typeof document === "object" && document) {
        if (typeof MutationObserver === "function") return byObserver(MutationObserver);
        if (typeof WebKitMutationObserver === "function") return byObserver(WebKitMutationObserver);
      }
      if (typeof setImmediate === "function") {
        return function(cb) {
          setImmediate(ensureCallable(cb));
        };
      }
      if (typeof setTimeout === "function" || typeof setTimeout === "object") {
        return function(cb) {
          setTimeout(ensureCallable(cb), 0);
        };
      }
      return null;
    }();
  }
});

// .api/apis/zklighter/node_modules/memoizee/ext/async.js
var require_async = __commonJS({
  ".api/apis/zklighter/node_modules/memoizee/ext/async.js"() {
    "use strict";
    var aFrom = require_from();
    var objectMap = require_map2();
    var mixin = require_mixin();
    var defineLength = require_define_length();
    var nextTick = require_next_tick();
    var slice = Array.prototype.slice;
    var apply = Function.prototype.apply;
    var create = Object.create;
    require_registered_extensions().async = function(tbi, conf) {
      var waiting = create(null), cache = create(null), base = conf.memoized, original = conf.original, currentCallback, currentContext, currentArgs;
      conf.memoized = defineLength(function(arg) {
        var args = arguments, last = args[args.length - 1];
        if (typeof last === "function") {
          currentCallback = last;
          args = slice.call(args, 0, -1);
        }
        return base.apply(currentContext = this, currentArgs = args);
      }, base);
      try {
        mixin(conf.memoized, base);
      } catch (ignore) {
      }
      conf.on("get", function(id) {
        var cb, context, args;
        if (!currentCallback) return;
        if (waiting[id]) {
          if (typeof waiting[id] === "function") waiting[id] = [waiting[id], currentCallback];
          else waiting[id].push(currentCallback);
          currentCallback = null;
          return;
        }
        cb = currentCallback;
        context = currentContext;
        args = currentArgs;
        currentCallback = currentContext = currentArgs = null;
        nextTick(function() {
          var data;
          if (hasOwnProperty.call(cache, id)) {
            data = cache[id];
            conf.emit("getasync", id, args, context);
            apply.call(cb, data.context, data.args);
          } else {
            currentCallback = cb;
            currentContext = context;
            currentArgs = args;
            base.apply(context, args);
          }
        });
      });
      conf.original = function() {
        var args, cb, origCb, result;
        if (!currentCallback) return apply.call(original, this, arguments);
        args = aFrom(arguments);
        cb = function self2(err) {
          var cb2, args2, id = self2.id;
          if (id == null) {
            nextTick(apply.bind(self2, this, arguments));
            return void 0;
          }
          delete self2.id;
          cb2 = waiting[id];
          delete waiting[id];
          if (!cb2) {
            return void 0;
          }
          args2 = aFrom(arguments);
          if (conf.has(id)) {
            if (err) {
              conf.delete(id);
            } else {
              cache[id] = { context: this, args: args2 };
              conf.emit("setasync", id, typeof cb2 === "function" ? 1 : cb2.length);
            }
          }
          if (typeof cb2 === "function") {
            result = apply.call(cb2, this, args2);
          } else {
            cb2.forEach(function(cb3) {
              result = apply.call(cb3, this, args2);
            }, this);
          }
          return result;
        };
        origCb = currentCallback;
        currentCallback = currentContext = currentArgs = null;
        args.push(cb);
        result = apply.call(original, this, args);
        cb.cb = origCb;
        currentCallback = cb;
        return result;
      };
      conf.on("set", function(id) {
        if (!currentCallback) {
          conf.delete(id);
          return;
        }
        if (waiting[id]) {
          if (typeof waiting[id] === "function") waiting[id] = [waiting[id], currentCallback.cb];
          else waiting[id].push(currentCallback.cb);
        } else {
          waiting[id] = currentCallback.cb;
        }
        delete currentCallback.cb;
        currentCallback.id = id;
        currentCallback = null;
      });
      conf.on("delete", function(id) {
        var result;
        if (hasOwnProperty.call(waiting, id)) return;
        if (!cache[id]) return;
        result = cache[id];
        delete cache[id];
        conf.emit("deleteasync", id, slice.call(result.args, 1));
      });
      conf.on("clear", function() {
        var oldCache = cache;
        cache = create(null);
        conf.emit(
          "clearasync",
          objectMap(oldCache, function(data) {
            return slice.call(data.args, 1);
          })
        );
      });
    };
  }
});

// .api/apis/zklighter/node_modules/es5-ext/object/primitive-set.js
var require_primitive_set = __commonJS({
  ".api/apis/zklighter/node_modules/es5-ext/object/primitive-set.js"(exports, module2) {
    "use strict";
    var forEach = Array.prototype.forEach;
    var create = Object.create;
    module2.exports = function(arg) {
      var set = create(null);
      forEach.call(arguments, function(name) {
        set[name] = true;
      });
      return set;
    };
  }
});

// .api/apis/zklighter/node_modules/es5-ext/object/is-callable.js
var require_is_callable = __commonJS({
  ".api/apis/zklighter/node_modules/es5-ext/object/is-callable.js"(exports, module2) {
    "use strict";
    module2.exports = function(obj) {
      return typeof obj === "function";
    };
  }
});

// .api/apis/zklighter/node_modules/es5-ext/object/validate-stringifiable.js
var require_validate_stringifiable = __commonJS({
  ".api/apis/zklighter/node_modules/es5-ext/object/validate-stringifiable.js"(exports, module2) {
    "use strict";
    var isCallable = require_is_callable();
    module2.exports = function(stringifiable) {
      try {
        if (stringifiable && isCallable(stringifiable.toString)) return stringifiable.toString();
        return String(stringifiable);
      } catch (e) {
        throw new TypeError("Passed argument cannot be stringifed");
      }
    };
  }
});

// .api/apis/zklighter/node_modules/es5-ext/object/validate-stringifiable-value.js
var require_validate_stringifiable_value = __commonJS({
  ".api/apis/zklighter/node_modules/es5-ext/object/validate-stringifiable-value.js"(exports, module2) {
    "use strict";
    var ensureValue = require_valid_value();
    var stringifiable = require_validate_stringifiable();
    module2.exports = function(value) {
      return stringifiable(ensureValue(value));
    };
  }
});

// .api/apis/zklighter/node_modules/es5-ext/safe-to-string.js
var require_safe_to_string = __commonJS({
  ".api/apis/zklighter/node_modules/es5-ext/safe-to-string.js"(exports, module2) {
    "use strict";
    var isCallable = require_is_callable();
    module2.exports = function(value) {
      try {
        if (value && isCallable(value.toString)) return value.toString();
        return String(value);
      } catch (e) {
        return "<Non-coercible to string value>";
      }
    };
  }
});

// .api/apis/zklighter/node_modules/es5-ext/to-short-string-representation.js
var require_to_short_string_representation = __commonJS({
  ".api/apis/zklighter/node_modules/es5-ext/to-short-string-representation.js"(exports, module2) {
    "use strict";
    var safeToString = require_safe_to_string();
    var reNewLine = /[\n\r\u2028\u2029]/g;
    module2.exports = function(value) {
      var string = safeToString(value);
      if (string.length > 100) string = string.slice(0, 99) + "";
      string = string.replace(reNewLine, function(char) {
        return JSON.stringify(char).slice(1, -1);
      });
      return string;
    };
  }
});

// .api/apis/zklighter/node_modules/is-promise/index.js
var require_is_promise = __commonJS({
  ".api/apis/zklighter/node_modules/is-promise/index.js"(exports, module2) {
    module2.exports = isPromise;
    module2.exports.default = isPromise;
    function isPromise(obj) {
      return !!obj && (typeof obj === "object" || typeof obj === "function") && typeof obj.then === "function";
    }
  }
});

// .api/apis/zklighter/node_modules/memoizee/ext/promise.js
var require_promise = __commonJS({
  ".api/apis/zklighter/node_modules/memoizee/ext/promise.js"() {
    "use strict";
    var objectMap = require_map2();
    var primitiveSet = require_primitive_set();
    var ensureString = require_validate_stringifiable_value();
    var toShortString = require_to_short_string_representation();
    var isPromise = require_is_promise();
    var nextTick = require_next_tick();
    var create = Object.create;
    var supportedModes = primitiveSet("then", "then:finally", "done", "done:finally");
    require_registered_extensions().promise = function(mode, conf) {
      var waiting = create(null), cache = create(null), promises = create(null);
      if (mode === true) {
        mode = null;
      } else {
        mode = ensureString(mode);
        if (!supportedModes[mode]) {
          throw new TypeError("'" + toShortString(mode) + "' is not valid promise mode");
        }
      }
      conf.on("set", function(id, ignore, promise) {
        var isFailed = false;
        if (!isPromise(promise)) {
          cache[id] = promise;
          conf.emit("setasync", id, 1);
          return;
        }
        waiting[id] = 1;
        promises[id] = promise;
        var onSuccess = function(result) {
          var count = waiting[id];
          if (isFailed) {
            throw new Error(
              "Memoizee error: Detected unordered then|done & finally resolution, which in turn makes proper detection of success/failure impossible (when in 'done:finally' mode)\nConsider to rely on 'then' or 'done' mode instead."
            );
          }
          if (!count) return;
          delete waiting[id];
          cache[id] = result;
          conf.emit("setasync", id, count);
        };
        var onFailure = function() {
          isFailed = true;
          if (!waiting[id]) return;
          delete waiting[id];
          delete promises[id];
          conf.delete(id);
        };
        var resolvedMode = mode;
        if (!resolvedMode) resolvedMode = "then";
        if (resolvedMode === "then") {
          var nextTickFailure = function() {
            nextTick(onFailure);
          };
          promise = promise.then(function(result) {
            nextTick(onSuccess.bind(this, result));
          }, nextTickFailure);
          if (typeof promise.finally === "function") {
            promise.finally(nextTickFailure);
          }
        } else if (resolvedMode === "done") {
          if (typeof promise.done !== "function") {
            throw new Error(
              "Memoizee error: Retrieved promise does not implement 'done' in 'done' mode"
            );
          }
          promise.done(onSuccess, onFailure);
        } else if (resolvedMode === "done:finally") {
          if (typeof promise.done !== "function") {
            throw new Error(
              "Memoizee error: Retrieved promise does not implement 'done' in 'done:finally' mode"
            );
          }
          if (typeof promise.finally !== "function") {
            throw new Error(
              "Memoizee error: Retrieved promise does not implement 'finally' in 'done:finally' mode"
            );
          }
          promise.done(onSuccess);
          promise.finally(onFailure);
        }
      });
      conf.on("get", function(id, args, context) {
        var promise;
        if (waiting[id]) {
          ++waiting[id];
          return;
        }
        promise = promises[id];
        var emit = function() {
          conf.emit("getasync", id, args, context);
        };
        if (isPromise(promise)) {
          if (typeof promise.done === "function") promise.done(emit);
          else {
            promise.then(function() {
              nextTick(emit);
            });
          }
        } else {
          emit();
        }
      });
      conf.on("delete", function(id) {
        delete promises[id];
        if (waiting[id]) {
          delete waiting[id];
          return;
        }
        if (!hasOwnProperty.call(cache, id)) return;
        var result = cache[id];
        delete cache[id];
        conf.emit("deleteasync", id, [result]);
      });
      conf.on("clear", function() {
        var oldCache = cache;
        cache = create(null);
        waiting = create(null);
        promises = create(null);
        conf.emit("clearasync", objectMap(oldCache, function(data) {
          return [data];
        }));
      });
    };
  }
});

// .api/apis/zklighter/node_modules/memoizee/ext/dispose.js
var require_dispose = __commonJS({
  ".api/apis/zklighter/node_modules/memoizee/ext/dispose.js"() {
    "use strict";
    var callable = require_valid_callable();
    var forEach = require_for_each();
    var extensions = require_registered_extensions();
    var apply = Function.prototype.apply;
    extensions.dispose = function(dispose, conf, options) {
      var del;
      callable(dispose);
      if (options.async && extensions.async || options.promise && extensions.promise) {
        conf.on(
          "deleteasync",
          del = function(id, resultArray) {
            apply.call(dispose, null, resultArray);
          }
        );
        conf.on("clearasync", function(cache) {
          forEach(cache, function(result, id) {
            del(id, result);
          });
        });
        return;
      }
      conf.on("delete", del = function(id, result) {
        dispose(result);
      });
      conf.on("clear", function(cache) {
        forEach(cache, function(result, id) {
          del(id, result);
        });
      });
    };
  }
});

// .api/apis/zklighter/node_modules/timers-ext/max-timeout.js
var require_max_timeout = __commonJS({
  ".api/apis/zklighter/node_modules/timers-ext/max-timeout.js"(exports, module2) {
    "use strict";
    module2.exports = 2147483647;
  }
});

// .api/apis/zklighter/node_modules/timers-ext/valid-timeout.js
var require_valid_timeout = __commonJS({
  ".api/apis/zklighter/node_modules/timers-ext/valid-timeout.js"(exports, module2) {
    "use strict";
    var toPosInt = require_to_pos_integer();
    var maxTimeout = require_max_timeout();
    module2.exports = function(value) {
      value = toPosInt(value);
      if (value > maxTimeout) throw new TypeError(value + " exceeds maximum possible timeout");
      return value;
    };
  }
});

// .api/apis/zklighter/node_modules/memoizee/ext/max-age.js
var require_max_age = __commonJS({
  ".api/apis/zklighter/node_modules/memoizee/ext/max-age.js"() {
    "use strict";
    var aFrom = require_from();
    var forEach = require_for_each();
    var nextTick = require_next_tick();
    var isPromise = require_is_promise();
    var timeout = require_valid_timeout();
    var extensions = require_registered_extensions();
    var noop = Function.prototype;
    var max = Math.max;
    var min = Math.min;
    var create = Object.create;
    extensions.maxAge = function(maxAge, conf, options) {
      var timeouts, postfix, preFetchAge, preFetchTimeouts;
      maxAge = timeout(maxAge);
      if (!maxAge) return;
      timeouts = create(null);
      postfix = options.async && extensions.async || options.promise && extensions.promise ? "async" : "";
      conf.on("set" + postfix, function(id) {
        timeouts[id] = setTimeout(function() {
          conf.delete(id);
        }, maxAge);
        if (typeof timeouts[id].unref === "function") timeouts[id].unref();
        if (!preFetchTimeouts) return;
        if (preFetchTimeouts[id]) {
          if (preFetchTimeouts[id] !== "nextTick") clearTimeout(preFetchTimeouts[id]);
        }
        preFetchTimeouts[id] = setTimeout(function() {
          delete preFetchTimeouts[id];
        }, preFetchAge);
        if (typeof preFetchTimeouts[id].unref === "function") preFetchTimeouts[id].unref();
      });
      conf.on("delete" + postfix, function(id) {
        clearTimeout(timeouts[id]);
        delete timeouts[id];
        if (!preFetchTimeouts) return;
        if (preFetchTimeouts[id] !== "nextTick") clearTimeout(preFetchTimeouts[id]);
        delete preFetchTimeouts[id];
      });
      if (options.preFetch) {
        if (options.preFetch === true || isNaN(options.preFetch)) {
          preFetchAge = 0.333;
        } else {
          preFetchAge = max(min(Number(options.preFetch), 1), 0);
        }
        if (preFetchAge) {
          preFetchTimeouts = {};
          preFetchAge = (1 - preFetchAge) * maxAge;
          conf.on("get" + postfix, function(id, args, context) {
            if (!preFetchTimeouts[id]) {
              preFetchTimeouts[id] = "nextTick";
              nextTick(function() {
                var result;
                if (preFetchTimeouts[id] !== "nextTick") return;
                delete preFetchTimeouts[id];
                conf.delete(id);
                if (options.async) {
                  args = aFrom(args);
                  args.push(noop);
                }
                result = conf.memoized.apply(context, args);
                if (options.promise) {
                  if (isPromise(result)) {
                    if (typeof result.done === "function") result.done(noop, noop);
                    else result.then(noop, noop);
                  }
                }
              });
            }
          });
        }
      }
      conf.on("clear" + postfix, function() {
        forEach(timeouts, function(id) {
          clearTimeout(id);
        });
        timeouts = {};
        if (preFetchTimeouts) {
          forEach(preFetchTimeouts, function(id) {
            if (id !== "nextTick") clearTimeout(id);
          });
          preFetchTimeouts = {};
        }
      });
    };
  }
});

// .api/apis/zklighter/node_modules/lru-queue/index.js
var require_lru_queue = __commonJS({
  ".api/apis/zklighter/node_modules/lru-queue/index.js"(exports, module2) {
    "use strict";
    var toPosInt = require_to_pos_integer();
    var create = Object.create;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    module2.exports = function(limit) {
      var size = 0, base = 1, queue = create(null), map = create(null), index = 0, del;
      limit = toPosInt(limit);
      return {
        hit: function(id) {
          var oldIndex = map[id], nuIndex = ++index;
          queue[nuIndex] = id;
          map[id] = nuIndex;
          if (!oldIndex) {
            ++size;
            if (size <= limit) return;
            id = queue[base];
            del(id);
            return id;
          }
          delete queue[oldIndex];
          if (base !== oldIndex) return;
          while (!hasOwnProperty2.call(queue, ++base)) continue;
        },
        delete: del = function(id) {
          var oldIndex = map[id];
          if (!oldIndex) return;
          delete queue[oldIndex];
          delete map[id];
          --size;
          if (base !== oldIndex) return;
          if (!size) {
            index = 0;
            base = 1;
            return;
          }
          while (!hasOwnProperty2.call(queue, ++base)) continue;
        },
        clear: function() {
          size = 0;
          base = 1;
          queue = create(null);
          map = create(null);
          index = 0;
        }
      };
    };
  }
});

// .api/apis/zklighter/node_modules/memoizee/ext/max.js
var require_max = __commonJS({
  ".api/apis/zklighter/node_modules/memoizee/ext/max.js"() {
    "use strict";
    var toPosInteger = require_to_pos_integer();
    var lruQueue = require_lru_queue();
    var extensions = require_registered_extensions();
    extensions.max = function(max, conf, options) {
      var postfix, queue, hit;
      max = toPosInteger(max);
      if (!max) return;
      queue = lruQueue(max);
      postfix = options.async && extensions.async || options.promise && extensions.promise ? "async" : "";
      conf.on(
        "set" + postfix,
        hit = function(id) {
          id = queue.hit(id);
          if (id === void 0) return;
          conf.delete(id);
        }
      );
      conf.on("get" + postfix, hit);
      conf.on("delete" + postfix, queue.delete);
      conf.on("clear" + postfix, queue.clear);
    };
  }
});

// .api/apis/zklighter/node_modules/memoizee/ext/ref-counter.js
var require_ref_counter = __commonJS({
  ".api/apis/zklighter/node_modules/memoizee/ext/ref-counter.js"() {
    "use strict";
    var d = require_d();
    var extensions = require_registered_extensions();
    var create = Object.create;
    var defineProperties = Object.defineProperties;
    extensions.refCounter = function(ignore, conf, options) {
      var cache, postfix;
      cache = create(null);
      postfix = options.async && extensions.async || options.promise && extensions.promise ? "async" : "";
      conf.on("set" + postfix, function(id, length) {
        cache[id] = length || 1;
      });
      conf.on("get" + postfix, function(id) {
        ++cache[id];
      });
      conf.on("delete" + postfix, function(id) {
        delete cache[id];
      });
      conf.on("clear" + postfix, function() {
        cache = {};
      });
      defineProperties(conf.memoized, {
        deleteRef: d(function() {
          var id = conf.get(arguments);
          if (id === null) return null;
          if (!cache[id]) return null;
          if (!--cache[id]) {
            conf.delete(id);
            return true;
          }
          return false;
        }),
        getRefCount: d(function() {
          var id = conf.get(arguments);
          if (id === null) return 0;
          if (!cache[id]) return 0;
          return cache[id];
        })
      });
    };
  }
});

// .api/apis/zklighter/node_modules/memoizee/index.js
var require_memoizee = __commonJS({
  ".api/apis/zklighter/node_modules/memoizee/index.js"(exports, module2) {
    "use strict";
    var normalizeOpts = require_normalize_options();
    var resolveLength = require_resolve_length();
    var plain = require_plain();
    module2.exports = function(fn) {
      var options = normalizeOpts(arguments[1]), length;
      if (!options.normalizer) {
        length = options.length = resolveLength(options.length, fn.length, options.async);
        if (length !== 0) {
          if (options.primitive) {
            if (length === false) {
              options.normalizer = require_primitive();
            } else if (length > 1) {
              options.normalizer = require_get_primitive_fixed()(length);
            }
          } else if (length === false) options.normalizer = require_get2()();
          else if (length === 1) options.normalizer = require_get_1()();
          else options.normalizer = require_get_fixed()(length);
        }
      }
      if (options.async) require_async();
      if (options.promise) require_promise();
      if (options.dispose) require_dispose();
      if (options.maxAge) require_max_age();
      if (options.max) require_max();
      if (options.refCounter) require_ref_counter();
      return plain(fn, options);
    };
  }
});

// .api/apis/zklighter/node_modules/oas/dist/samples/utils.js
var require_utils = __commonJS({
  ".api/apis/zklighter/node_modules/oas/dist/samples/utils.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    exports.__esModule = true;
    exports.deeplyStripKey = exports.isFunc = exports.normalizeArray = exports.objectify = exports.usesPolymorphism = void 0;
    function isObject(obj) {
      return !!obj && typeof obj === "object";
    }
    function usesPolymorphism(schema) {
      if (schema.oneOf) {
        return "oneOf";
      } else if (schema.anyOf) {
        return "anyOf";
      } else if (schema.allOf) {
        return "allOf";
      }
      return false;
    }
    exports.usesPolymorphism = usesPolymorphism;
    function objectify(thing) {
      if (!isObject(thing)) {
        return {};
      }
      return thing;
    }
    exports.objectify = objectify;
    function normalizeArray(arr) {
      if (Array.isArray(arr)) {
        return arr;
      }
      return [arr];
    }
    exports.normalizeArray = normalizeArray;
    function isFunc(thing) {
      return typeof thing === "function";
    }
    exports.isFunc = isFunc;
    function deeplyStripKey(input, keyToStrip, predicate) {
      if (predicate === void 0) {
        predicate = function(obj2, key) {
          return true;
        };
      }
      if (typeof input !== "object" || Array.isArray(input) || input === null || !keyToStrip) {
        return input;
      }
      var obj = __assign({}, input);
      Object.keys(obj).forEach(function(k) {
        if (k === keyToStrip && predicate(obj[k], k)) {
          delete obj[k];
          return;
        }
        obj[k] = deeplyStripKey(obj[k], keyToStrip, predicate);
      });
      return obj;
    }
    exports.deeplyStripKey = deeplyStripKey;
  }
});

// .api/apis/zklighter/node_modules/oas/dist/samples/index.js
var require_samples = __commonJS({
  ".api/apis/zklighter/node_modules/oas/dist/samples/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    exports.__esModule = true;
    var json_schema_merge_allof_1 = __importDefault(require_src2());
    var memoizee_1 = __importDefault(require_memoizee());
    var utils_1 = require_utils();
    var sampleDefaults = function(genericSample) {
      return function(schema) {
        return typeof schema["default"] === typeof genericSample ? schema["default"] : genericSample;
      };
    };
    var primitives = {
      string: sampleDefaults("string"),
      string_email: sampleDefaults("user@example.com"),
      "string_date-time": sampleDefaults((/* @__PURE__ */ new Date()).toISOString()),
      string_date: sampleDefaults((/* @__PURE__ */ new Date()).toISOString().substring(0, 10)),
      "string_YYYY-MM-DD": sampleDefaults((/* @__PURE__ */ new Date()).toISOString().substring(0, 10)),
      string_uuid: sampleDefaults("3fa85f64-5717-4562-b3fc-2c963f66afa6"),
      string_hostname: sampleDefaults("example.com"),
      string_ipv4: sampleDefaults("198.51.100.42"),
      string_ipv6: sampleDefaults("2001:0db8:5b96:0000:0000:426f:8e17:642a"),
      number: sampleDefaults(0),
      number_float: sampleDefaults(0),
      integer: sampleDefaults(0),
      boolean: sampleDefaults(true)
    };
    var primitive = function(schema) {
      schema = (0, utils_1.objectify)(schema);
      var type = schema.type, format2 = schema.format;
      var fn = primitives["".concat(type, "_").concat(format2)] || primitives[type];
      if ((0, utils_1.isFunc)(fn)) {
        return fn(schema);
      }
      return "Unknown Type: ".concat(schema.type);
    };
    function sampleFromSchema(schema, opts) {
      if (opts === void 0) {
        opts = {};
      }
      var objectifySchema = (0, utils_1.objectify)(schema);
      var type = objectifySchema.type;
      var hasPolymorphism = (0, utils_1.usesPolymorphism)(objectifySchema);
      if (hasPolymorphism === "allOf") {
        try {
          return sampleFromSchema((0, json_schema_merge_allof_1["default"])(objectifySchema, {
            resolvers: {
              // Ignore any unrecognized OAS-specific keywords that might be present on the schema
              // (like `xml`).
              defaultResolver: json_schema_merge_allof_1["default"].options.resolvers.title
            }
          }), opts);
        } catch (error) {
          return void 0;
        }
      } else if (hasPolymorphism) {
        return sampleFromSchema(objectifySchema[hasPolymorphism][0], opts);
      }
      var example = objectifySchema.example, additionalProperties = objectifySchema.additionalProperties, properties = objectifySchema.properties, items = objectifySchema.items;
      var includeReadOnly = opts.includeReadOnly, includeWriteOnly = opts.includeWriteOnly;
      if (example !== void 0) {
        return (0, utils_1.deeplyStripKey)(example, "$$ref", function(val) {
          return typeof val === "string" && val.indexOf("#") > -1;
        });
      }
      if (!type) {
        if (properties || additionalProperties) {
          type = "object";
        } else if (items) {
          type = "array";
        } else {
          return void 0;
        }
      }
      if (type === "object") {
        var props = (0, utils_1.objectify)(properties);
        var obj = {};
        for (var name_1 in props) {
          if (props[name_1] && props[name_1].deprecated) {
            continue;
          }
          if (props[name_1] && props[name_1].readOnly && !includeReadOnly) {
            continue;
          }
          if (props[name_1] && props[name_1].writeOnly && !includeWriteOnly) {
            continue;
          }
          obj[name_1] = sampleFromSchema(props[name_1], opts);
        }
        if (additionalProperties === true) {
          obj.additionalProp = {};
        } else if (additionalProperties) {
          var additionalProps = (0, utils_1.objectify)(additionalProperties);
          var additionalPropVal = sampleFromSchema(additionalProps, opts);
          obj.additionalProp = additionalPropVal;
        }
        return obj;
      }
      if (type === "array") {
        if (typeof items === "undefined") {
          return [];
        }
        if (Array.isArray(items.anyOf)) {
          return items.anyOf.map(function(i) {
            return sampleFromSchema(i, opts);
          });
        }
        if (Array.isArray(items.oneOf)) {
          return items.oneOf.map(function(i) {
            return sampleFromSchema(i, opts);
          });
        }
        return [sampleFromSchema(items, opts)];
      }
      if (schema["enum"]) {
        if (schema["default"]) {
          return schema["default"];
        }
        return (0, utils_1.normalizeArray)(schema["enum"])[0];
      }
      if (type === "file") {
        return void 0;
      }
      return primitive(schema);
    }
    exports["default"] = (0, memoizee_1["default"])(sampleFromSchema);
  }
});

// .api/apis/zklighter/node_modules/oas/dist/lib/get-mediatype-examples.js
var require_get_mediatype_examples = __commonJS({
  ".api/apis/zklighter/node_modules/oas/dist/lib/get-mediatype-examples.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    exports.__esModule = true;
    var samples_1 = __importDefault(require_samples());
    var matches_mimetype_1 = __importDefault(require_matches_mimetype());
    function getMediaTypeExamples(mediaType, mediaTypeObject, opts) {
      if (opts === void 0) {
        opts = {};
      }
      if (mediaTypeObject.example) {
        return [
          {
            value: mediaTypeObject.example
          }
        ];
      } else if (mediaTypeObject.examples) {
        var examples_1 = mediaTypeObject.examples;
        var multipleExamples = Object.keys(examples_1).map(function(key) {
          var summary = key;
          var description;
          var example = examples_1[key];
          if (example !== null && typeof example === "object") {
            if ("summary" in example) {
              summary = example.summary;
            }
            if ("description" in example) {
              description = example.description;
            }
            if ("value" in example) {
              if (example.value !== null && typeof example.value === "object" && "$ref" in example.value) {
                return false;
              }
              example = example.value;
            }
          }
          var ret = { summary, title: key, value: example };
          if (description) {
            ret.description = description;
          }
          return ret;
        }).filter(Boolean);
        if (multipleExamples.length) {
          return multipleExamples;
        }
      }
      if (mediaTypeObject.schema) {
        if (!matches_mimetype_1["default"].xml(mediaType)) {
          return [
            {
              value: (0, samples_1["default"])(JSON.parse(JSON.stringify(mediaTypeObject.schema)), opts)
            }
          ];
        }
      }
      return [];
    }
    exports["default"] = getMediaTypeExamples;
  }
});

// .api/apis/zklighter/node_modules/oas/dist/operation/get-response-examples.js
var require_get_response_examples = __commonJS({
  ".api/apis/zklighter/node_modules/oas/dist/operation/get-response-examples.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    exports.__esModule = true;
    var get_mediatype_examples_1 = __importDefault(require_get_mediatype_examples());
    var rmoas_types_1 = require_rmoas_types();
    function getResponseExamples(operation) {
      return Object.keys(operation.responses || {}).map(function(status) {
        var response = operation.responses[status];
        var onlyHeaders = false;
        if ((0, rmoas_types_1.isRef)(response)) {
          return false;
        }
        var mediaTypes = {};
        (response.content ? Object.keys(response.content) : []).forEach(function(mediaType) {
          if (!mediaType)
            return;
          var mediaTypeObject = response.content[mediaType];
          var examples = (0, get_mediatype_examples_1["default"])(mediaType, mediaTypeObject, {
            includeReadOnly: true,
            includeWriteOnly: false
          });
          if (examples) {
            mediaTypes[mediaType] = examples;
          }
        });
        if (response.headers && Object.keys(response.headers).length && !Object.keys(mediaTypes).length) {
          mediaTypes["*/*"] = [];
          onlyHeaders = true;
        }
        if (!Object.keys(mediaTypes).length) {
          return false;
        }
        return __assign({ status, mediaTypes }, onlyHeaders ? { onlyHeaders } : {});
      }).filter(Boolean);
    }
    exports["default"] = getResponseExamples;
  }
});

// .api/apis/zklighter/node_modules/oas/dist/operation/get-callback-examples.js
var require_get_callback_examples = __commonJS({
  ".api/apis/zklighter/node_modules/oas/dist/operation/get-callback-examples.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    exports.__esModule = true;
    var get_response_examples_1 = __importDefault(require_get_response_examples());
    function getCallbackExamples(operation) {
      var ret = [];
      return ret.concat.apply(ret, Object.keys(operation.callbacks || {}).map(function(identifier) {
        var callback = operation.callbacks[identifier];
        return [].concat.apply([], Object.keys(callback).map(function(expression) {
          return Object.keys(callback[expression]).map(function(method) {
            var pathItem = callback[expression];
            var example = (0, get_response_examples_1["default"])(pathItem[method]);
            if (example.length === 0)
              return false;
            return {
              identifier,
              expression,
              method,
              example
            };
          });
        })).filter(Boolean);
      }));
    }
    exports["default"] = getCallbackExamples;
  }
});

// .api/apis/zklighter/node_modules/oas/dist/lib/clone-object.js
var require_clone_object = __commonJS({
  ".api/apis/zklighter/node_modules/oas/dist/lib/clone-object.js"(exports) {
    "use strict";
    exports.__esModule = true;
    function cloneObject(obj) {
      if (typeof obj === "undefined") {
        return void 0;
      }
      return JSON.parse(JSON.stringify(obj));
    }
    exports["default"] = cloneObject;
  }
});

// .api/apis/zklighter/node_modules/oas/dist/lib/openapi-to-json-schema.js
var require_openapi_to_json_schema = __commonJS({
  ".api/apis/zklighter/node_modules/oas/dist/lib/openapi-to-json-schema.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __rest = exports && exports.__rest || function(s, e) {
      var t = {};
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    exports.__esModule = true;
    exports.isPrimitive = exports.getSchemaVersionString = void 0;
    var json_schema_merge_allof_1 = __importDefault(require_src2());
    var jsonpointer_1 = __importDefault(require_jsonpointer());
    var RMOAS = __importStar(require_rmoas_types());
    var UNSUPPORTED_SCHEMA_PROPS = [
      "nullable",
      // 'discriminator',
      // 'readOnly',
      // 'writeOnly',
      "xml",
      "externalDocs",
      "example"
      // OpenAPI supports `example`, but we're mapping it to `examples` below.
      // 'deprecated',
    ];
    var FORMAT_OPTIONS = {
      INT8_MIN: 0 - Math.pow(2, 7),
      INT8_MAX: Math.pow(2, 7) - 1,
      INT16_MIN: 0 - Math.pow(2, 15),
      INT16_MAX: Math.pow(2, 15) - 1,
      INT32_MIN: 0 - Math.pow(2, 31),
      INT32_MAX: Math.pow(2, 31) - 1,
      INT64_MIN: 0 - Math.pow(2, 63),
      INT64_MAX: Math.pow(2, 63) - 1,
      UINT8_MIN: 0,
      UINT8_MAX: Math.pow(2, 8) - 1,
      UINT16_MIN: 0,
      UINT16_MAX: Math.pow(2, 16) - 1,
      UINT32_MIN: 0,
      UINT32_MAX: Math.pow(2, 32) - 1,
      UINT64_MIN: 0,
      UINT64_MAX: Math.pow(2, 64) - 1,
      FLOAT_MIN: 0 - Math.pow(2, 128),
      FLOAT_MAX: Math.pow(2, 128) - 1,
      DOUBLE_MIN: 0 - Number.MAX_VALUE,
      DOUBLE_MAX: Number.MAX_VALUE
    };
    function encodePointer(str) {
      return str.replace("~", "~0").replace("/", "~1");
    }
    function getSchemaVersionString(schema, api) {
      if (!RMOAS.isOAS31(api)) {
        return "http://json-schema.org/draft-04/schema#";
      }
      if (schema.$schema) {
        return schema.$schema;
      }
      if (api.jsonSchemaDialect) {
        return api.jsonSchemaDialect;
      }
      return "https://json-schema.org/draft/2020-12/schema#";
    }
    exports.getSchemaVersionString = getSchemaVersionString;
    function isPrimitive(val) {
      return typeof val === "string" || typeof val === "number" || typeof val === "boolean";
    }
    exports.isPrimitive = isPrimitive;
    function isPolymorphicSchema(schema) {
      return "allOf" in schema || "anyOf" in schema || "oneOf" in schema;
    }
    function isRequestBodySchema(schema) {
      return "content" in schema;
    }
    function searchForExampleByPointer(pointer, examples) {
      if (examples === void 0) {
        examples = [];
      }
      if (!examples.length || !pointer.length) {
        return void 0;
      }
      var locSplit = pointer.split("/").filter(Boolean).reverse();
      var pointers = [];
      var point = "";
      for (var i = 0; i < locSplit.length; i += 1) {
        point = "/".concat(locSplit[i]).concat(point);
        pointers.push(point);
      }
      var example;
      var rev = __spreadArray([], examples, true).reverse();
      for (var i = 0; i < pointers.length; i += 1) {
        for (var ii = 0; ii < rev.length; ii += 1) {
          var schema = rev[ii];
          if ("example" in schema) {
            schema = schema.example;
          } else {
            if (!Array.isArray(schema.examples) || !schema.examples.length) {
              continue;
            }
            schema = schema.examples.shift();
          }
          try {
            example = jsonpointer_1["default"].get(schema, pointers[i]);
          } catch (err) {
          }
          if (example !== void 0) {
            break;
          }
        }
        if (example !== void 0) {
          break;
        }
      }
      return example;
    }
    function toJSONSchema(data, opts) {
      if (opts === void 0) {
        opts = {};
      }
      var schema = data === true ? {} : __assign({}, data);
      var schemaAdditionalProperties = RMOAS.isSchema(schema) ? schema.additionalProperties : null;
      var _a = __assign({ addEnumsToDescriptions: false, currentLocation: "", globalDefaults: {}, isPolymorphicAllOfChild: false, prevSchemas: [], refLogger: function() {
        return true;
      }, transformer: function(s) {
        return s;
      } }, opts), addEnumsToDescriptions = _a.addEnumsToDescriptions, currentLocation = _a.currentLocation, globalDefaults = _a.globalDefaults, isPolymorphicAllOfChild = _a.isPolymorphicAllOfChild, prevSchemas = _a.prevSchemas, refLogger = _a.refLogger, transformer = _a.transformer;
      if (RMOAS.isRef(schema)) {
        refLogger(schema.$ref, "ref");
        return transformer({
          $ref: schema.$ref
        });
      }
      if (RMOAS.isSchema(schema, isPolymorphicAllOfChild)) {
        if ("allOf" in schema && Array.isArray(schema.allOf)) {
          try {
            schema = (0, json_schema_merge_allof_1["default"])(schema, {
              ignoreAdditionalProperties: true,
              resolvers: {
                // JSON Schema ony supports examples with the `examples` property, since we're
                // ingesting OpenAPI definitions we need to add a custom resolver for its `example`
                // property.
                example: function(obj) {
                  return obj[0];
                },
                // JSON Schema has no support for `format` on anything other than `string`, but since
                // OpenAPI has it on `integer` and `number` we need to add a custom resolver here so we
                // can still merge schemas that may have those.
                format: function(obj) {
                  return obj[0];
                },
                // Since JSON Schema obviously doesn't know about our vendor extension we need to tell
                // the library to essentially ignore and pass it along.
                "x-readme-ref-name": function(obj) {
                  return obj[0];
                }
              }
            });
          } catch (e) {
            var schemaWithoutAllOf = __rest(schema, []);
            schema = schemaWithoutAllOf;
            delete schema.allOf;
          }
        }
        ["anyOf", "oneOf"].forEach(function(polyType) {
          if (polyType in schema && Array.isArray(schema[polyType])) {
            schema[polyType].forEach(function(item, idx) {
              var polyOptions = {
                addEnumsToDescriptions,
                currentLocation: "".concat(currentLocation, "/").concat(idx),
                globalDefaults,
                isPolymorphicAllOfChild: false,
                prevSchemas,
                refLogger,
                transformer
              };
              if ("properties" in schema) {
                schema[polyType][idx] = toJSONSchema({ allOf: [item, { properties: schema.properties }] }, polyOptions);
              } else if ("items" in schema) {
                schema[polyType][idx] = toJSONSchema({ allOf: [item, { items: schema.items }] }, polyOptions);
              } else {
                schema[polyType][idx] = toJSONSchema(item, polyOptions);
              }
            });
          }
        });
        if ("discriminator" in schema) {
          if ("mapping" in schema.discriminator && typeof schema.discriminator.mapping === "object") {
            var mapping_1 = schema.discriminator.mapping;
            Object.keys(mapping_1).forEach(function(k) {
              refLogger(mapping_1[k], "discriminator");
            });
          }
        }
      }
      if (!("type" in schema) && !isPolymorphicSchema(schema) && !isRequestBodySchema(schema)) {
        if ("properties" in schema) {
          schema.type = "object";
        } else if ("items" in schema) {
          schema.type = "array";
        } else {
        }
      }
      if (RMOAS.isSchema(schema, isPolymorphicAllOfChild)) {
        if ("example" in schema) {
          if (isPrimitive(schema.example)) {
            schema.examples = [schema.example];
          } else if (Array.isArray(schema.example)) {
            schema.examples = schema.example.filter(function(example) {
              return isPrimitive(example);
            });
            if (!schema.examples.length) {
              delete schema.examples;
            }
          } else {
            prevSchemas.push({ example: schema.example });
          }
          delete schema.example;
        } else if ("examples" in schema) {
          var reshapedExamples_1 = false;
          if (typeof schema.examples === "object" && !Array.isArray(schema.examples)) {
            var examples_1 = [];
            Object.keys(schema.examples).forEach(function(name) {
              var example = schema.examples[name];
              if ("$ref" in example) {
                refLogger(example.$ref, "ref");
              } else if ("value" in example) {
                if (isPrimitive(example.value)) {
                  examples_1.push(example.value);
                  reshapedExamples_1 = true;
                } else if (Array.isArray(example.value) && isPrimitive(example.value[0])) {
                  examples_1.push(example.value[0]);
                  reshapedExamples_1 = true;
                } else {
                  prevSchemas.push({
                    example: example.value
                  });
                }
              }
            });
            if (examples_1.length) {
              reshapedExamples_1 = true;
              schema.examples = examples_1;
            }
          } else if (Array.isArray(schema.examples) && isPrimitive(schema.examples[0])) {
            reshapedExamples_1 = true;
          }
          if (!reshapedExamples_1) {
            delete schema.examples;
          }
        }
        if (schema.type !== "array" && schema.type !== "object" && !schema.examples) {
          var foundExample = searchForExampleByPointer(currentLocation, prevSchemas);
          if (foundExample) {
            if (isPrimitive(foundExample) || Array.isArray(foundExample) && isPrimitive(foundExample[0])) {
              schema.examples = [foundExample];
            }
          }
        }
        if (schema.type === "array") {
          if ("items" in schema) {
            if (!Array.isArray(schema.items) && Object.keys(schema.items).length === 1 && RMOAS.isRef(schema.items)) {
              refLogger(schema.items.$ref, "ref");
            } else if (schema.items !== true) {
              schema.items = toJSONSchema(schema.items, {
                addEnumsToDescriptions,
                currentLocation: "".concat(currentLocation, "/0"),
                globalDefaults,
                prevSchemas,
                refLogger,
                transformer
              });
            }
          } else if ("properties" in schema || "additionalProperties" in schema) {
            schema.type = "object";
          } else {
            schema.items = {};
          }
        } else if (schema.type === "object") {
          if ("properties" in schema) {
            Object.keys(schema.properties).forEach(function(prop) {
              if (Array.isArray(schema.properties[prop]) || typeof schema.properties[prop] === "object" && schema.properties[prop] !== null) {
                schema.properties[prop] = toJSONSchema(schema.properties[prop], {
                  addEnumsToDescriptions,
                  currentLocation: "".concat(currentLocation, "/").concat(encodePointer(prop)),
                  globalDefaults,
                  prevSchemas,
                  refLogger,
                  transformer
                });
              }
            });
          }
          if (typeof schemaAdditionalProperties === "object" && schemaAdditionalProperties !== null) {
            if (!("type" in schemaAdditionalProperties) && !("$ref" in schemaAdditionalProperties) && // We know it will be a schema object because it's dereferenced
            !isPolymorphicSchema(schemaAdditionalProperties)) {
              schema.additionalProperties = true;
            } else {
              schema.additionalProperties = toJSONSchema(schemaAdditionalProperties, {
                addEnumsToDescriptions,
                currentLocation,
                globalDefaults,
                prevSchemas,
                refLogger,
                transformer
              });
            }
          }
          if (!isPolymorphicSchema(schema) && !("properties" in schema) && !("additionalProperties" in schema)) {
            schema.additionalProperties = true;
          }
        }
      }
      if ("format" in schema) {
        var formatUpper = schema.format.toUpperCase();
        if ("".concat(formatUpper, "_MIN") in FORMAT_OPTIONS) {
          if (!schema.minimum && schema.minimum !== 0 || schema.minimum < FORMAT_OPTIONS["".concat(formatUpper, "_MIN")]) {
            schema.minimum = FORMAT_OPTIONS["".concat(formatUpper, "_MIN")];
          }
        }
        if ("".concat(formatUpper, "_MAX") in FORMAT_OPTIONS) {
          if (!schema.maximum && schema.maximum !== 0 || schema.maximum > FORMAT_OPTIONS["".concat(formatUpper, "_MAX")]) {
            schema.maximum = FORMAT_OPTIONS["".concat(formatUpper, "_MAX")];
          }
        }
      }
      if (RMOAS.isSchema(schema, isPolymorphicAllOfChild) && globalDefaults && Object.keys(globalDefaults).length > 0 && currentLocation) {
        try {
          var userJwtDefault = jsonpointer_1["default"].get(globalDefaults, currentLocation);
          if (userJwtDefault) {
            schema["default"] = userJwtDefault;
          }
        } catch (err) {
        }
      }
      if ("default" in schema && typeof schema["default"] !== "undefined") {
        if ("allowEmptyValue" in schema && schema.allowEmptyValue && schema["default"] === "" || schema["default"] !== "") {
        } else {
          delete schema["default"];
        }
      }
      if (RMOAS.isSchema(schema, isPolymorphicAllOfChild) && "enum" in schema && Array.isArray(schema["enum"])) {
        schema["enum"] = Array.from(new Set(schema["enum"]));
        if (addEnumsToDescriptions) {
          var enums = schema["enum"].filter(Boolean).map(function(str) {
            return "`".concat(str, "`");
          }).join(" ");
          if (enums.length) {
            if ("description" in schema) {
              schema.description += "\n\n".concat(enums);
            } else {
              schema.description = enums;
            }
          }
        }
      }
      if ("anyOf" in schema || "oneOf" in schema) {
        if ("properties" in schema) {
          delete schema.properties;
        }
        if ("items" in schema) {
          delete schema.items;
        }
      }
      for (var i = 0; i < UNSUPPORTED_SCHEMA_PROPS.length; i += 1) {
        delete schema[UNSUPPORTED_SCHEMA_PROPS[i]];
      }
      return transformer(schema);
    }
    exports["default"] = toJSONSchema;
  }
});

// .api/apis/zklighter/node_modules/oas/dist/operation/get-parameters-as-json-schema.js
var require_get_parameters_as_json_schema = __commonJS({
  ".api/apis/zklighter/node_modules/oas/dist/operation/get-parameters-as-json-schema.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    exports.__esModule = true;
    exports.types = void 0;
    var clone_object_1 = __importDefault(require_clone_object());
    var matches_mimetype_1 = __importDefault(require_matches_mimetype());
    var openapi_to_json_schema_1 = __importStar(require_openapi_to_json_schema());
    var isJSON = matches_mimetype_1["default"].json;
    exports.types = {
      path: "Path Params",
      query: "Query Params",
      body: "Body Params",
      cookie: "Cookie Params",
      formData: "Form Data",
      header: "Headers",
      metadata: "Metadata"
    };
    function getParametersAsJSONSchema(operation, api, opts) {
      var _a;
      var hasCircularRefs = false;
      var hasDiscriminatorMappingRefs = false;
      function refLogger(ref, type) {
        if (type === "ref") {
          hasCircularRefs = true;
        } else {
          hasDiscriminatorMappingRefs = true;
        }
      }
      function getDeprecated(schema, type) {
        if (opts.retainDeprecatedProperties) {
          return null;
        }
        if (!schema || !schema.properties)
          return null;
        var deprecatedBody = (0, clone_object_1["default"])(schema);
        var requiredParams = schema.required || [];
        var allDeprecatedProps = {};
        Object.keys(deprecatedBody.properties).forEach(function(key) {
          var deprecatedProp = deprecatedBody.properties[key];
          if (deprecatedProp.deprecated && !requiredParams.includes(key) && !deprecatedProp.readOnly) {
            allDeprecatedProps[key] = deprecatedProp;
          }
        });
        deprecatedBody.properties = allDeprecatedProps;
        var deprecatedSchema = (0, openapi_to_json_schema_1["default"])(deprecatedBody, {
          globalDefaults: opts.globalDefaults,
          prevSchemas: [],
          refLogger,
          transformer: opts.transformer
        });
        if (Object.keys(deprecatedSchema).length === 0 || Object.keys(deprecatedSchema.properties).length === 0) {
          return null;
        }
        Object.keys(schema.properties).forEach(function(key) {
          if (schema.properties[key].deprecated && !requiredParams.includes(key)) {
            delete schema.properties[key];
          }
        });
        return {
          type,
          schema: (0, openapi_to_json_schema_1.isPrimitive)(deprecatedSchema) ? deprecatedSchema : __assign(__assign({}, deprecatedSchema), { $schema: (0, openapi_to_json_schema_1.getSchemaVersionString)(deprecatedSchema, api) })
        };
      }
      function transformRequestBody() {
        var requestBody = operation.getRequestBody();
        if (!requestBody || !Array.isArray(requestBody))
          return null;
        var mediaType = requestBody[0], mediaTypeObject = requestBody[1], description = requestBody[2];
        var type = mediaType === "application/x-www-form-urlencoded" ? "formData" : "body";
        if (!mediaTypeObject.schema || !Object.keys(mediaTypeObject.schema).length) {
          return null;
        }
        var prevSchemas = [];
        if ("example" in mediaTypeObject) {
          prevSchemas.push({ example: mediaTypeObject.example });
        } else if ("examples" in mediaTypeObject) {
          prevSchemas.push({
            examples: Object.values(mediaTypeObject.examples).map(function(example) {
              return example.value;
            }).filter(function(val) {
              return val !== void 0;
            })
          });
        }
        var requestSchema = (0, clone_object_1["default"])(mediaTypeObject.schema);
        var cleanedSchema = (0, openapi_to_json_schema_1["default"])(requestSchema, {
          globalDefaults: opts.globalDefaults,
          prevSchemas,
          refLogger,
          transformer: opts.transformer
        });
        if (!Object.keys(cleanedSchema).length) {
          return null;
        }
        return __assign({ type, label: exports.types[type], schema: (0, openapi_to_json_schema_1.isPrimitive)(cleanedSchema) ? cleanedSchema : __assign(__assign({}, cleanedSchema), { $schema: (0, openapi_to_json_schema_1.getSchemaVersionString)(cleanedSchema, api) }), deprecatedProps: getDeprecated(cleanedSchema, type) }, description ? { description } : {});
      }
      function transformComponents() {
        if (!("components" in api)) {
          return false;
        }
        var components2 = {};
        Object.keys(api.components).forEach(function(componentType) {
          if (typeof api.components[componentType] === "object" && !Array.isArray(api.components[componentType])) {
            components2[componentType] = {};
            Object.keys(api.components[componentType]).forEach(function(schemaName) {
              var componentSchema = (0, clone_object_1["default"])(api.components[componentType][schemaName]);
              components2[componentType][schemaName] = (0, openapi_to_json_schema_1["default"])(componentSchema, {
                globalDefaults: opts.globalDefaults,
                refLogger,
                transformer: opts.transformer
              });
            });
          }
        });
        return components2;
      }
      function transformParameters() {
        var operationParams = operation.getParameters();
        var transformed = Object.keys(exports.types).map(function(type) {
          var required = [];
          var parameters = operationParams.filter(function(param) {
            return param["in"] === type;
          });
          if (parameters.length === 0) {
            return null;
          }
          var properties = parameters.reduce(function(prev, current) {
            var schema2 = {};
            if ("schema" in current) {
              var currentSchema = current.schema ? (0, clone_object_1["default"])(current.schema) : {};
              if (current.example) {
                currentSchema.example = current.example;
              } else if (current.examples) {
                currentSchema.examples = current.examples;
              }
              if (current.deprecated)
                currentSchema.deprecated = current.deprecated;
              var interimSchema = (0, openapi_to_json_schema_1["default"])(currentSchema, {
                currentLocation: "/".concat(current.name),
                globalDefaults: opts.globalDefaults,
                refLogger,
                transformer: opts.transformer
              });
              schema2 = (0, openapi_to_json_schema_1.isPrimitive)(interimSchema) ? interimSchema : __assign(__assign({}, interimSchema), {
                // Note: this applies a `$schema` version to each field in the larger schema
                // object. It's not really **correct** but it's what we have to do because
                // there's a chance that the end user has indicated the schemas are different.
                $schema: (0, openapi_to_json_schema_1.getSchemaVersionString)(currentSchema, api)
              });
            } else if ("content" in current && typeof current.content === "object") {
              var contentKeys = Object.keys(current.content);
              if (contentKeys.length) {
                var contentType = void 0;
                if (contentKeys.length === 1) {
                  contentType = contentKeys[0];
                } else {
                  var jsonLikeContentTypes = contentKeys.filter(function(k) {
                    return isJSON(k);
                  });
                  if (jsonLikeContentTypes.length) {
                    contentType = jsonLikeContentTypes[0];
                  } else {
                    contentType = contentKeys[0];
                  }
                }
                if (typeof current.content[contentType] === "object" && "schema" in current.content[contentType]) {
                  var currentSchema = current.content[contentType].schema ? (0, clone_object_1["default"])(current.content[contentType].schema) : {};
                  if (current.example) {
                    currentSchema.example = current.example;
                  } else if (current.examples) {
                    currentSchema.examples = current.examples;
                  }
                  if (current.deprecated)
                    currentSchema.deprecated = current.deprecated;
                  var interimSchema = (0, openapi_to_json_schema_1["default"])(currentSchema, {
                    currentLocation: "/".concat(current.name),
                    globalDefaults: opts.globalDefaults,
                    refLogger,
                    transformer: opts.transformer
                  });
                  schema2 = (0, openapi_to_json_schema_1.isPrimitive)(interimSchema) ? interimSchema : __assign(__assign({}, interimSchema), {
                    // Note: this applies a `$schema` version to each field in the larger schema
                    // object. It's not really **correct** but it's what we have to do because
                    // there's a chance that the end user has indicated the schemas are different.
                    $schema: (0, openapi_to_json_schema_1.getSchemaVersionString)(currentSchema, api)
                  });
                }
              }
            }
            if (current.description) {
              if (!(0, openapi_to_json_schema_1.isPrimitive)(schema2)) {
                schema2.description = current.description;
              }
            }
            prev[current.name] = schema2;
            if (current.required) {
              required.push(current.name);
            }
            return prev;
          }, {});
          var schema = {
            type: "object",
            properties,
            required
          };
          return {
            type,
            label: exports.types[type],
            schema,
            deprecatedProps: getDeprecated(schema, type)
          };
        }).filter(Boolean);
        if (!opts.mergeIntoBodyAndMetadata) {
          return transformed;
        } else if (!transformed.length) {
          return [];
        }
        var deprecatedProps = transformed.map(function(r) {
          var _a2;
          return ((_a2 = r.deprecatedProps) === null || _a2 === void 0 ? void 0 : _a2.schema) || null;
        }).filter(Boolean);
        return [
          {
            type: "metadata",
            label: exports.types.metadata,
            schema: {
              allOf: transformed.map(function(r) {
                return r.schema;
              })
            },
            deprecatedProps: deprecatedProps.length ? {
              type: "metadata",
              schema: {
                allOf: deprecatedProps
              }
            } : null
          }
        ];
      }
      if (!operation.hasParameters() && !operation.hasRequestBody()) {
        return null;
      }
      var components = transformComponents();
      var typeKeys = Object.keys(exports.types);
      return (_a = [transformRequestBody()]).concat.apply(_a, transformParameters()).filter(Boolean).map(function(group) {
        if (components) {
          if (hasCircularRefs || hasDiscriminatorMappingRefs && opts.includeDiscriminatorMappingRefs) {
            group.schema.components = components;
          }
        }
        if (!group.deprecatedProps)
          delete group.deprecatedProps;
        return group;
      }).sort(function(a, b) {
        return typeKeys.indexOf(a.type) - typeKeys.indexOf(b.type);
      });
    }
    exports["default"] = getParametersAsJSONSchema;
  }
});

// .api/apis/zklighter/node_modules/oas/dist/operation/get-requestbody-examples.js
var require_get_requestbody_examples = __commonJS({
  ".api/apis/zklighter/node_modules/oas/dist/operation/get-requestbody-examples.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    exports.__esModule = true;
    var get_mediatype_examples_1 = __importDefault(require_get_mediatype_examples());
    function getRequestBodyExamples(operation) {
      var requestBody = operation.requestBody;
      if (!requestBody || !requestBody.content) {
        return [];
      }
      return Object.keys(requestBody.content || {}).map(function(mediaType) {
        var mediaTypeObject = requestBody.content[mediaType];
        var examples = (0, get_mediatype_examples_1["default"])(mediaType, mediaTypeObject, {
          includeReadOnly: false,
          includeWriteOnly: true
        });
        if (!examples.length) {
          return false;
        }
        return {
          mediaType,
          examples
        };
      }).filter(Boolean);
    }
    exports["default"] = getRequestBodyExamples;
  }
});

// .api/apis/zklighter/node_modules/oas/dist/operation/get-response-as-json-schema.js
var require_get_response_as_json_schema = __commonJS({
  ".api/apis/zklighter/node_modules/oas/dist/operation/get-response-as-json-schema.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    exports.__esModule = true;
    var clone_object_1 = __importDefault(require_clone_object());
    var matches_mimetype_1 = __importDefault(require_matches_mimetype());
    var openapi_to_json_schema_1 = __importStar(require_openapi_to_json_schema());
    var isJSON = matches_mimetype_1["default"].json;
    function buildHeadersSchema(response, opts) {
      var headers = response.headers;
      var headersSchema = {
        type: "object",
        properties: {}
      };
      Object.keys(headers).forEach(function(key) {
        if (headers[key] && headers[key].schema) {
          var header = headers[key];
          headersSchema.properties[key] = (0, openapi_to_json_schema_1["default"])(header.schema, {
            addEnumsToDescriptions: true,
            transformer: opts.transformer
          });
          if (header.description) {
            headersSchema.properties[key].description = header.description;
          }
        }
      });
      var headersWrapper = {
        schema: headersSchema,
        type: "object",
        label: "Headers"
      };
      if (response.description && headersWrapper.schema) {
        headersWrapper.description = response.description;
      }
      return headersWrapper;
    }
    function getResponseAsJSONSchema(operation, api, statusCode, opts) {
      var response = operation.getResponseByStatusCode(statusCode);
      var jsonSchema = [];
      if (!response) {
        return null;
      }
      var hasCircularRefs = false;
      var hasDiscriminatorMappingRefs = false;
      function refLogger(ref, type) {
        if (type === "ref") {
          hasCircularRefs = true;
        } else {
          hasDiscriminatorMappingRefs = true;
        }
      }
      function getPreferredSchema(content) {
        if (!content) {
          return null;
        }
        var contentTypes = Object.keys(content);
        if (!contentTypes.length) {
          return null;
        }
        for (var i = 0; i < contentTypes.length; i++) {
          if (isJSON(contentTypes[i])) {
            return (0, openapi_to_json_schema_1["default"])((0, clone_object_1["default"])(content[contentTypes[i]].schema), {
              addEnumsToDescriptions: true,
              refLogger,
              transformer: opts.transformer
            });
          }
        }
        var contentType = contentTypes.shift();
        return (0, openapi_to_json_schema_1["default"])((0, clone_object_1["default"])(content[contentType].schema), {
          addEnumsToDescriptions: true,
          refLogger,
          transformer: opts.transformer
        });
      }
      var foundSchema = getPreferredSchema(response.content);
      if (foundSchema) {
        var schema = (0, clone_object_1["default"])(foundSchema);
        var schemaWrapper = {
          // If there's no `type` then the root schema is a circular `$ref` that we likely won't be
          // able to render so instead of generating a JSON Schema with an `undefined` type we should
          // default to `string` so there's at least *something* the end-user can interact with.
          type: foundSchema.type || "string",
          schema: (0, openapi_to_json_schema_1.isPrimitive)(schema) ? schema : __assign(__assign({}, schema), { $schema: (0, openapi_to_json_schema_1.getSchemaVersionString)(schema, api) }),
          label: "Response body"
        };
        if (response.description && schemaWrapper.schema) {
          schemaWrapper.description = response.description;
        }
        if (api.components && schemaWrapper.schema) {
          if (hasCircularRefs || hasDiscriminatorMappingRefs && opts.includeDiscriminatorMappingRefs) {
            schemaWrapper.schema.components = api.components;
          }
        }
        jsonSchema.push(schemaWrapper);
      }
      if (response.headers) {
        jsonSchema.push(buildHeadersSchema(response, opts));
      }
      return jsonSchema.length ? jsonSchema : null;
    }
    exports["default"] = getResponseAsJSONSchema;
  }
});

// .api/apis/zklighter/node_modules/oas/dist/utils.js
var require_utils2 = __commonJS({
  ".api/apis/zklighter/node_modules/oas/dist/utils.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    exports.__esModule = true;
    exports.supportedMethods = void 0;
    var find_schema_definition_1 = __importDefault(require_find_schema_definition());
    var matches_mimetype_1 = __importDefault(require_matches_mimetype());
    var get_parameters_as_json_schema_1 = require_get_parameters_as_json_schema();
    var supportedMethods = /* @__PURE__ */ new Set(["get", "put", "post", "delete", "options", "head", "patch", "trace"]);
    exports.supportedMethods = supportedMethods;
    exports["default"] = {
      findSchemaDefinition: find_schema_definition_1["default"],
      jsonSchemaTypes: get_parameters_as_json_schema_1.types,
      matchesMimeType: matches_mimetype_1["default"]
    };
  }
});

// .api/apis/zklighter/node_modules/oas/dist/operation.js
var require_operation = __commonJS({
  ".api/apis/zklighter/node_modules/oas/dist/operation.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    exports.__esModule = true;
    exports.Webhook = exports.Callback = void 0;
    var dedupe_common_parameters_1 = __importDefault(require_dedupe_common_parameters());
    var find_schema_definition_1 = __importDefault(require_find_schema_definition());
    var matches_mimetype_1 = __importDefault(require_matches_mimetype());
    var get_callback_examples_1 = __importDefault(require_get_callback_examples());
    var get_parameters_as_json_schema_1 = __importDefault(require_get_parameters_as_json_schema());
    var get_requestbody_examples_1 = __importDefault(require_get_requestbody_examples());
    var get_response_as_json_schema_1 = __importDefault(require_get_response_as_json_schema());
    var get_response_examples_1 = __importDefault(require_get_response_examples());
    var RMOAS = __importStar(require_rmoas_types());
    var utils_1 = require_utils2();
    var Operation = (
      /** @class */
      function() {
        function Operation2(api, path, method, operation) {
          this.schema = operation;
          this.api = api;
          this.path = path;
          this.method = method;
          this.contentType = void 0;
          this.requestBodyExamples = void 0;
          this.responseExamples = void 0;
          this.callbackExamples = void 0;
        }
        Operation2.prototype.getSummary = function() {
          var _a;
          if ((_a = this.schema) === null || _a === void 0 ? void 0 : _a.summary) {
            return this.schema.summary.trim();
          } else if (this.api.paths[this.path].summary) {
            return this.api.paths[this.path].summary;
          }
          return void 0;
        };
        Operation2.prototype.getDescription = function() {
          var _a;
          if ((_a = this.schema) === null || _a === void 0 ? void 0 : _a.description) {
            return this.schema.description.trim();
          } else if (this.api.paths[this.path].description) {
            return this.api.paths[this.path].description;
          }
          return void 0;
        };
        Operation2.prototype.getContentType = function() {
          var _this = this;
          if (this.contentType) {
            return this.contentType;
          }
          var types = [];
          if (this.schema.requestBody) {
            if ("$ref" in this.schema.requestBody) {
              this.schema.requestBody = (0, find_schema_definition_1["default"])(this.schema.requestBody.$ref, this.api);
            }
            if ("content" in this.schema.requestBody) {
              types = Object.keys(this.schema.requestBody.content);
            }
          }
          this.contentType = "application/json";
          if (types && types.length) {
            this.contentType = types[0];
          }
          types.forEach(function(t) {
            if (matches_mimetype_1["default"].json(t)) {
              _this.contentType = t;
            }
          });
          return this.contentType;
        };
        Operation2.prototype.isFormUrlEncoded = function() {
          return matches_mimetype_1["default"].formUrlEncoded(this.getContentType());
        };
        Operation2.prototype.isMultipart = function() {
          return matches_mimetype_1["default"].multipart(this.getContentType());
        };
        Operation2.prototype.isJson = function() {
          return matches_mimetype_1["default"].json(this.getContentType());
        };
        Operation2.prototype.isXml = function() {
          return matches_mimetype_1["default"].xml(this.getContentType());
        };
        Operation2.prototype.getSecurity = function() {
          var _a, _b;
          if (!((_b = (_a = this.api) === null || _a === void 0 ? void 0 : _a.components) === null || _b === void 0 ? void 0 : _b.securitySchemes) || !Object.keys(this.api.components.securitySchemes).length) {
            return [];
          }
          return this.schema.security || this.api.security || [];
        };
        Operation2.prototype.getSecurityWithTypes = function(filterInvalid) {
          var _this = this;
          if (filterInvalid === void 0) {
            filterInvalid = false;
          }
          var securityRequirements = this.getSecurity();
          return securityRequirements.map(function(requirement) {
            var keys;
            try {
              keys = Object.keys(requirement);
            } catch (e) {
              return false;
            }
            var keysWithTypes = keys.map(function(key) {
              var security;
              try {
                security = _this.api.components.securitySchemes[key];
              } catch (e) {
                return false;
              }
              if (!security)
                return false;
              var type = null;
              if (security.type === "http") {
                if (security.scheme === "basic")
                  type = "Basic";
                else if (security.scheme === "bearer")
                  type = "Bearer";
                else
                  type = security.type;
              } else if (security.type === "oauth2") {
                type = "OAuth2";
              } else if (security.type === "apiKey") {
                if (security["in"] === "query")
                  type = "Query";
                else if (security["in"] === "header")
                  type = "Header";
                else if (security["in"] === "cookie")
                  type = "Cookie";
                else
                  type = security.type;
              } else {
                return false;
              }
              return {
                type,
                security: __assign(__assign({}, security), { _key: key })
              };
            });
            if (filterInvalid)
              return keysWithTypes.filter(function(key) {
                return key !== false;
              });
            return keysWithTypes;
          });
        };
        Operation2.prototype.prepareSecurity = function() {
          var securitiesWithTypes = this.getSecurityWithTypes();
          return securitiesWithTypes.reduce(function(prev, securities) {
            if (!securities)
              return prev;
            securities.forEach(function(security) {
              if (!security)
                return;
              if (!prev[security.type])
                prev[security.type] = [];
              var exists = prev[security.type].findIndex(function(sec) {
                return sec._key === security.security._key;
              });
              if (exists < 0) {
                prev[security.type].push(security.security);
              }
            });
            return prev;
          }, {});
        };
        Operation2.prototype.getHeaders = function() {
          var _this = this;
          this.headers = {
            request: [],
            response: []
          };
          var security = this.prepareSecurity();
          if (security.Header) {
            this.headers.request = security.Header.map(function(h) {
              return h.name;
            });
          }
          if (security.Bearer || security.Basic || security.OAuth2) {
            this.headers.request.push("Authorization");
          }
          if (security.Cookie) {
            this.headers.request.push("Cookie");
          }
          if (this.schema.parameters) {
            this.headers.request = this.headers.request.concat(
              // Remove the reference object because we will have already dereferenced
              this.schema.parameters.map(function(p) {
                if (p["in"] && p["in"] === "header")
                  return p.name;
                return void 0;
              }).filter(function(p) {
                return p;
              })
            );
          }
          if (this.schema.responses) {
            this.headers.response = Object.keys(this.schema.responses).filter(function(r) {
              return _this.schema.responses[r].headers;
            }).map(function(r) {
              return Object.keys(_this.schema.responses[r].headers);
            }).reduce(function(a, b) {
              return a.concat(b);
            }, []);
          }
          if (!this.headers.request.includes("Content-Type") && this.schema.requestBody) {
            if (this.schema.requestBody.content && Object.keys(this.schema.requestBody.content)) {
              this.headers.request.push("Content-Type");
            }
          }
          if (this.schema.responses) {
            if (Object.keys(this.schema.responses).some(function(response) {
              return !!_this.schema.responses[response].content;
            })) {
              if (!this.headers.request.includes("Accept"))
                this.headers.request.push("Accept");
              if (!this.headers.response.includes("Content-Type"))
                this.headers.response.push("Content-Type");
            }
          }
          return this.headers;
        };
        Operation2.prototype.hasOperationId = function() {
          return Boolean("operationId" in this.schema && this.schema.operationId.length);
        };
        Operation2.prototype.getOperationId = function(opts) {
          function sanitize(id) {
            return id.replace((opts === null || opts === void 0 ? void 0 : opts.camelCase) ? /[^a-zA-Z0-9_]/g : /[^a-zA-Z0-9]/g, "-").replace(/--+/g, "-").replace(/^-|-$/g, "");
          }
          var operationId;
          if (this.hasOperationId()) {
            operationId = this.schema.operationId;
          } else {
            operationId = sanitize(this.path).toLowerCase();
          }
          var method = this.method.toLowerCase();
          if (opts === null || opts === void 0 ? void 0 : opts.camelCase) {
            operationId = operationId.replace(/[^a-zA-Z0-9_]+(.)/g, function(_, chr) {
              return chr.toUpperCase();
            });
            if (this.hasOperationId()) {
              operationId = sanitize(operationId);
            }
            operationId = operationId.replace(/^[0-9]/g, function(match2) {
              return "_".concat(match2);
            });
            operationId = operationId.charAt(0).toLowerCase() + operationId.slice(1);
            if (operationId.startsWith(method)) {
              return operationId;
            }
            if (this.hasOperationId()) {
              return operationId;
            }
            operationId = operationId.charAt(0).toUpperCase() + operationId.slice(1);
            return "".concat(method).concat(operationId);
          } else if (this.hasOperationId()) {
            return operationId;
          }
          return "".concat(method, "_").concat(operationId);
        };
        Operation2.prototype.getTags = function() {
          if (!("tags" in this.schema)) {
            return [];
          }
          var oasTagMap = /* @__PURE__ */ new Map();
          if ("tags" in this.api) {
            this.api.tags.forEach(function(tag) {
              oasTagMap.set(tag.name, tag);
            });
          }
          var oasTags = Object.fromEntries(oasTagMap);
          var tags = [];
          if (Array.isArray(this.schema.tags)) {
            this.schema.tags.forEach(function(tag) {
              if (tag in oasTags) {
                tags.push(oasTags[tag]);
              } else {
                tags.push({
                  name: tag
                });
              }
            });
          }
          return tags;
        };
        Operation2.prototype.isDeprecated = function() {
          return "deprecated" in this.schema ? this.schema.deprecated : false;
        };
        Operation2.prototype.hasParameters = function() {
          return !!this.getParameters().length;
        };
        Operation2.prototype.getParameters = function() {
          var _a, _b, _c, _d;
          var parameters = ((_a = this.schema) === null || _a === void 0 ? void 0 : _a.parameters) || [];
          var commonParams = ((_d = (_c = (_b = this.api) === null || _b === void 0 ? void 0 : _b.paths) === null || _c === void 0 ? void 0 : _c[this.path]) === null || _d === void 0 ? void 0 : _d.parameters) || [];
          if (commonParams.length) {
            parameters = parameters.concat((0, dedupe_common_parameters_1["default"])(parameters, commonParams) || []);
          }
          return parameters;
        };
        Operation2.prototype.hasRequiredParameters = function() {
          return this.getParameters().some(function(param) {
            return "required" in param && param.required;
          });
        };
        Operation2.prototype.getParametersAsJSONSchema = function(opts) {
          if (opts === void 0) {
            opts = {};
          }
          return (0, get_parameters_as_json_schema_1["default"])(this, this.api, __assign({ includeDiscriminatorMappingRefs: true, transformer: function(s) {
            return s;
          } }, opts));
        };
        Operation2.prototype.getResponseAsJSONSchema = function(statusCode, opts) {
          if (opts === void 0) {
            opts = {};
          }
          return (0, get_response_as_json_schema_1["default"])(this, this.api, statusCode, __assign({ includeDiscriminatorMappingRefs: true, transformer: function(s) {
            return s;
          } }, opts));
        };
        Operation2.prototype.getResponseStatusCodes = function() {
          return this.schema.responses ? Object.keys(this.schema.responses) : [];
        };
        Operation2.prototype.hasRequestBody = function() {
          return !!this.schema.requestBody;
        };
        Operation2.prototype.getRequestBodyMediaTypes = function() {
          if (!this.hasRequestBody()) {
            return [];
          }
          var requestBody = this.schema.requestBody;
          if (RMOAS.isRef(requestBody)) {
            return [];
          }
          return Object.keys(requestBody.content);
        };
        Operation2.prototype.hasRequiredRequestBody = function() {
          if (!this.hasRequestBody()) {
            return false;
          }
          var requestBody = this.schema.requestBody;
          if (RMOAS.isRef(requestBody)) {
            return false;
          }
          if (requestBody.required) {
            return true;
          }
          return !!this.getParametersAsJSONSchema().filter(function(js) {
            return ["body", "formData"].includes(js.type);
          }).find(function(js) {
            return js.schema && Array.isArray(js.schema.required) && js.schema.required.length;
          });
        };
        Operation2.prototype.getRequestBody = function(mediaType) {
          if (!this.hasRequestBody()) {
            return false;
          }
          var requestBody = this.schema.requestBody;
          if (RMOAS.isRef(requestBody)) {
            return false;
          }
          if (mediaType) {
            if (!(mediaType in requestBody.content)) {
              return false;
            }
            return requestBody.content[mediaType];
          }
          var availableMediaType;
          var mediaTypes = this.getRequestBodyMediaTypes();
          mediaTypes.forEach(function(mt) {
            if (!availableMediaType && matches_mimetype_1["default"].json(mt)) {
              availableMediaType = mt;
            }
          });
          if (!availableMediaType) {
            mediaTypes.forEach(function(mt) {
              if (!availableMediaType) {
                availableMediaType = mt;
              }
            });
          }
          if (availableMediaType) {
            return __spreadArray([
              availableMediaType,
              requestBody.content[availableMediaType]
            ], requestBody.description ? [requestBody.description] : [], true);
          }
          return false;
        };
        Operation2.prototype.getRequestBodyExamples = function() {
          if (this.requestBodyExamples) {
            return this.requestBodyExamples;
          }
          this.requestBodyExamples = (0, get_requestbody_examples_1["default"])(this.schema);
          return this.requestBodyExamples;
        };
        Operation2.prototype.getResponseByStatusCode = function(statusCode) {
          if (!this.schema.responses) {
            return false;
          }
          if (typeof this.schema.responses[statusCode] === "undefined") {
            return false;
          }
          var response = this.schema.responses[statusCode];
          if (RMOAS.isRef(response)) {
            return false;
          }
          return response;
        };
        Operation2.prototype.getResponseExamples = function() {
          if (this.responseExamples) {
            return this.responseExamples;
          }
          this.responseExamples = (0, get_response_examples_1["default"])(this.schema);
          return this.responseExamples;
        };
        Operation2.prototype.hasCallbacks = function() {
          return !!this.schema.callbacks;
        };
        Operation2.prototype.getCallback = function(identifier, expression, method) {
          if (!this.schema.callbacks)
            return false;
          var callback = this.schema.callbacks[identifier] ? this.schema.callbacks[identifier][expression] : false;
          if (!callback || !callback[method])
            return false;
          return new Callback(this.api, expression, method, callback[method], identifier, callback);
        };
        Operation2.prototype.getCallbacks = function() {
          var _this = this;
          var callbackOperations = [];
          if (!this.hasCallbacks())
            return false;
          Object.keys(this.schema.callbacks).forEach(function(callback) {
            Object.keys(_this.schema.callbacks[callback]).forEach(function(expression) {
              var cb = _this.schema.callbacks[callback];
              if (!RMOAS.isRef(cb)) {
                var exp = cb[expression];
                if (!RMOAS.isRef(exp)) {
                  Object.keys(exp).forEach(function(method) {
                    if (!utils_1.supportedMethods.has(method))
                      return;
                    callbackOperations.push(_this.getCallback(callback, expression, method));
                  });
                }
              }
            });
          });
          return callbackOperations;
        };
        Operation2.prototype.getCallbackExamples = function() {
          if (this.callbackExamples) {
            return this.callbackExamples;
          }
          this.callbackExamples = (0, get_callback_examples_1["default"])(this.schema);
          return this.callbackExamples;
        };
        Operation2.prototype.hasExtension = function(extension) {
          return Boolean(this.schema && extension in this.schema);
        };
        Operation2.prototype.getExtension = function(extension) {
          var _a;
          return (_a = this.schema) === null || _a === void 0 ? void 0 : _a[extension];
        };
        return Operation2;
      }()
    );
    exports["default"] = Operation;
    var Callback = (
      /** @class */
      function(_super) {
        __extends(Callback2, _super);
        function Callback2(oas, path, method, operation, identifier, parentPathItem) {
          var _this = _super.call(this, oas, path, method, operation) || this;
          _this.identifier = identifier;
          _this.parentSchema = parentPathItem;
          return _this;
        }
        Callback2.prototype.getIdentifier = function() {
          return this.identifier;
        };
        Callback2.prototype.getSummary = function() {
          var _a;
          if ((_a = this.schema) === null || _a === void 0 ? void 0 : _a.summary) {
            return this.schema.summary.trim();
          } else if (this.parentSchema.summary) {
            return this.parentSchema.summary;
          }
          return void 0;
        };
        Callback2.prototype.getDescription = function() {
          var _a;
          if ((_a = this.schema) === null || _a === void 0 ? void 0 : _a.description) {
            return this.schema.description.trim();
          } else if (this.parentSchema.description) {
            return this.parentSchema.description;
          }
          return void 0;
        };
        Callback2.prototype.getParameters = function() {
          var _a;
          var parameters = ((_a = this.schema) === null || _a === void 0 ? void 0 : _a.parameters) || [];
          var commonParams = this.parentSchema.parameters || [];
          if (commonParams.length) {
            parameters = parameters.concat((0, dedupe_common_parameters_1["default"])(parameters, commonParams) || []);
          }
          return parameters;
        };
        return Callback2;
      }(Operation)
    );
    exports.Callback = Callback;
    var Webhook = (
      /** @class */
      function(_super) {
        __extends(Webhook2, _super);
        function Webhook2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        return Webhook2;
      }(Operation)
    );
    exports.Webhook = Webhook;
  }
});

// .api/apis/zklighter/node_modules/oas/dist/index.js
var require_dist = __commonJS({
  ".api/apis/zklighter/node_modules/oas/dist/index.js"(exports) {
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    exports.__esModule = true;
    exports.utils = exports.Webhook = exports.Callback = exports.Operation = void 0;
    var json_schema_ref_parser_1 = __importDefault(require_lib());
    var path_to_regexp_1 = (init_dist(), __toCommonJS(dist_exports));
    var get_auth_1 = __importDefault(require_get_auth());
    var get_user_variable_1 = __importDefault(require_get_user_variable());
    var operation_1 = __importStar(require_operation());
    exports.Operation = operation_1["default"];
    exports.Callback = operation_1.Callback;
    exports.Webhook = operation_1.Webhook;
    var utils_1 = __importStar(require_utils2());
    exports.utils = utils_1["default"];
    var SERVER_VARIABLE_REGEX = /{([-_a-zA-Z0-9:.[\]]+)}/g;
    function ensureProtocol(url) {
      if (url.match(/^\/\//)) {
        return "https:".concat(url);
      }
      if (!url.match(/\/\//)) {
        return "https://".concat(url);
      }
      return url;
    }
    function stripTrailingSlash(url) {
      if (url[url.length - 1] === "/") {
        return url.slice(0, -1);
      }
      return url;
    }
    function normalizedUrl(api, selected) {
      var exampleDotCom = "https://example.com";
      var url;
      try {
        url = api.servers[selected].url;
        if (!url)
          throw new Error("no url");
        url = stripTrailingSlash(url);
        if (url.startsWith("/") && !url.startsWith("//")) {
          var urlWithOrigin = new URL(exampleDotCom);
          urlWithOrigin.pathname = url;
          url = urlWithOrigin.href;
        }
      } catch (e) {
        url = exampleDotCom;
      }
      return ensureProtocol(url);
    }
    function transformUrlIntoRegex(url) {
      return stripTrailingSlash(url.replace(SERVER_VARIABLE_REGEX, "([-_a-zA-Z0-9:.[\\]]+)"));
    }
    function normalizePath(path) {
      return path.replace(/({?){(.*?)}(}?)/g, function(str) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        return ":".concat(args[1].replace("-", ""));
      }).replace(/::/, "\\::").split("?")[0];
    }
    function generatePathMatches(paths, pathName, origin) {
      var prunedPathName = pathName.split("?")[0];
      return Object.keys(paths).map(function(path) {
        var cleanedPath = normalizePath(path);
        var matchResult;
        try {
          var matchStatement = (0, path_to_regexp_1.match)(cleanedPath, { decode: decodeURIComponent });
          matchResult = matchStatement(prunedPathName);
        } catch (err) {
          return;
        }
        var slugs = {};
        if (matchResult && Object.keys(matchResult.params).length) {
          Object.keys(matchResult.params).forEach(function(param) {
            slugs[":".concat(param)] = matchResult.params[param];
          });
        }
        return {
          url: {
            origin,
            path: cleanedPath.replace(/\\::/, "::"),
            nonNormalizedPath: path,
            slugs
          },
          operation: paths[path],
          match: matchResult
        };
      }).filter(Boolean).filter(function(p) {
        return p.match;
      });
    }
    function filterPathMethods(pathMatches, targetMethod) {
      var regExp = (0, path_to_regexp_1.pathToRegexp)(targetMethod);
      return pathMatches.map(function(p) {
        var captures = Object.keys(p.operation).filter(function(r) {
          return regExp.exec(r);
        });
        if (captures.length) {
          var method = captures[0];
          p.url.method = method.toUpperCase();
          return {
            url: p.url,
            operation: p.operation[method]
          };
        }
        return false;
      }).filter(Boolean);
    }
    function findTargetPath(pathMatches) {
      var minCount = Object.keys(pathMatches[0].url.slugs).length;
      var operation;
      for (var m = 0; m < pathMatches.length; m += 1) {
        var selection = pathMatches[m];
        var paramCount = Object.keys(selection.url.slugs).length;
        if (paramCount <= minCount) {
          minCount = paramCount;
          operation = selection;
        }
      }
      return operation;
    }
    var Oas = (
      /** @class */
      function() {
        function Oas2(oas, user) {
          this.api = oas;
          this.user = user || {};
          this.promises = [];
          this.dereferencing = {
            processing: false,
            complete: false,
            circularRefs: []
          };
        }
        Oas2.init = function(oas, user) {
          return new Oas2(oas, user);
        };
        Oas2.prototype.getVersion = function() {
          if (this.api.openapi) {
            return this.api.openapi;
          }
          throw new Error("Unable to recognize what specification version this API definition conforms to.");
        };
        Oas2.prototype.getDefinition = function() {
          return this.api;
        };
        Oas2.prototype.url = function(selected, variables) {
          if (selected === void 0) {
            selected = 0;
          }
          var url = normalizedUrl(this.api, selected);
          return this.replaceUrl(url, variables || this.variables(selected)).trim();
        };
        Oas2.prototype.variables = function(selected) {
          if (selected === void 0) {
            selected = 0;
          }
          var variables;
          try {
            variables = this.api.servers[selected].variables;
            if (!variables)
              throw new Error("no variables");
          } catch (e) {
            variables = {};
          }
          return variables;
        };
        Oas2.prototype.defaultVariables = function(selected) {
          var _this = this;
          if (selected === void 0) {
            selected = 0;
          }
          var variables = this.variables(selected);
          var defaults = {};
          Object.keys(variables).forEach(function(key) {
            defaults[key] = (0, get_user_variable_1["default"])(_this.user, key) || variables[key]["default"] || "";
          });
          return defaults;
        };
        Oas2.prototype.splitUrl = function(selected) {
          if (selected === void 0) {
            selected = 0;
          }
          var url = normalizedUrl(this.api, selected);
          var variables = this.variables(selected);
          return url.split(/({.+?})/).filter(Boolean).map(function(part, i) {
            var isVariable = part.match(/[{}]/);
            var value = part.replace(/[{}]/g, "");
            var key = "".concat(value, "-").concat(i);
            if (!isVariable) {
              return {
                type: "text",
                value,
                key
              };
            }
            var variable = variables === null || variables === void 0 ? void 0 : variables[value];
            return {
              type: "variable",
              value,
              key,
              description: variable === null || variable === void 0 ? void 0 : variable.description,
              "enum": variable === null || variable === void 0 ? void 0 : variable["enum"]
            };
          });
        };
        Oas2.prototype.splitVariables = function(baseUrl) {
          var matchedServer = (this.api.servers || []).map(function(server, i) {
            var rgx = transformUrlIntoRegex(server.url);
            var found = new RegExp(rgx).exec(baseUrl);
            if (!found) {
              return false;
            }
            var variables = {};
            Array.from(server.url.matchAll(SERVER_VARIABLE_REGEX)).forEach(function(variable, y) {
              variables[variable[1]] = found[y + 1];
            });
            return {
              selected: i,
              variables
            };
          }).filter(Boolean);
          return matchedServer.length ? matchedServer[0] : false;
        };
        Oas2.prototype.replaceUrl = function(url, variables) {
          var _this = this;
          if (variables === void 0) {
            variables = {};
          }
          return stripTrailingSlash(url.replace(SERVER_VARIABLE_REGEX, function(original, key) {
            var userVariable = (0, get_user_variable_1["default"])(_this.user, key);
            if (userVariable) {
              return userVariable;
            }
            if (key in variables) {
              var data = variables[key];
              if (typeof data === "object") {
                if (!Array.isArray(data) && data !== null && "default" in data) {
                  return data["default"];
                }
              } else {
                return data;
              }
            }
            return original;
          }));
        };
        Oas2.prototype.operation = function(path, method, opts) {
          var _a, _b, _c, _d;
          if (opts === void 0) {
            opts = {};
          }
          var operation = {
            parameters: []
          };
          if (opts.isWebhook) {
            var api = this.api;
            if ((_a = api === null || api === void 0 ? void 0 : api.webhooks[path]) === null || _a === void 0 ? void 0 : _a[method]) {
              operation = api.webhooks[path][method];
              return new operation_1.Webhook(api, path, method, operation);
            }
          }
          if ((_d = (_c = (_b = this === null || this === void 0 ? void 0 : this.api) === null || _b === void 0 ? void 0 : _b.paths) === null || _c === void 0 ? void 0 : _c[path]) === null || _d === void 0 ? void 0 : _d[method]) {
            operation = this.api.paths[path][method];
          }
          return new operation_1["default"](this.api, path, method, operation);
        };
        Oas2.prototype.findOperationMatches = function(url) {
          var _a;
          var _this = this;
          var _b = new URL(url), origin = _b.origin, hostname = _b.hostname;
          var originRegExp = new RegExp(origin, "i");
          var _c = this.api, servers = _c.servers, paths = _c.paths;
          var pathName;
          var targetServer;
          var matchedServer;
          if (!servers || !servers.length) {
            matchedServer = {
              url: "https://example.com"
            };
          } else {
            matchedServer = servers.find(function(s) {
              return originRegExp.exec(_this.replaceUrl(s.url, s.variables || {}));
            });
            if (!matchedServer) {
              var hostnameRegExp_1 = new RegExp(hostname);
              matchedServer = servers.find(function(s) {
                return hostnameRegExp_1.exec(_this.replaceUrl(s.url, s.variables || {}));
              });
            }
          }
          if (!matchedServer) {
            var matchedServerAndPath = servers.map(function(server) {
              var rgx = transformUrlIntoRegex(server.url);
              var found = new RegExp(rgx).exec(url);
              if (!found) {
                return false;
              }
              return {
                matchedServer: server,
                pathName: url.split(new RegExp(rgx)).slice(-1).pop()
              };
            }).filter(Boolean);
            if (!matchedServerAndPath.length) {
              return void 0;
            }
            pathName = matchedServerAndPath[0].pathName;
            targetServer = __assign({}, matchedServerAndPath[0].matchedServer);
          } else {
            targetServer = __assign(__assign({}, matchedServer), { url: this.replaceUrl(matchedServer.url, matchedServer.variables || {}) });
            _a = url.split(new RegExp(targetServer.url, "i")), pathName = _a[1];
          }
          if (pathName === void 0)
            return void 0;
          if (pathName === "")
            pathName = "/";
          var annotatedPaths = generatePathMatches(paths, pathName, targetServer.url);
          if (!annotatedPaths.length)
            return void 0;
          return annotatedPaths;
        };
        Oas2.prototype.findOperation = function(url, method) {
          var annotatedPaths = this.findOperationMatches(url);
          if (!annotatedPaths) {
            return void 0;
          }
          var matches = filterPathMethods(annotatedPaths, method);
          if (!matches.length)
            return void 0;
          return findTargetPath(matches);
        };
        Oas2.prototype.findOperationWithoutMethod = function(url) {
          var annotatedPaths = this.findOperationMatches(url);
          if (!annotatedPaths) {
            return void 0;
          }
          return findTargetPath(annotatedPaths);
        };
        Oas2.prototype.getOperation = function(url, method) {
          var op = this.findOperation(url, method);
          if (op === void 0) {
            return void 0;
          }
          return this.operation(op.url.nonNormalizedPath, method);
        };
        Oas2.prototype.getAuth = function(user, selectedApp) {
          var _a, _b;
          if (!((_b = (_a = this.api) === null || _a === void 0 ? void 0 : _a.components) === null || _b === void 0 ? void 0 : _b.securitySchemes)) {
            return {};
          }
          return (0, get_auth_1["default"])(this.api, user, selectedApp);
        };
        Oas2.prototype.getPaths = function() {
          var _this = this;
          var paths = {};
          Object.keys(this.api.paths ? this.api.paths : []).forEach(function(path) {
            if (path.startsWith("x-")) {
              return;
            }
            paths[path] = {};
            if ("$ref" in _this.api.paths[path]) {
              _this.api.paths[path] = utils_1["default"].findSchemaDefinition(_this.api.paths[path].$ref, _this.api);
            }
            Object.keys(_this.api.paths[path]).forEach(function(method) {
              if (!utils_1.supportedMethods.has(method))
                return;
              paths[path][method] = _this.operation(path, method);
            });
          });
          return paths;
        };
        Oas2.prototype.getWebhooks = function() {
          var _this = this;
          var webhooks = {};
          var api = this.api;
          Object.keys(api.webhooks ? api.webhooks : []).forEach(function(id) {
            webhooks[id] = {};
            Object.keys(api.webhooks[id]).forEach(function(method) {
              webhooks[id][method] = _this.operation(id, method, { isWebhook: true });
            });
          });
          return webhooks;
        };
        Oas2.prototype.getTags = function(setIfMissing) {
          if (setIfMissing === void 0) {
            setIfMissing = false;
          }
          var allTags = /* @__PURE__ */ new Set();
          Object.entries(this.getPaths()).forEach(function(_a) {
            var path = _a[0], operations = _a[1];
            Object.values(operations).forEach(function(operation) {
              var tags = operation.getTags();
              if (setIfMissing && !tags.length) {
                allTags.add(path);
                return;
              }
              tags.forEach(function(tag) {
                allTags.add(tag.name);
              });
            });
          });
          return Array.from(allTags);
        };
        Oas2.prototype.hasExtension = function(extension) {
          return Boolean(this.api && extension in this.api);
        };
        Oas2.prototype.getExtension = function(extension) {
          var _a;
          return (_a = this.api) === null || _a === void 0 ? void 0 : _a[extension];
        };
        Oas2.prototype.getCircularReferences = function() {
          if (!this.dereferencing.complete) {
            throw new Error("#dereference() must be called first in order for this method to obtain circular references.");
          }
          return this.dereferencing.circularRefs;
        };
        Oas2.prototype.dereference = function(opts) {
          if (opts === void 0) {
            opts = { preserveRefAsJSONSchemaTitle: false };
          }
          return __awaiter(this, void 0, void 0, function() {
            var _a, api, promises, parser;
            var _this = this;
            return __generator(this, function(_b) {
              if (this.dereferencing.complete) {
                return [2, new Promise(function(resolve) {
                  resolve(true);
                })];
              }
              if (this.dereferencing.processing) {
                return [2, new Promise(function(resolve, reject) {
                  _this.promises.push({ resolve, reject });
                })];
              }
              this.dereferencing.processing = true;
              _a = this, api = _a.api, promises = _a.promises;
              if (api && api.components && api.components.schemas && typeof api.components.schemas === "object") {
                Object.keys(api.components.schemas).forEach(function(schemaName) {
                  if (opts.preserveRefAsJSONSchemaTitle) {
                    api.components.schemas[schemaName].title = schemaName;
                  }
                  api.components.schemas[schemaName]["x-readme-ref-name"] = schemaName;
                });
              }
              parser = new json_schema_ref_parser_1["default"]();
              return [2, parser.dereference(api || {}, {
                resolve: {
                  // We shouldn't be resolving external pointers at this point so just ignore them.
                  external: false
                },
                dereference: {
                  // If circular `$refs` are ignored they'll remain in the OAS as `$ref: String`, otherwise
                  // `$ref just won't exist. This allows us to do easy circular reference detection.
                  circular: "ignore"
                }
              }).then(function(dereferenced) {
                var circularRefs = [];
                if (parser.$refs.circular) {
                  circularRefs = parser.$refs.circularRefs.map(function(pointer) {
                    return "#".concat(pointer.split("#")[1]);
                  });
                }
                _this.api = dereferenced;
                _this.promises = promises;
                _this.dereferencing = {
                  processing: false,
                  complete: true,
                  circularRefs
                };
                if (opts.cb) {
                  opts.cb();
                }
              }).then(function() {
                return _this.promises.map(function(deferred) {
                  return deferred.resolve();
                });
              })];
            });
          });
        };
        return Oas2;
      }()
    );
    exports["default"] = Oas;
  }
});

export {
  require_util,
  require_fs,
  require_rmoas_types,
  require_baseMerge,
  require_createAssigner,
  require_dist
};
//# sourceMappingURL=chunk-3IQXWZTV.js.map
