import {
  require_baseMerge,
  require_createAssigner,
  require_dist,
  require_fs,
  require_rmoas_types,
  require_util
} from "./chunk-3IQXWZTV.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "./chunk-EWTE5DHJ.js";

// .api/apis/zklighter/node_modules/@readme/data-urls/dist/index.js
var require_dist2 = __commonJS({
  ".api/apis/zklighter/node_modules/@readme/data-urls/dist/index.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.validate = exports.parse = void 0;
    var DATA_URL_REGEX = (
      // eslint-disable-next-line unicorn/no-unsafe-regex
      /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@/?%\s<>]*?)$/i
    );
    function validate(str) {
      return DATA_URL_REGEX.test((str || "").trim());
    }
    exports.validate = validate;
    function parse(str) {
      if (!validate(str)) {
        return false;
      }
      var parts = str.trim().match(DATA_URL_REGEX);
      var parsed = {};
      if (parts[1]) {
        parsed.mediaType = parts[1].toLowerCase();
        var mediaTypeParts = parts[1].split(";").map(function(x) {
          if (x.startsWith("name=")) {
            return x;
          }
          return x.toLowerCase();
        });
        parsed.contentType = mediaTypeParts[0];
        mediaTypeParts.slice(1).forEach(function(attribute) {
          var p = attribute.split("=");
          parsed[p[0]] = p[1];
        });
      }
      parsed.base64 = !!parts[parts.length - 2];
      parsed.data = parts[parts.length - 1] || "";
      parsed.toBuffer = function() {
        var encoding = parsed.base64 ? "base64" : "utf8";
        return Buffer.from(parsed.data, encoding);
      };
      return parsed;
    }
    exports.parse = parse;
  }
});

// .api/apis/zklighter/node_modules/@readme/oas-extensions/dist/index.js
var require_dist3 = __commonJS({
  ".api/apis/zklighter/node_modules/@readme/oas-extensions/dist/index.js"(exports) {
    "use strict";
    var _a;
    exports.__esModule = true;
    exports.validateExtension = exports.getExtension = exports.defaults = exports.SIMPLE_MODE = exports.SEND_DEFAULTS = exports.SAMPLES_LANGUAGES = exports.SAMPLES_ENABLED = exports.PROXY_ENABLED = exports.METRICS_ENABLED = exports.HEADERS = exports.EXPLORER_ENABLED = exports.CODE_SAMPLES = void 0;
    exports.CODE_SAMPLES = "code-samples";
    exports.EXPLORER_ENABLED = "explorer-enabled";
    exports.HEADERS = "headers";
    exports.METRICS_ENABLED = "metrics-enabled";
    exports.PROXY_ENABLED = "proxy-enabled";
    exports.SAMPLES_ENABLED = "samples-enabled";
    exports.SAMPLES_LANGUAGES = "samples-languages";
    exports.SEND_DEFAULTS = "send-defaults";
    exports.SIMPLE_MODE = "simple-mode";
    exports.defaults = (_a = {}, _a[exports.CODE_SAMPLES] = void 0, _a[exports.EXPLORER_ENABLED] = true, _a[exports.HEADERS] = void 0, _a[exports.METRICS_ENABLED] = true, _a[exports.PROXY_ENABLED] = true, _a[exports.SAMPLES_ENABLED] = true, _a[exports.SAMPLES_LANGUAGES] = ["shell", "node", "ruby", "php", "python", "java", "csharp"], _a[exports.SEND_DEFAULTS] = false, _a[exports.SIMPLE_MODE] = true, _a);
    function getExtension(extension, oas, operation) {
      if (operation) {
        if (operation.hasExtension("x-readme")) {
          var data = operation.getExtension("x-readme");
          if (data && typeof data === "object" && extension in data) {
            return data[extension];
          }
        }
        if (operation.hasExtension("x-".concat(extension))) {
          return operation.getExtension("x-".concat(extension));
        }
      }
      if (extension === exports.CODE_SAMPLES) {
        return exports.defaults[extension];
      }
      if (oas.hasExtension("x-readme")) {
        var data = oas.getExtension("x-readme");
        if (data && typeof data === "object" && extension in data) {
          return data[extension];
        }
      }
      if (oas.hasExtension("x-".concat(extension))) {
        return oas.getExtension("x-".concat(extension));
      }
      return exports.defaults[extension];
    }
    exports.getExtension = getExtension;
    function validateExtension(extension, oas) {
      if (oas.hasExtension("x-readme")) {
        var data = oas.getExtension("x-readme");
        if (typeof data !== "object" || Array.isArray(data) || data === null) {
          throw new TypeError('"x-readme" must be of type "Object"');
        }
        if (extension in data) {
          if ([exports.CODE_SAMPLES, exports.HEADERS, exports.SAMPLES_LANGUAGES].includes(extension)) {
            if (!Array.isArray(data[extension])) {
              throw new TypeError('"x-readme.'.concat(extension, '" must be of type "Array"'));
            }
          } else if (typeof data[extension] !== "boolean") {
            throw new TypeError('"x-readme.'.concat(extension, '" must be of type "Boolean"'));
          }
        }
      }
      if (oas.hasExtension("x-".concat(extension))) {
        var data = oas.getExtension("x-".concat(extension));
        if ([exports.CODE_SAMPLES, exports.HEADERS, exports.SAMPLES_LANGUAGES].includes(extension)) {
          if (!Array.isArray(data)) {
            throw new TypeError('"x-'.concat(extension, '" must be of type "Array"'));
          }
        } else if (typeof data !== "boolean") {
          throw new TypeError('"x-'.concat(extension, '" must be of type "Boolean"'));
        }
      }
    }
    exports.validateExtension = validateExtension;
  }
});

// .api/apis/zklighter/node_modules/remove-undefined-objects/dist/index.js
var require_dist4 = __commonJS({
  ".api/apis/zklighter/node_modules/remove-undefined-objects/dist/index.js"(exports) {
    "use strict";
    exports.__esModule = true;
    function isObject(obj) {
      return typeof obj === "object" && obj !== null && !Array.isArray(obj);
    }
    function isEmptyObject(obj) {
      return typeof obj === "object" && obj !== null && !Object.keys(obj).length;
    }
    function stripEmptyObjects(obj) {
      var cleanObj = obj;
      if (!isObject(obj) && !Array.isArray(cleanObj)) {
        return cleanObj;
      } else if (obj === null) {
        return void 0;
      }
      if (!Array.isArray(cleanObj)) {
        Object.keys(cleanObj).forEach(function(key) {
          var value = cleanObj[key];
          if (typeof value === "object" && value !== null) {
            value = stripEmptyObjects(value);
            if (isEmptyObject(value)) {
              delete cleanObj[key];
            } else {
              cleanObj[key] = value;
            }
          } else if (value === null) {
          }
        });
        return cleanObj;
      }
      cleanObj.forEach(function(o, idx) {
        var value = o;
        if (typeof value === "object" && value !== null) {
          value = stripEmptyObjects(value);
          if (isEmptyObject(value)) {
            delete cleanObj[idx];
          } else {
            cleanObj[idx] = value;
          }
        } else if (value === null) {
          delete cleanObj[idx];
        }
      });
      return cleanObj.filter(function(el) {
        return el !== void 0;
      });
    }
    function removeUndefinedObjects(obj) {
      if (obj === void 0) {
        return void 0;
      }
      var withoutUndefined = JSON.parse(JSON.stringify(obj));
      withoutUndefined = stripEmptyObjects(withoutUndefined);
      if (isEmptyObject(withoutUndefined))
        return void 0;
      return withoutUndefined;
    }
    exports["default"] = removeUndefinedObjects;
  }
});

// .api/apis/zklighter/node_modules/@readme/oas-to-har/dist/lib/configure-security.js
var require_configure_security = __commonJS({
  ".api/apis/zklighter/node_modules/@readme/oas-to-har/dist/lib/configure-security.js"(exports) {
    "use strict";
    exports.__esModule = true;
    var rmoas_types_1 = require_rmoas_types();
    function harValue(type, value) {
      if (!value.value)
        return void 0;
      return { type, value };
    }
    function configureSecurity(apiDefinition, values, scheme) {
      var _a, _b;
      if (!scheme)
        return void 0;
      if (Object.keys(values || {}).length === 0)
        return void 0;
      if (!apiDefinition.components.securitySchemes[scheme])
        return void 0;
      var security = apiDefinition.components.securitySchemes[scheme];
      if ((0, rmoas_types_1.isRef)(security)) {
        return void 0;
      } else if (!values[scheme]) {
        return false;
      }
      if (security.type === "http") {
        if (security.scheme === "basic") {
          var auth = values[scheme];
          if (typeof auth !== "object")
            return false;
          if (!auth.user && !auth.pass)
            return false;
          var user = (_a = auth.user) !== null && _a !== void 0 ? _a : null;
          if (user === null || user.length === 0) {
            user = "";
          }
          var pass = (_b = auth.pass) !== null && _b !== void 0 ? _b : null;
          if (pass === null || pass.length === 0) {
            pass = "";
          }
          return harValue("headers", {
            name: "authorization",
            value: "Basic ".concat(Buffer.from("".concat(user, ":").concat(pass)).toString("base64"))
          });
        } else if (security.scheme === "bearer") {
          return harValue("headers", {
            name: "authorization",
            value: "Bearer ".concat(values[scheme])
          });
        }
      }
      if (security.type === "apiKey") {
        if (security["in"] === "query") {
          return harValue("queryString", {
            name: security.name,
            value: String(values[scheme])
          });
        } else if (security["in"] === "header") {
          var header = {
            name: security.name,
            value: String(values[scheme])
          };
          if (security["x-bearer-format"]) {
            var bearerFormat = security["x-bearer-format"].charAt(0).toUpperCase() + security["x-bearer-format"].slice(1);
            header.name = security.name;
            header.value = "".concat(bearerFormat, " ").concat(header.value);
          }
          return harValue("headers", header);
        } else if (security["in"] === "cookie") {
          return harValue("cookies", {
            name: security.name,
            value: String(values[scheme])
          });
        }
      }
      if (security.type === "oauth2") {
        return harValue("headers", {
          name: "authorization",
          value: "Bearer ".concat(values[scheme])
        });
      }
      return void 0;
    }
    exports["default"] = configureSecurity;
  }
});

// .api/apis/zklighter/node_modules/es-errors/type.js
var require_type = __commonJS({
  ".api/apis/zklighter/node_modules/es-errors/type.js"(exports, module) {
    "use strict";
    module.exports = TypeError;
  }
});

// (disabled):.api/apis/zklighter/node_modules/object-inspect/util.inspect
var require_util2 = __commonJS({
  "(disabled):.api/apis/zklighter/node_modules/object-inspect/util.inspect"() {
  }
});

// .api/apis/zklighter/node_modules/object-inspect/index.js
var require_object_inspect = __commonJS({
  ".api/apis/zklighter/node_modules/object-inspect/index.js"(exports, module) {
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
      return O.__proto__;
    } : null);
    function addNumericSeparator(num, str) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int = num < 0 ? -$floor(-num) : $floor(num);
        if (int !== num) {
          var intStr = String(int);
          var dec = $slice.call(str, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    var utilInspect = require_util2();
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
    var quotes = {
      __proto__: null,
      "double": '"',
      single: "'"
    };
    var quoteREs = {
      __proto__: null,
      "double": /(["\\])/g,
      single: /(['\\])/g
    };
    module.exports = function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (has(opts, "quoteStyle") && !has(quotes, opts.quoteStyle)) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect(value, from, noIndent) {
        if (from) {
          seen = $arrSlice.call(seen);
          seen.push(from);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      if (typeof obj === "function" && !isRegExp(obj)) {
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
      }
      if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement(obj)) {
        var s = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
          s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
        }
        s += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s += "...";
        }
        s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s;
      }
      if (isArray(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
          mapForEach.call(obj, function(value, key) {
            mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
          });
        }
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
      }
      if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
          setForEach.call(obj, function(value) {
            setParts.push(inspect(value, obj));
          });
        }
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
      }
      if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
      }
      if (typeof window !== "undefined" && obj === window) {
        return "{ [object Window] }";
      }
      if (typeof globalThis !== "undefined" && obj === globalThis || typeof global !== "undefined" && obj === global) {
        return "{ [object globalThis] }";
      }
      if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
        if (ys.length === 0) {
          return tag + "{}";
        }
        if (indent) {
          return tag + "{" + indentedJoin(ys, indent) + "}";
        }
        return tag + "{ " + $join.call(ys, ", ") + " }";
      }
      return String(obj);
    };
    function wrapQuotes(s, defaultStyle, opts) {
      var style = opts.quoteStyle || defaultStyle;
      var quoteChar = quotes[style];
      return quoteChar + s + quoteChar;
    }
    function quote(s) {
      return $replace.call(String(s), /"/g, "&quot;");
    }
    function canTrustToString(obj) {
      return !toStringTag || !(typeof obj === "object" && (toStringTag in obj || typeof obj[toStringTag] !== "undefined"));
    }
    function isArray(obj) {
      return toStr(obj) === "[object Array]" && canTrustToString(obj);
    }
    function isDate(obj) {
      return toStr(obj) === "[object Date]" && canTrustToString(obj);
    }
    function isRegExp(obj) {
      return toStr(obj) === "[object RegExp]" && canTrustToString(obj);
    }
    function isError(obj) {
      return toStr(obj) === "[object Error]" && canTrustToString(obj);
    }
    function isString(obj) {
      return toStr(obj) === "[object String]" && canTrustToString(obj);
    }
    function isNumber(obj) {
      return toStr(obj) === "[object Number]" && canTrustToString(obj);
    }
    function isBoolean(obj) {
      return toStr(obj) === "[object Boolean]" && canTrustToString(obj);
    }
    function isSymbol(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    var hasOwn = Object.prototype.hasOwnProperty || function(key) {
      return key in this;
    };
    function has(obj, key) {
      return hasOwn.call(obj, key);
    }
    function toStr(obj) {
      return objectToString.call(obj);
    }
    function nameOf(f) {
      if (f.name) {
        return f.name;
      }
      var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
      if (m) {
        return m[1];
      }
      return null;
    }
    function indexOf(xs, x) {
      if (xs.indexOf) {
        return xs.indexOf(x);
      }
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) {
          return i;
        }
      }
      return -1;
    }
    function isMap(x) {
      if (!mapSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        mapSize.call(x);
        try {
          setSize.call(x);
        } catch (s) {
          return true;
        }
        return x instanceof Map;
      } catch (e) {
      }
      return false;
    }
    function isWeakMap(x) {
      if (!weakMapHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x, weakMapHas);
        try {
          weakSetHas.call(x, weakSetHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakMap;
      } catch (e) {
      }
      return false;
    }
    function isWeakRef(x) {
      if (!weakRefDeref || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isSet(x) {
      if (!setSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        setSize.call(x);
        try {
          mapSize.call(x);
        } catch (m) {
          return true;
        }
        return x instanceof Set;
      } catch (e) {
      }
      return false;
    }
    function isWeakSet(x) {
      if (!weakSetHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x, weakSetHas);
        try {
          weakMapHas.call(x, weakMapHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakSet;
      } catch (e) {
      }
      return false;
    }
    function isElement(x) {
      if (!x || typeof x !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
        return true;
      }
      return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
    }
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
      }
      var quoteRE = quoteREs[opts.quoteStyle || "single"];
      quoteRE.lastIndex = 0;
      var s = $replace.call($replace.call(str, quoteRE, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s, "single", opts);
    }
    function lowbyte(c) {
      var n = c.charCodeAt(0);
      var x = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n];
      if (x) {
        return "\\" + x;
      }
      return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
    }
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    function weakCollectionOf(type) {
      return type + " { ? }";
    }
    function collectionOf(type, size, entries, indent) {
      var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
      return type + " (" + size + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
      for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    function indentedJoin(xs, indent) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
    }
    function arrObjKeys(obj, inspect) {
      var isArr = isArray(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
          xs[i] = has(obj, i) ? inspect(obj[i], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
          symMap["$" + syms[k]] = syms[k];
        }
      }
      for (var key in obj) {
        if (!has(obj, key)) {
          continue;
        }
        if (isArr && String(Number(key)) === key && key < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key)) {
          xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
        } else {
          xs.push(key + ": " + inspect(obj[key], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j = 0; j < syms.length; j++) {
          if (isEnumerable.call(obj, syms[j])) {
            xs.push("[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj));
          }
        }
      }
      return xs;
    }
  }
});

// .api/apis/zklighter/node_modules/side-channel-list/index.js
var require_side_channel_list = __commonJS({
  ".api/apis/zklighter/node_modules/side-channel-list/index.js"(exports, module) {
    "use strict";
    var inspect = require_object_inspect();
    var $TypeError = require_type();
    var listGetNode = function(list, key, isDelete) {
      var prev = list;
      var curr;
      for (; (curr = prev.next) != null; prev = curr) {
        if (curr.key === key) {
          prev.next = curr.next;
          if (!isDelete) {
            curr.next = /** @type {NonNullable<typeof list.next>} */
            list.next;
            list.next = curr;
          }
          return curr;
        }
      }
    };
    var listGet = function(objects, key) {
      if (!objects) {
        return void 0;
      }
      var node = listGetNode(objects, key);
      return node && node.value;
    };
    var listSet = function(objects, key, value) {
      var node = listGetNode(objects, key);
      if (node) {
        node.value = value;
      } else {
        objects.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */
        {
          // eslint-disable-line no-param-reassign, no-extra-parens
          key,
          next: objects.next,
          value
        };
      }
    };
    var listHas = function(objects, key) {
      if (!objects) {
        return false;
      }
      return !!listGetNode(objects, key);
    };
    var listDelete = function(objects, key) {
      if (objects) {
        return listGetNode(objects, key, true);
      }
    };
    module.exports = function getSideChannelList() {
      var $o;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        },
        "delete": function(key) {
          var root = $o && $o.next;
          var deletedNode = listDelete($o, key);
          if (deletedNode && root && root === deletedNode) {
            $o = void 0;
          }
          return !!deletedNode;
        },
        get: function(key) {
          return listGet($o, key);
        },
        has: function(key) {
          return listHas($o, key);
        },
        set: function(key, value) {
          if (!$o) {
            $o = {
              next: void 0
            };
          }
          listSet(
            /** @type {NonNullable<typeof $o>} */
            $o,
            key,
            value
          );
        }
      };
      return channel;
    };
  }
});

// .api/apis/zklighter/node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS({
  ".api/apis/zklighter/node_modules/es-object-atoms/index.js"(exports, module) {
    "use strict";
    module.exports = Object;
  }
});

// .api/apis/zklighter/node_modules/es-errors/index.js
var require_es_errors = __commonJS({
  ".api/apis/zklighter/node_modules/es-errors/index.js"(exports, module) {
    "use strict";
    module.exports = Error;
  }
});

// .api/apis/zklighter/node_modules/es-errors/eval.js
var require_eval = __commonJS({
  ".api/apis/zklighter/node_modules/es-errors/eval.js"(exports, module) {
    "use strict";
    module.exports = EvalError;
  }
});

// .api/apis/zklighter/node_modules/es-errors/range.js
var require_range = __commonJS({
  ".api/apis/zklighter/node_modules/es-errors/range.js"(exports, module) {
    "use strict";
    module.exports = RangeError;
  }
});

// .api/apis/zklighter/node_modules/es-errors/ref.js
var require_ref = __commonJS({
  ".api/apis/zklighter/node_modules/es-errors/ref.js"(exports, module) {
    "use strict";
    module.exports = ReferenceError;
  }
});

// .api/apis/zklighter/node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  ".api/apis/zklighter/node_modules/es-errors/syntax.js"(exports, module) {
    "use strict";
    module.exports = SyntaxError;
  }
});

// .api/apis/zklighter/node_modules/es-errors/uri.js
var require_uri = __commonJS({
  ".api/apis/zklighter/node_modules/es-errors/uri.js"(exports, module) {
    "use strict";
    module.exports = URIError;
  }
});

// .api/apis/zklighter/node_modules/math-intrinsics/abs.js
var require_abs = __commonJS({
  ".api/apis/zklighter/node_modules/math-intrinsics/abs.js"(exports, module) {
    "use strict";
    module.exports = Math.abs;
  }
});

// .api/apis/zklighter/node_modules/math-intrinsics/floor.js
var require_floor = __commonJS({
  ".api/apis/zklighter/node_modules/math-intrinsics/floor.js"(exports, module) {
    "use strict";
    module.exports = Math.floor;
  }
});

// .api/apis/zklighter/node_modules/math-intrinsics/max.js
var require_max = __commonJS({
  ".api/apis/zklighter/node_modules/math-intrinsics/max.js"(exports, module) {
    "use strict";
    module.exports = Math.max;
  }
});

// .api/apis/zklighter/node_modules/math-intrinsics/min.js
var require_min = __commonJS({
  ".api/apis/zklighter/node_modules/math-intrinsics/min.js"(exports, module) {
    "use strict";
    module.exports = Math.min;
  }
});

// .api/apis/zklighter/node_modules/math-intrinsics/pow.js
var require_pow = __commonJS({
  ".api/apis/zklighter/node_modules/math-intrinsics/pow.js"(exports, module) {
    "use strict";
    module.exports = Math.pow;
  }
});

// .api/apis/zklighter/node_modules/math-intrinsics/round.js
var require_round = __commonJS({
  ".api/apis/zklighter/node_modules/math-intrinsics/round.js"(exports, module) {
    "use strict";
    module.exports = Math.round;
  }
});

// .api/apis/zklighter/node_modules/math-intrinsics/isNaN.js
var require_isNaN = __commonJS({
  ".api/apis/zklighter/node_modules/math-intrinsics/isNaN.js"(exports, module) {
    "use strict";
    module.exports = Number.isNaN || function isNaN2(a) {
      return a !== a;
    };
  }
});

// .api/apis/zklighter/node_modules/math-intrinsics/sign.js
var require_sign = __commonJS({
  ".api/apis/zklighter/node_modules/math-intrinsics/sign.js"(exports, module) {
    "use strict";
    var $isNaN = require_isNaN();
    module.exports = function sign(number) {
      if ($isNaN(number) || number === 0) {
        return number;
      }
      return number < 0 ? -1 : 1;
    };
  }
});

// .api/apis/zklighter/node_modules/gopd/gOPD.js
var require_gOPD = __commonJS({
  ".api/apis/zklighter/node_modules/gopd/gOPD.js"(exports, module) {
    "use strict";
    module.exports = Object.getOwnPropertyDescriptor;
  }
});

// .api/apis/zklighter/node_modules/gopd/index.js
var require_gopd = __commonJS({
  ".api/apis/zklighter/node_modules/gopd/index.js"(exports, module) {
    "use strict";
    var $gOPD = require_gOPD();
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module.exports = $gOPD;
  }
});

// .api/apis/zklighter/node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  ".api/apis/zklighter/node_modules/es-define-property/index.js"(exports, module) {
    "use strict";
    var $defineProperty = Object.defineProperty || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = false;
      }
    }
    module.exports = $defineProperty;
  }
});

// .api/apis/zklighter/node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  ".api/apis/zklighter/node_modules/has-symbols/shams.js"(exports, module) {
    "use strict";
    module.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (var _ in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = (
          /** @type {PropertyDescriptor} */
          Object.getOwnPropertyDescriptor(obj, sym)
        );
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// .api/apis/zklighter/node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  ".api/apis/zklighter/node_modules/has-symbols/index.js"(exports, module) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// .api/apis/zklighter/node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = __commonJS({
  ".api/apis/zklighter/node_modules/get-proto/Reflect.getPrototypeOf.js"(exports, module) {
    "use strict";
    module.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  }
});

// .api/apis/zklighter/node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = __commonJS({
  ".api/apis/zklighter/node_modules/get-proto/Object.getPrototypeOf.js"(exports, module) {
    "use strict";
    var $Object = require_es_object_atoms();
    module.exports = $Object.getPrototypeOf || null;
  }
});

// .api/apis/zklighter/node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  ".api/apis/zklighter/node_modules/function-bind/implementation.js"(exports, module) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a, b) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// .api/apis/zklighter/node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  ".api/apis/zklighter/node_modules/function-bind/index.js"(exports, module) {
    "use strict";
    var implementation = require_implementation();
    module.exports = Function.prototype.bind || implementation;
  }
});

// .api/apis/zklighter/node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = __commonJS({
  ".api/apis/zklighter/node_modules/call-bind-apply-helpers/functionCall.js"(exports, module) {
    "use strict";
    module.exports = Function.prototype.call;
  }
});

// .api/apis/zklighter/node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = __commonJS({
  ".api/apis/zklighter/node_modules/call-bind-apply-helpers/functionApply.js"(exports, module) {
    "use strict";
    module.exports = Function.prototype.apply;
  }
});

// .api/apis/zklighter/node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = __commonJS({
  ".api/apis/zklighter/node_modules/call-bind-apply-helpers/reflectApply.js"(exports, module) {
    "use strict";
    module.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  }
});

// .api/apis/zklighter/node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = __commonJS({
  ".api/apis/zklighter/node_modules/call-bind-apply-helpers/actualApply.js"(exports, module) {
    "use strict";
    var bind = require_function_bind();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var $reflectApply = require_reflectApply();
    module.exports = $reflectApply || bind.call($call, $apply);
  }
});

// .api/apis/zklighter/node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = __commonJS({
  ".api/apis/zklighter/node_modules/call-bind-apply-helpers/index.js"(exports, module) {
    "use strict";
    var bind = require_function_bind();
    var $TypeError = require_type();
    var $call = require_functionCall();
    var $actualApply = require_actualApply();
    module.exports = function callBindBasic(args) {
      if (args.length < 1 || typeof args[0] !== "function") {
        throw new $TypeError("a function is required");
      }
      return $actualApply(bind, $call, args);
    };
  }
});

// .api/apis/zklighter/node_modules/dunder-proto/get.js
var require_get = __commonJS({
  ".api/apis/zklighter/node_modules/dunder-proto/get.js"(exports, module) {
    "use strict";
    var callBind = require_call_bind_apply_helpers();
    var gOPD = require_gopd();
    var hasProtoAccessor;
    try {
      hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
      [].__proto__ === Array.prototype;
    } catch (e) {
      if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
        throw e;
      }
    }
    var desc = !!hasProtoAccessor && gOPD && gOPD(
      Object.prototype,
      /** @type {keyof typeof Object.prototype} */
      "__proto__"
    );
    var $Object = Object;
    var $getPrototypeOf = $Object.getPrototypeOf;
    module.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
      /** @type {import('./get')} */
      function getDunder(value) {
        return $getPrototypeOf(value == null ? value : $Object(value));
      }
    ) : false;
  }
});

// .api/apis/zklighter/node_modules/get-proto/index.js
var require_get_proto = __commonJS({
  ".api/apis/zklighter/node_modules/get-proto/index.js"(exports, module) {
    "use strict";
    var reflectGetProto = require_Reflect_getPrototypeOf();
    var originalGetProto = require_Object_getPrototypeOf();
    var getDunderProto = require_get();
    module.exports = reflectGetProto ? function getProto(O) {
      return reflectGetProto(O);
    } : originalGetProto ? function getProto(O) {
      if (!O || typeof O !== "object" && typeof O !== "function") {
        throw new TypeError("getProto: not an object");
      }
      return originalGetProto(O);
    } : getDunderProto ? function getProto(O) {
      return getDunderProto(O);
    } : null;
  }
});

// .api/apis/zklighter/node_modules/hasown/index.js
var require_hasown = __commonJS({
  ".api/apis/zklighter/node_modules/hasown/index.js"(exports, module) {
    "use strict";
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module.exports = bind.call(call, $hasOwn);
  }
});

// .api/apis/zklighter/node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  ".api/apis/zklighter/node_modules/get-intrinsic/index.js"(exports, module) {
    "use strict";
    var undefined2;
    var $Object = require_es_object_atoms();
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range();
    var $ReferenceError = require_ref();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var $URIError = require_uri();
    var abs = require_abs();
    var floor = require_floor();
    var max = require_max();
    var min = require_min();
    var pow = require_pow();
    var round = require_round();
    var sign = require_sign();
    var $Function = Function;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = require_gopd();
    var $defineProperty = require_es_define_property();
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = require_get_proto();
    var $ObjectGPO = require_Object_getPrototypeOf();
    var $ReflectGPO = require_Reflect_getPrototypeOf();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float16Array%": typeof Float16Array === "undefined" ? undefined2 : Float16Array,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": $Object,
      "%Object.getOwnPropertyDescriptor%": $gOPD,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
      "%Function.prototype.call%": $call,
      "%Function.prototype.apply%": $apply,
      "%Object.defineProperty%": $defineProperty,
      "%Object.getPrototypeOf%": $ObjectGPO,
      "%Math.abs%": abs,
      "%Math.floor%": floor,
      "%Math.max%": max,
      "%Math.min%": min,
      "%Math.pow%": pow,
      "%Math.round%": round,
      "%Math.sign%": sign,
      "%Reflect.getPrototypeOf%": $ReflectGPO
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind.call($call, Array.prototype.concat);
    var $spliceApply = bind.call($apply, Array.prototype.splice);
    var $replace = bind.call($call, String.prototype.replace);
    var $strSlice = bind.call($call, String.prototype.slice);
    var $exec = bind.call($call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// .api/apis/zklighter/node_modules/call-bound/index.js
var require_call_bound = __commonJS({
  ".api/apis/zklighter/node_modules/call-bound/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBindBasic = require_call_bind_apply_helpers();
    var $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
    module.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = (
        /** @type {(this: unknown, ...args: unknown[]) => unknown} */
        GetIntrinsic(name, !!allowMissing)
      );
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBindBasic(
          /** @type {const} */
          [intrinsic]
        );
      }
      return intrinsic;
    };
  }
});

// .api/apis/zklighter/node_modules/side-channel-map/index.js
var require_side_channel_map = __commonJS({
  ".api/apis/zklighter/node_modules/side-channel-map/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_call_bound();
    var inspect = require_object_inspect();
    var $TypeError = require_type();
    var $Map = GetIntrinsic("%Map%", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSet = callBound("Map.prototype.set", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var $mapDelete = callBound("Map.prototype.delete", true);
    var $mapSize = callBound("Map.prototype.size", true);
    module.exports = !!$Map && /** @type {Exclude<import('.'), false>} */
    function getSideChannelMap() {
      var $m;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        },
        "delete": function(key) {
          if ($m) {
            var result = $mapDelete($m, key);
            if ($mapSize($m) === 0) {
              $m = void 0;
            }
            return result;
          }
          return false;
        },
        get: function(key) {
          if ($m) {
            return $mapGet($m, key);
          }
        },
        has: function(key) {
          if ($m) {
            return $mapHas($m, key);
          }
          return false;
        },
        set: function(key, value) {
          if (!$m) {
            $m = new $Map();
          }
          $mapSet($m, key, value);
        }
      };
      return channel;
    };
  }
});

// .api/apis/zklighter/node_modules/side-channel-weakmap/index.js
var require_side_channel_weakmap = __commonJS({
  ".api/apis/zklighter/node_modules/side-channel-weakmap/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_call_bound();
    var inspect = require_object_inspect();
    var getSideChannelMap = require_side_channel_map();
    var $TypeError = require_type();
    var $WeakMap = GetIntrinsic("%WeakMap%", true);
    var $weakMapGet = callBound("WeakMap.prototype.get", true);
    var $weakMapSet = callBound("WeakMap.prototype.set", true);
    var $weakMapHas = callBound("WeakMap.prototype.has", true);
    var $weakMapDelete = callBound("WeakMap.prototype.delete", true);
    module.exports = $WeakMap ? (
      /** @type {Exclude<import('.'), false>} */
      function getSideChannelWeakMap() {
        var $wm;
        var $m;
        var channel = {
          assert: function(key) {
            if (!channel.has(key)) {
              throw new $TypeError("Side channel does not contain " + inspect(key));
            }
          },
          "delete": function(key) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if ($wm) {
                return $weakMapDelete($wm, key);
              }
            } else if (getSideChannelMap) {
              if ($m) {
                return $m["delete"](key);
              }
            }
            return false;
          },
          get: function(key) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if ($wm) {
                return $weakMapGet($wm, key);
              }
            }
            return $m && $m.get(key);
          },
          has: function(key) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if ($wm) {
                return $weakMapHas($wm, key);
              }
            }
            return !!$m && $m.has(key);
          },
          set: function(key, value) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if (!$wm) {
                $wm = new $WeakMap();
              }
              $weakMapSet($wm, key, value);
            } else if (getSideChannelMap) {
              if (!$m) {
                $m = getSideChannelMap();
              }
              $m.set(key, value);
            }
          }
        };
        return channel;
      }
    ) : getSideChannelMap;
  }
});

// .api/apis/zklighter/node_modules/side-channel/index.js
var require_side_channel = __commonJS({
  ".api/apis/zklighter/node_modules/side-channel/index.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var inspect = require_object_inspect();
    var getSideChannelList = require_side_channel_list();
    var getSideChannelMap = require_side_channel_map();
    var getSideChannelWeakMap = require_side_channel_weakmap();
    var makeChannel = getSideChannelWeakMap || getSideChannelMap || getSideChannelList;
    module.exports = function getSideChannel() {
      var $channelData;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        },
        "delete": function(key) {
          return !!$channelData && $channelData["delete"](key);
        },
        get: function(key) {
          return $channelData && $channelData.get(key);
        },
        has: function(key) {
          return !!$channelData && $channelData.has(key);
        },
        set: function(key, value) {
          if (!$channelData) {
            $channelData = makeChannel();
          }
          $channelData.set(key, value);
        }
      };
      return channel;
    };
  }
});

// .api/apis/zklighter/node_modules/qs/lib/formats.js
var require_formats = __commonJS({
  ".api/apis/zklighter/node_modules/qs/lib/formats.js"(exports, module) {
    "use strict";
    var replace = String.prototype.replace;
    var percentTwenties = /%20/g;
    var Format = {
      RFC1738: "RFC1738",
      RFC3986: "RFC3986"
    };
    module.exports = {
      "default": Format.RFC3986,
      formatters: {
        RFC1738: function(value) {
          return replace.call(value, percentTwenties, "+");
        },
        RFC3986: function(value) {
          return String(value);
        }
      },
      RFC1738: Format.RFC1738,
      RFC3986: Format.RFC3986
    };
  }
});

// .api/apis/zklighter/node_modules/qs/lib/utils.js
var require_utils = __commonJS({
  ".api/apis/zklighter/node_modules/qs/lib/utils.js"(exports, module) {
    "use strict";
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var hexTable = function() {
      var array = [];
      for (var i = 0; i < 256; ++i) {
        array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
      }
      return array;
    }();
    var compactQueue = function compactQueue2(queue) {
      while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];
        if (isArray(obj)) {
          var compacted = [];
          for (var j = 0; j < obj.length; ++j) {
            if (typeof obj[j] !== "undefined") {
              compacted.push(obj[j]);
            }
          }
          item.obj[item.prop] = compacted;
        }
      }
    };
    var arrayToObject = function arrayToObject2(source, options) {
      var obj = options && options.plainObjects ? { __proto__: null } : {};
      for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== "undefined") {
          obj[i] = source[i];
        }
      }
      return obj;
    };
    var merge = function merge2(target, source, options) {
      if (!source) {
        return target;
      }
      if (typeof source !== "object" && typeof source !== "function") {
        if (isArray(target)) {
          target.push(source);
        } else if (target && typeof target === "object") {
          if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
            target[source] = true;
          }
        } else {
          return [target, source];
        }
        return target;
      }
      if (!target || typeof target !== "object") {
        return [target].concat(source);
      }
      var mergeTarget = target;
      if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
      }
      if (isArray(target) && isArray(source)) {
        source.forEach(function(item, i) {
          if (has.call(target, i)) {
            var targetItem = target[i];
            if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
              target[i] = merge2(targetItem, item, options);
            } else {
              target.push(item);
            }
          } else {
            target[i] = item;
          }
        });
        return target;
      }
      return Object.keys(source).reduce(function(acc, key) {
        var value = source[key];
        if (has.call(acc, key)) {
          acc[key] = merge2(acc[key], value, options);
        } else {
          acc[key] = value;
        }
        return acc;
      }, mergeTarget);
    };
    var assign = function assignSingleSource(target, source) {
      return Object.keys(source).reduce(function(acc, key) {
        acc[key] = source[key];
        return acc;
      }, target);
    };
    var decode2 = function(str, defaultDecoder, charset) {
      var strWithoutPlus = str.replace(/\+/g, " ");
      if (charset === "iso-8859-1") {
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
      }
      try {
        return decodeURIComponent(strWithoutPlus);
      } catch (e) {
        return strWithoutPlus;
      }
    };
    var limit = 1024;
    var encode = function encode2(str, defaultEncoder, charset, kind, format) {
      if (str.length === 0) {
        return str;
      }
      var string = str;
      if (typeof str === "symbol") {
        string = Symbol.prototype.toString.call(str);
      } else if (typeof str !== "string") {
        string = String(str);
      }
      if (charset === "iso-8859-1") {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
          return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
        });
      }
      var out = "";
      for (var j = 0; j < string.length; j += limit) {
        var segment = string.length >= limit ? string.slice(j, j + limit) : string;
        var arr = [];
        for (var i = 0; i < segment.length; ++i) {
          var c = segment.charCodeAt(i);
          if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format === formats.RFC1738 && (c === 40 || c === 41)) {
            arr[arr.length] = segment.charAt(i);
            continue;
          }
          if (c < 128) {
            arr[arr.length] = hexTable[c];
            continue;
          }
          if (c < 2048) {
            arr[arr.length] = hexTable[192 | c >> 6] + hexTable[128 | c & 63];
            continue;
          }
          if (c < 55296 || c >= 57344) {
            arr[arr.length] = hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
            continue;
          }
          i += 1;
          c = 65536 + ((c & 1023) << 10 | segment.charCodeAt(i) & 1023);
          arr[arr.length] = hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
        }
        out += arr.join("");
      }
      return out;
    };
    var compact = function compact2(value) {
      var queue = [{ obj: { o: value }, prop: "o" }];
      var refs = [];
      for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];
        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
          var key = keys[j];
          var val = obj[key];
          if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
            queue.push({ obj, prop: key });
            refs.push(val);
          }
        }
      }
      compactQueue(queue);
      return value;
    };
    var isRegExp = function isRegExp2(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    };
    var isBuffer = function isBuffer2(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    };
    var combine = function combine2(a, b) {
      return [].concat(a, b);
    };
    var maybeMap = function maybeMap2(val, fn) {
      if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
          mapped.push(fn(val[i]));
        }
        return mapped;
      }
      return fn(val);
    };
    module.exports = {
      arrayToObject,
      assign,
      combine,
      compact,
      decode: decode2,
      encode,
      isBuffer,
      isRegExp,
      maybeMap,
      merge
    };
  }
});

// .api/apis/zklighter/node_modules/qs/lib/stringify.js
var require_stringify = __commonJS({
  ".api/apis/zklighter/node_modules/qs/lib/stringify.js"(exports, module) {
    "use strict";
    var getSideChannel = require_side_channel();
    var utils = require_utils();
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var arrayPrefixGenerators = {
      brackets: function brackets(prefix) {
        return prefix + "[]";
      },
      comma: "comma",
      indices: function indices(prefix, key) {
        return prefix + "[" + key + "]";
      },
      repeat: function repeat(prefix) {
        return prefix;
      }
    };
    var isArray = Array.isArray;
    var push = Array.prototype.push;
    var pushToArray = function(arr, valueOrArray) {
      push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
    };
    var toISO = Date.prototype.toISOString;
    var defaultFormat = formats["default"];
    var defaults = {
      addQueryPrefix: false,
      allowDots: false,
      allowEmptyArrays: false,
      arrayFormat: "indices",
      charset: "utf-8",
      charsetSentinel: false,
      commaRoundTrip: false,
      delimiter: "&",
      encode: true,
      encodeDotInKeys: false,
      encoder: utils.encode,
      encodeValuesOnly: false,
      filter: void 0,
      format: defaultFormat,
      formatter: formats.formatters[defaultFormat],
      // deprecated
      indices: false,
      serializeDate: function serializeDate(date) {
        return toISO.call(date);
      },
      skipNulls: false,
      strictNullHandling: false
    };
    var isNonNullishPrimitive = function isNonNullishPrimitive2(v) {
      return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
    };
    var sentinel = {};
    var stringify = function stringify2(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
      var obj = object;
      var tmpSc = sideChannel;
      var step = 0;
      var findFlag = false;
      while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== "undefined") {
          if (pos === step) {
            throw new RangeError("Cyclic object value");
          } else {
            findFlag = true;
          }
        }
        if (typeof tmpSc.get(sentinel) === "undefined") {
          step = 0;
        }
      }
      if (typeof filter === "function") {
        obj = filter(prefix, obj);
      } else if (obj instanceof Date) {
        obj = serializeDate(obj);
      } else if (generateArrayPrefix === "comma" && isArray(obj)) {
        obj = utils.maybeMap(obj, function(value2) {
          if (value2 instanceof Date) {
            return serializeDate(value2);
          }
          return value2;
        });
      }
      if (obj === null) {
        if (strictNullHandling) {
          return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, "key", format) : prefix;
        }
        obj = "";
      }
      if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
          var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format);
          return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder, charset, "value", format))];
        }
        return [formatter(prefix) + "=" + formatter(String(obj))];
      }
      var values = [];
      if (typeof obj === "undefined") {
        return values;
      }
      var objKeys;
      if (generateArrayPrefix === "comma" && isArray(obj)) {
        if (encodeValuesOnly && encoder) {
          obj = utils.maybeMap(obj, encoder);
        }
        objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
      } else if (isArray(filter)) {
        objKeys = filter;
      } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
      }
      var encodedPrefix = encodeDotInKeys ? String(prefix).replace(/\./g, "%2E") : String(prefix);
      var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encodedPrefix + "[]" : encodedPrefix;
      if (allowEmptyArrays && isArray(obj) && obj.length === 0) {
        return adjustedPrefix + "[]";
      }
      for (var j = 0; j < objKeys.length; ++j) {
        var key = objKeys[j];
        var value = typeof key === "object" && key && typeof key.value !== "undefined" ? key.value : obj[key];
        if (skipNulls && value === null) {
          continue;
        }
        var encodedKey = allowDots && encodeDotInKeys ? String(key).replace(/\./g, "%2E") : String(key);
        var keyPrefix = isArray(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + encodedKey : "[" + encodedKey + "]");
        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify2(
          value,
          keyPrefix,
          generateArrayPrefix,
          commaRoundTrip,
          allowEmptyArrays,
          strictNullHandling,
          skipNulls,
          encodeDotInKeys,
          generateArrayPrefix === "comma" && encodeValuesOnly && isArray(obj) ? null : encoder,
          filter,
          sort,
          allowDots,
          serializeDate,
          format,
          formatter,
          encodeValuesOnly,
          charset,
          valueSideChannel
        ));
      }
      return values;
    };
    var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
        throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
      }
      if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
        throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
      }
      if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
        throw new TypeError("Encoder has to be a function.");
      }
      var charset = opts.charset || defaults.charset;
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var format = formats["default"];
      if (typeof opts.format !== "undefined") {
        if (!has.call(formats.formatters, opts.format)) {
          throw new TypeError("Unknown format option provided.");
        }
        format = opts.format;
      }
      var formatter = formats.formatters[format];
      var filter = defaults.filter;
      if (typeof opts.filter === "function" || isArray(opts.filter)) {
        filter = opts.filter;
      }
      var arrayFormat;
      if (opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
      } else if ("indices" in opts) {
        arrayFormat = opts.indices ? "indices" : "repeat";
      } else {
        arrayFormat = defaults.arrayFormat;
      }
      if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
        throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
      }
      var allowDots = typeof opts.allowDots === "undefined" ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
      return {
        addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        arrayFormat,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        commaRoundTrip: !!opts.commaRoundTrip,
        delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
        encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
        encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter,
        format,
        formatter,
        serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === "function" ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module.exports = function(object, opts) {
      var obj = object;
      var options = normalizeStringifyOptions(opts);
      var objKeys;
      var filter;
      if (typeof options.filter === "function") {
        filter = options.filter;
        obj = filter("", obj);
      } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
      }
      var keys = [];
      if (typeof obj !== "object" || obj === null) {
        return "";
      }
      var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
      var commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
      if (!objKeys) {
        objKeys = Object.keys(obj);
      }
      if (options.sort) {
        objKeys.sort(options.sort);
      }
      var sideChannel = getSideChannel();
      for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];
        var value = obj[key];
        if (options.skipNulls && value === null) {
          continue;
        }
        pushToArray(keys, stringify(
          value,
          key,
          generateArrayPrefix,
          commaRoundTrip,
          options.allowEmptyArrays,
          options.strictNullHandling,
          options.skipNulls,
          options.encodeDotInKeys,
          options.encode ? options.encoder : null,
          options.filter,
          options.sort,
          options.allowDots,
          options.serializeDate,
          options.format,
          options.formatter,
          options.encodeValuesOnly,
          options.charset,
          sideChannel
        ));
      }
      var joined = keys.join(options.delimiter);
      var prefix = options.addQueryPrefix === true ? "?" : "";
      if (options.charsetSentinel) {
        if (options.charset === "iso-8859-1") {
          prefix += "utf8=%26%2310003%3B&";
        } else {
          prefix += "utf8=%E2%9C%93&";
        }
      }
      return joined.length > 0 ? prefix + joined : "";
    };
  }
});

// .api/apis/zklighter/node_modules/qs/lib/parse.js
var require_parse = __commonJS({
  ".api/apis/zklighter/node_modules/qs/lib/parse.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var defaults = {
      allowDots: false,
      allowEmptyArrays: false,
      allowPrototypes: false,
      allowSparse: false,
      arrayLimit: 20,
      charset: "utf-8",
      charsetSentinel: false,
      comma: false,
      decodeDotInKeys: false,
      decoder: utils.decode,
      delimiter: "&",
      depth: 5,
      duplicates: "combine",
      ignoreQueryPrefix: false,
      interpretNumericEntities: false,
      parameterLimit: 1e3,
      parseArrays: true,
      plainObjects: false,
      strictDepth: false,
      strictNullHandling: false,
      throwOnLimitExceeded: false
    };
    var interpretNumericEntities = function(str) {
      return str.replace(/&#(\d+);/g, function($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
      });
    };
    var parseArrayValue = function(val, options, currentArrayLength) {
      if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
        return val.split(",");
      }
      if (options.throwOnLimitExceeded && currentArrayLength >= options.arrayLimit) {
        throw new RangeError("Array limit exceeded. Only " + options.arrayLimit + " element" + (options.arrayLimit === 1 ? "" : "s") + " allowed in an array.");
      }
      return val;
    };
    var isoSentinel = "utf8=%26%2310003%3B";
    var charsetSentinel = "utf8=%E2%9C%93";
    var parseValues = function parseQueryStringValues(str, options) {
      var obj = { __proto__: null };
      var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
      cleanStr = cleanStr.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
      var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
      var parts = cleanStr.split(
        options.delimiter,
        options.throwOnLimitExceeded ? limit + 1 : limit
      );
      if (options.throwOnLimitExceeded && parts.length > limit) {
        throw new RangeError("Parameter limit exceeded. Only " + limit + " parameter" + (limit === 1 ? "" : "s") + " allowed.");
      }
      var skipIndex = -1;
      var i;
      var charset = options.charset;
      if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
          if (parts[i].indexOf("utf8=") === 0) {
            if (parts[i] === charsetSentinel) {
              charset = "utf-8";
            } else if (parts[i] === isoSentinel) {
              charset = "iso-8859-1";
            }
            skipIndex = i;
            i = parts.length;
          }
        }
      }
      for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
          continue;
        }
        var part = parts[i];
        var bracketEqualsPos = part.indexOf("]=");
        var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
        var key;
        var val;
        if (pos === -1) {
          key = options.decoder(part, defaults.decoder, charset, "key");
          val = options.strictNullHandling ? null : "";
        } else {
          key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
          val = utils.maybeMap(
            parseArrayValue(
              part.slice(pos + 1),
              options,
              isArray(obj[key]) ? obj[key].length : 0
            ),
            function(encodedVal) {
              return options.decoder(encodedVal, defaults.decoder, charset, "value");
            }
          );
        }
        if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
          val = interpretNumericEntities(String(val));
        }
        if (part.indexOf("[]=") > -1) {
          val = isArray(val) ? [val] : val;
        }
        var existing = has.call(obj, key);
        if (existing && options.duplicates === "combine") {
          obj[key] = utils.combine(obj[key], val);
        } else if (!existing || options.duplicates === "last") {
          obj[key] = val;
        }
      }
      return obj;
    };
    var parseObject = function(chain, val, options, valuesParsed) {
      var currentArrayLength = 0;
      if (chain.length > 0 && chain[chain.length - 1] === "[]") {
        var parentKey = chain.slice(0, -1).join("");
        currentArrayLength = Array.isArray(val) && val[parentKey] ? val[parentKey].length : 0;
      }
      var leaf = valuesParsed ? val : parseArrayValue(val, options, currentArrayLength);
      for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];
        if (root === "[]" && options.parseArrays) {
          obj = options.allowEmptyArrays && (leaf === "" || options.strictNullHandling && leaf === null) ? [] : utils.combine([], leaf);
        } else {
          obj = options.plainObjects ? { __proto__: null } : {};
          var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
          var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, ".") : cleanRoot;
          var index = parseInt(decodedRoot, 10);
          if (!options.parseArrays && decodedRoot === "") {
            obj = { 0: leaf };
          } else if (!isNaN(index) && root !== decodedRoot && String(index) === decodedRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
            obj = [];
            obj[index] = leaf;
          } else if (decodedRoot !== "__proto__") {
            obj[decodedRoot] = leaf;
          }
        }
        leaf = obj;
      }
      return leaf;
    };
    var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
      if (!givenKey) {
        return;
      }
      var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
      var brackets = /(\[[^[\]]*])/;
      var child = /(\[[^[\]]*])/g;
      var segment = options.depth > 0 && brackets.exec(key);
      var parent = segment ? key.slice(0, segment.index) : key;
      var keys = [];
      if (parent) {
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(parent);
      }
      var i = 0;
      while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(segment[1]);
      }
      if (segment) {
        if (options.strictDepth === true) {
          throw new RangeError("Input depth exceeded depth option of " + options.depth + " and strictDepth is true");
        }
        keys.push("[" + key.slice(segment.index) + "]");
      }
      return parseObject(keys, val, options, valuesParsed);
    };
    var normalizeParseOptions = function normalizeParseOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
        throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
      }
      if (typeof opts.decodeDotInKeys !== "undefined" && typeof opts.decodeDotInKeys !== "boolean") {
        throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
      }
      if (opts.decoder !== null && typeof opts.decoder !== "undefined" && typeof opts.decoder !== "function") {
        throw new TypeError("Decoder has to be a function.");
      }
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      if (typeof opts.throwOnLimitExceeded !== "undefined" && typeof opts.throwOnLimitExceeded !== "boolean") {
        throw new TypeError("`throwOnLimitExceeded` option must be a boolean");
      }
      var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
      var duplicates = typeof opts.duplicates === "undefined" ? defaults.duplicates : opts.duplicates;
      if (duplicates !== "combine" && duplicates !== "first" && duplicates !== "last") {
        throw new TypeError("The duplicates option must be either combine, first, or last");
      }
      var allowDots = typeof opts.allowDots === "undefined" ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
      return {
        allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
        decodeDotInKeys: typeof opts.decodeDotInKeys === "boolean" ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
        decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
        duplicates,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
        strictDepth: typeof opts.strictDepth === "boolean" ? !!opts.strictDepth : defaults.strictDepth,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling,
        throwOnLimitExceeded: typeof opts.throwOnLimitExceeded === "boolean" ? opts.throwOnLimitExceeded : false
      };
    };
    module.exports = function(str, opts) {
      var options = normalizeParseOptions(opts);
      if (str === "" || str === null || typeof str === "undefined") {
        return options.plainObjects ? { __proto__: null } : {};
      }
      var tempObj = typeof str === "string" ? parseValues(str, options) : str;
      var obj = options.plainObjects ? { __proto__: null } : {};
      var keys = Object.keys(tempObj);
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
        obj = utils.merge(obj, newObj, options);
      }
      if (options.allowSparse === true) {
        return obj;
      }
      return utils.compact(obj);
    };
  }
});

// .api/apis/zklighter/node_modules/qs/lib/index.js
var require_lib = __commonJS({
  ".api/apis/zklighter/node_modules/qs/lib/index.js"(exports, module) {
    "use strict";
    var stringify = require_stringify();
    var parse = require_parse();
    var formats = require_formats();
    module.exports = {
      formats,
      parse,
      stringify
    };
  }
});

// .api/apis/zklighter/node_modules/@readme/oas-to-har/dist/lib/style-formatting/style-serializer.js
var require_style_serializer = __commonJS({
  ".api/apis/zklighter/node_modules/@readme/oas-to-har/dist/lib/style-formatting/style-serializer.js"(exports, module) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    exports.__esModule = true;
    exports.encodeDisallowedCharacters = void 0;
    var isRfc3986Reserved = function(char) {
      return ":/?#[]@!$&'()*+,;=".indexOf(char) > -1;
    };
    var isRfc3986Unreserved = function(char) {
      return /^[a-z0-9\-._~]+$/i.test(char);
    };
    function isURIEncoded(value) {
      try {
        return decodeURIComponent(value) !== value;
      } catch (err) {
        return false;
      }
    }
    function isObject(value) {
      return typeof value === "object" && value !== null;
    }
    function stylize(config) {
      var value = config.value;
      if (Array.isArray(value)) {
        return encodeArray(config);
      }
      if (isObject(value)) {
        return encodeObject(config);
      }
      return encodePrimitive(config);
    }
    exports["default"] = stylize;
    function encodeDisallowedCharacters(str, _a, parse) {
      var _b = _a === void 0 ? {} : _a, escape2 = _b.escape, _c = _b.returnIfEncoded, returnIfEncoded = _c === void 0 ? false : _c, isAllowedReserved = _b.isAllowedReserved;
      if (typeof str === "number") {
        str = str.toString();
      }
      if (returnIfEncoded) {
        if (isURIEncoded(str)) {
          return str;
        }
      }
      if (typeof str !== "string" || !str.length) {
        return str;
      }
      if (!escape2) {
        return str;
      }
      if (parse) {
        return JSON.parse(str);
      }
      return __spreadArray([], __read(str), false).map(function(char) {
        if (isRfc3986Unreserved(char)) {
          return char;
        }
        if (isRfc3986Reserved(char) && (escape2 === "unsafe" || isAllowedReserved)) {
          return char;
        }
        var encoder = new TextEncoder();
        var encoded = Array.from(encoder.encode(char)).map(function(byte) {
          return "0".concat(byte.toString(16).toUpperCase()).slice(-2);
        }).map(function(encodedByte) {
          return "%".concat(encodedByte);
        }).join("");
        return encoded;
      }).join("");
    }
    exports.encodeDisallowedCharacters = encodeDisallowedCharacters;
    function encodeArray(_a) {
      var location = _a.location, key = _a.key, value = _a.value, style = _a.style, explode = _a.explode, escape2 = _a.escape, _b = _a.isAllowedReserved, isAllowedReserved = _b === void 0 ? false : _b;
      var valueEncoder = function(str) {
        return module.exports.encodeDisallowedCharacters(str, {
          escape: escape2,
          returnIfEncoded: location === "query",
          isAllowedReserved
        });
      };
      switch (style) {
        case "simple":
          return value.map(function(val) {
            return valueEncoder(val);
          }).join(",");
        case "label":
          return ".".concat(value.map(function(val) {
            return valueEncoder(val);
          }).join("."));
        case "matrix":
          return value.map(function(val) {
            return valueEncoder(val);
          }).reduce(function(prev, curr) {
            if (!prev || explode) {
              return "".concat(prev || "", ";").concat(key, "=").concat(curr);
            }
            return "".concat(prev, ",").concat(curr);
          }, "");
        case "form":
          return value.map(function(val) {
            return valueEncoder(val);
          }).join(explode ? "&".concat(key, "=") : ",");
        case "spaceDelimited":
          return value.map(function(val) {
            return valueEncoder(val);
          }).join(" ".concat(explode ? "".concat(key, "=") : ""));
        case "pipeDelimited":
          return value.map(function(val) {
            return valueEncoder(val);
          }).join("|".concat(explode ? "".concat(key, "=") : ""));
        default:
          return void 0;
      }
    }
    function encodeObject(_a) {
      var location = _a.location, key = _a.key, value = _a.value, style = _a.style, explode = _a.explode, escape2 = _a.escape, _b = _a.isAllowedReserved, isAllowedReserved = _b === void 0 ? false : _b;
      var valueEncoder = function(str) {
        return module.exports.encodeDisallowedCharacters(str, {
          escape: escape2,
          returnIfEncoded: location === "query",
          isAllowedReserved
        });
      };
      var valueKeys = Object.keys(value);
      switch (style) {
        case "simple":
          return valueKeys.reduce(function(prev, curr) {
            var val = valueEncoder(value[curr]);
            var middleChar = explode ? "=" : ",";
            var prefix = prev ? "".concat(prev, ",") : "";
            return "".concat(prefix).concat(curr).concat(middleChar).concat(val);
          }, "");
        case "label":
          return valueKeys.reduce(function(prev, curr) {
            var val = valueEncoder(value[curr]);
            var middleChar = explode ? "=" : ".";
            var prefix = prev ? "".concat(prev, ".") : ".";
            return "".concat(prefix).concat(curr).concat(middleChar).concat(val);
          }, "");
        case "matrix":
          if (explode) {
            return valueKeys.reduce(function(prev, curr) {
              var val = valueEncoder(value[curr]);
              var prefix = prev ? "".concat(prev, ";") : ";";
              return "".concat(prefix).concat(curr, "=").concat(val);
            }, "");
          }
          return valueKeys.reduce(function(prev, curr) {
            var val = valueEncoder(value[curr]);
            var prefix = prev ? "".concat(prev, ",") : ";".concat(key, "=");
            return "".concat(prefix).concat(curr, ",").concat(val);
          }, "");
        case "form":
          return valueKeys.reduce(function(prev, curr) {
            var val = valueEncoder(value[curr]);
            var prefix = prev ? "".concat(prev).concat(explode ? "&" : ",") : "";
            var separator = explode ? "=" : ",";
            return "".concat(prefix).concat(curr).concat(separator).concat(val);
          }, "");
        case "spaceDelimited":
          return valueKeys.reduce(function(prev, curr) {
            var val = valueEncoder(value[curr]);
            var prefix = prev ? "".concat(prev, " ") : "";
            return "".concat(prefix).concat(curr, " ").concat(val);
          }, "");
        case "pipeDelimited":
          return valueKeys.reduce(function(prev, curr) {
            var val = valueEncoder(value[curr]);
            var prefix = prev ? "".concat(prev, "|") : "";
            return "".concat(prefix).concat(curr, "|").concat(val);
          }, "");
        case "deepObject":
          return valueKeys.reduce(function(curr) {
            var val = valueEncoder(value[curr]);
            return "".concat(val);
          }, "");
        default:
          return void 0;
      }
    }
    function encodePrimitive(_a) {
      var location = _a.location, key = _a.key, value = _a.value, style = _a.style, escape2 = _a.escape, _b = _a.isAllowedReserved, isAllowedReserved = _b === void 0 ? false : _b;
      var valueEncoder = function(str) {
        return module.exports.encodeDisallowedCharacters(str, {
          escape: escape2,
          returnIfEncoded: location === "query" || location === "body",
          isAllowedReserved
        });
      };
      switch (style) {
        case "simple":
          return valueEncoder(value);
        case "label":
          return ".".concat(valueEncoder(value));
        case "matrix":
          if (value === "") {
            return ";".concat(key);
          }
          return ";".concat(key, "=").concat(valueEncoder(value));
        case "form":
          return valueEncoder(value);
        case "deepObject":
          return valueEncoder(value);
        default:
          return void 0;
      }
    }
  }
});

// .api/apis/zklighter/node_modules/@readme/oas-to-har/dist/lib/style-formatting/index.js
var require_style_formatting = __commonJS({
  ".api/apis/zklighter/node_modules/@readme/oas-to-har/dist/lib/style-formatting/index.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    exports.__esModule = true;
    var qs_1 = __importDefault(require_lib());
    var style_serializer_1 = __importDefault(require_style_serializer());
    function shouldNotStyleEmptyValues(parameter) {
      return ["simple", "spaceDelimited", "pipeDelimited", "deepObject"].includes(parameter.style);
    }
    function shouldNotStyleReservedHeader(parameter) {
      return ["accept", "authorization", "content-type"].includes(parameter.name.toLowerCase());
    }
    function removeUndefinedForPath(value) {
      var finalValue = value;
      if (typeof finalValue === "undefined") {
        return "";
      }
      if (Array.isArray(finalValue)) {
        finalValue = finalValue.filter(function(val) {
          return val === void 0 ? "" : val;
        });
        if (finalValue.length === 0) {
          finalValue = "";
        }
      }
      if (typeof finalValue === "object") {
        Object.keys(finalValue).forEach(function(key) {
          finalValue[key] = finalValue[key] === void 0 ? "" : finalValue[key];
        });
      }
      return finalValue;
    }
    function stylizeValue(value, parameter) {
      var finalValue = value;
      if (shouldNotStyleEmptyValues(parameter) && (typeof finalValue === "undefined" || finalValue === "")) {
        if (parameter["in"] === "path") {
          return "";
        }
        return void 0;
      }
      if (parameter["in"] === "path") {
        finalValue = removeUndefinedForPath(finalValue);
      }
      if (parameter["in"] === "header" && shouldNotStyleReservedHeader(parameter)) {
        return value;
      }
      var style = parameter.style;
      if (!style) {
        if (parameter["in"] === "query") {
          style = "form";
        } else if (parameter["in"] === "path") {
          style = "simple";
        } else if (parameter["in"] === "header") {
          style = "simple";
        } else if (parameter["in"] === "cookie") {
          style = "form";
        }
      }
      var explode = parameter.explode;
      if (explode === void 0 && style === "form") {
        explode = true;
      }
      return (0, style_serializer_1["default"])(__assign({
        location: parameter["in"],
        value: finalValue,
        key: parameter.name,
        style,
        explode,
        /**
         * @todo this parameter is optional to stylize. It defaults to false, and can accept falsy, truthy, or "unsafe".
         *  I do not know if it is correct for query to use this. See style-serializer for more info
         */
        escape: true
      }, parameter["in"] === "query" ? { isAllowedReserved: parameter.allowReserved || false } : {}));
    }
    function handleDeepObject(value, parameter) {
      return qs_1["default"].stringify(value, {
        // eslint-disable-next-line consistent-return
        encoder: function(str, defaultEncoder, charset, type) {
          if (type === "key") {
            var prefixedKey = str.split(/[[\]]/g).filter(Boolean).map(function(k) {
              return "[".concat(k, "]");
            }).join("");
            return "".concat(parameter.name).concat(prefixedKey);
          } else if (type === "value") {
            return stylizeValue(str, parameter);
          }
        }
      }).split("&").map(function(item) {
        var split = item.split("=");
        return {
          label: split[0],
          // `qs` will coerce null values into being `undefined` string but we want to preserve them.
          value: split[1] === "undefined" ? null : split[1]
        };
      });
    }
    function handleExplode(value, parameter) {
      var _a;
      if (Array.isArray(value) && ((_a = parameter.schema) === null || _a === void 0 ? void 0 : _a.type) === "array" && parameter.style === "deepObject") {
        var newObj_1 = {};
        var deepObjs = handleDeepObject(value, parameter);
        deepObjs.forEach(function(obj) {
          newObj_1[obj.label] = obj.value;
        });
        return newObj_1;
      }
      if (Array.isArray(value)) {
        return value.map(function(val) {
          return stylizeValue(val, parameter);
        });
      }
      if (typeof value === "object" && value !== null) {
        var newObj_2 = {};
        Object.keys(value).forEach(function(key) {
          if (parameter.style === "deepObject") {
            var deepObjs2 = handleDeepObject(value, parameter);
            deepObjs2.forEach(function(obj) {
              newObj_2[obj.label] = obj.value;
            });
          } else {
            newObj_2[key] = stylizeValue(value[key], parameter);
          }
        });
        return newObj_2;
      }
      return stylizeValue(value, parameter);
    }
    function shouldExplode(parameter) {
      return (parameter.explode || parameter.explode !== false && parameter.style === "form") && // header and path doesn't explode into separate parameters like query and cookie do
      parameter["in"] !== "header" && parameter["in"] !== "path";
    }
    function formatStyle(value, parameter) {
      if (parameter.style === "deepObject" && (!value || typeof value !== "object" || parameter.explode === false)) {
        return void 0;
      }
      if (shouldExplode(parameter)) {
        return handleExplode(value, parameter);
      }
      return stylizeValue(value, parameter);
    }
    exports["default"] = formatStyle;
  }
});

// .api/apis/zklighter/node_modules/@readme/oas-to-har/dist/index.js
var require_dist5 = __commonJS({
  ".api/apis/zklighter/node_modules/@readme/oas-to-har/dist/index.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    exports.__esModule = true;
    var data_urls_1 = require_dist2();
    var extensions = __importStar(require_dist3());
    var oas_1 = require_dist();
    var rmoas_types_1 = require_rmoas_types();
    var remove_undefined_objects_1 = __importDefault(require_dist4());
    var configure_security_1 = __importDefault(require_configure_security());
    var style_formatting_1 = __importDefault(require_style_formatting());
    var jsonSchemaTypes = oas_1.utils.jsonSchemaTypes;
    var matchesMimeType = oas_1.utils.matchesMimeType;
    function formatter(values, param, type, onlyIfExists) {
      if (onlyIfExists === void 0) {
        onlyIfExists = false;
      }
      if (param.style) {
        var value_1 = values[type][param.name];
        return (0, style_formatting_1["default"])(value_1, param);
      }
      var value;
      if (typeof values[type][param.name] !== "undefined") {
        value = values[type][param.name];
      } else if (onlyIfExists && !param.required) {
        value = void 0;
      } else if (param.required && param.schema && !(0, rmoas_types_1.isRef)(param.schema) && param.schema["default"]) {
        value = param.schema["default"];
      } else if (type === "path") {
        return param.name;
      }
      if (param.schema && !(0, rmoas_types_1.isRef)(param.schema) && param.schema.type === "array" && param.schema.items && !(0, rmoas_types_1.isRef)(param.schema.items) && param.schema.items.format === "binary") {
        if (Array.isArray(value)) {
          return value;
        }
        return JSON.stringify(value);
      }
      if (value !== void 0) {
        if (type === "query") {
          return (0, style_formatting_1["default"])(value, param);
        }
        return value;
      }
      return void 0;
    }
    function multipartBodyToFormatterParams(multipartBody, oasMediaTypeObject) {
      var schema = oasMediaTypeObject.schema;
      var encoding = oasMediaTypeObject.encoding;
      if (typeof multipartBody === "object" && multipartBody !== null) {
        return Object.keys(multipartBody).map(function(key) {
          if (!schema.properties[key]) {
            return false;
          }
          var paramEncoding = encoding ? encoding[key] : void 0;
          return {
            name: key,
            // If the style isn't defined, use the default
            style: paramEncoding ? paramEncoding.style : void 0,
            // If explode isn't defined, use the default
            explode: paramEncoding ? paramEncoding.explode : void 0,
            required: schema.required && typeof schema.required === "boolean" && Boolean(schema.required) || Array.isArray(schema.required) && schema.required.includes(key),
            schema: schema.properties[key],
            "in": "body"
          };
        }).filter(Boolean);
      }
      return [];
    }
    var defaultFormDataTypes = Object.keys(jsonSchemaTypes).reduce(function(prev, curr) {
      var _a;
      return Object.assign(prev, (_a = {}, _a[curr] = {}, _a));
    }, {});
    function getResponseContentType(content) {
      var types = Object.keys(content) || [];
      if (types && types.length) {
        var jsonType = types.find(function(t) {
          return matchesMimeType.json(t);
        });
        if (jsonType) {
          return jsonType;
        }
        return types[0];
      }
      return "application/json";
    }
    function isPrimitive(val) {
      return typeof val === "string" || typeof val === "number" || typeof val === "boolean";
    }
    function stringify(json) {
      return JSON.stringify((0, remove_undefined_objects_1["default"])(typeof json.RAW_BODY !== "undefined" ? json.RAW_BODY : json));
    }
    function stringifyParameter(param) {
      if (param === null || isPrimitive(param)) {
        return param;
      } else if (Array.isArray(param) && param.every(isPrimitive)) {
        return String(param);
      }
      return JSON.stringify(param);
    }
    function appendHarValue(harParam, name, value, addtlData) {
      if (addtlData === void 0) {
        addtlData = {};
      }
      if (typeof value === "undefined")
        return;
      if (Array.isArray(value)) {
        value.forEach(function(singleValue) {
          appendHarValue(harParam, name, singleValue);
        });
      } else if (typeof value === "object" && value !== null) {
        Object.keys(value).forEach(function(key) {
          appendHarValue(harParam, key, value[key]);
        });
      } else {
        harParam.push(__assign(__assign({}, addtlData), { name, value: String(value) }));
      }
    }
    function encodeBodyForHAR(body) {
      if (isPrimitive(body)) {
        return body;
      } else if (typeof body === "object" && body !== null && !Array.isArray(body) && typeof body.RAW_BODY !== "undefined") {
        if (isPrimitive(body.RAW_BODY)) {
          return body.RAW_BODY;
        }
        return stringify(body.RAW_BODY);
      }
      return stringify(body);
    }
    function oasToHar(oas, operationSchema, values, auth, opts) {
      var _a;
      if (values === void 0) {
        values = {};
      }
      if (auth === void 0) {
        auth = {};
      }
      if (opts === void 0) {
        opts = {
          // If true, the operation URL will be rewritten and prefixed with https://try.readme.io/ in
          // order to funnel requests through our CORS-friendly proxy.
          proxyUrl: false
        };
      }
      var operation;
      if (!operationSchema || typeof operationSchema.getParameters !== "function") {
        operation = new oas_1.Operation(oas, (operationSchema === null || operationSchema === void 0 ? void 0 : operationSchema.path) || "", (operationSchema === null || operationSchema === void 0 ? void 0 : operationSchema.method) || "", operationSchema || { path: "", method: "" });
      } else {
        operation = operationSchema;
      }
      var apiDefinition = oas.getDefinition();
      var formData = __assign(__assign(__assign({}, defaultFormDataTypes), { server: {
        selected: 0,
        variables: oas.defaultVariables(0)
      } }), values);
      formData.server.variables = __assign(__assign({}, oas.defaultVariables(formData.server.selected)), formData.server.variables ? formData.server.variables : {});
      var har = {
        cookies: [],
        headers: [],
        headersSize: 0,
        queryString: [],
        // @ts-expect-error This is fine because we're fleshing `postData` out further down.
        postData: {},
        bodySize: 0,
        method: operation.method.toUpperCase(),
        url: "".concat(oas.url(formData.server.selected, formData.server.variables)).concat(operation.path).replace(/\s/g, "%20"),
        httpVersion: "HTTP/1.1"
      };
      if (opts.proxyUrl) {
        if (extensions.getExtension(extensions.PROXY_ENABLED, oas, operation)) {
          har.url = "https://try.readme.io/".concat(har.url);
        }
      }
      var parameters = operation.getParameters();
      har.url = har.url.replace(/{([-_a-zA-Z0-9[\]]+)}/g, function(full, key) {
        if (!operation || !parameters)
          return key;
        var parameter = parameters.find(function(param) {
          return param.name === key;
        }) || { name: key };
        if (!("style" in parameter) || !parameter.style) {
          return encodeURIComponent(formatter(formData, parameter, "path"));
        }
        return formatter(formData, parameter, "path");
      });
      var queryStrings = parameters && parameters.filter(function(param) {
        return param["in"] === "query";
      });
      if (queryStrings && queryStrings.length) {
        queryStrings.forEach(function(queryString) {
          var value = formatter(formData, queryString, "query", true);
          appendHarValue(har.queryString, queryString.name, value);
        });
      }
      var cookies = parameters && parameters.filter(function(param) {
        return param["in"] === "cookie";
      });
      if (cookies && cookies.length) {
        cookies.forEach(function(cookie) {
          var value = formatter(formData, cookie, "cookie", true);
          appendHarValue(har.cookies, cookie.name, value);
        });
      }
      if (operation.schema.responses) {
        Object.keys(operation.schema.responses).some(function(response) {
          if ((0, rmoas_types_1.isRef)(operation.schema.responses[response]))
            return false;
          var content = operation.schema.responses[response].content;
          if (!content)
            return false;
          if (Object.keys(formData.header).find(function(h) {
            return h.toLowerCase() === "accept";
          }))
            return true;
          har.headers.push({
            name: "accept",
            value: getResponseContentType(content)
          });
          return true;
        });
      }
      var hasContentType = false;
      var contentType = operation.getContentType();
      var headers = parameters && parameters.filter(function(param) {
        return param["in"] === "header";
      });
      if (headers && headers.length) {
        headers.forEach(function(header) {
          var value = formatter(formData, header, "header", true);
          if (typeof value === "undefined")
            return;
          if (header.name.toLowerCase() === "content-type") {
            hasContentType = true;
            contentType = String(value);
          }
          appendHarValue(har.headers, header.name, value);
        });
      }
      var userDefinedHeaders = extensions.getExtension(extensions.HEADERS, oas, operation);
      if (userDefinedHeaders) {
        userDefinedHeaders.forEach(function(header) {
          if (typeof header.key === "string" && header.key.toLowerCase() === "content-type") {
            hasContentType = true;
            contentType = String(header.value);
          }
          har.headers.push({
            name: String(header.key),
            value: String(header.value)
          });
        });
      }
      if (formData.header) {
        var acceptHeader = Object.keys(formData.header).find(function(h) {
          return h.toLowerCase() === "accept";
        });
        if (acceptHeader && !har.headers.find(function(hdr) {
          return hdr.name.toLowerCase() === "accept";
        })) {
          har.headers.push({
            name: "accept",
            value: String(formData.header[acceptHeader])
          });
        }
        var authorizationHeader = Object.keys(formData.header).find(function(h) {
          return h.toLowerCase() === "authorization";
        });
        if (authorizationHeader && !har.headers.find(function(hdr) {
          return hdr.name.toLowerCase() === "authorization";
        })) {
          har.headers.push({
            name: "authorization",
            value: String(formData.header[authorizationHeader])
          });
        }
      }
      var requestBody;
      if (operation.hasRequestBody()) {
        _a = __read(operation.getRequestBody(), 2), requestBody = _a[1];
      }
      if (requestBody && requestBody.schema && Object.keys(requestBody.schema).length) {
        var requestBodySchema_1 = requestBody.schema;
        if (operation.isFormUrlEncoded()) {
          if (Object.keys(formData.formData).length) {
            var cleanFormData_1 = (0, remove_undefined_objects_1["default"])(JSON.parse(JSON.stringify(formData.formData)));
            if (cleanFormData_1 !== void 0) {
              har.postData.params = [];
              har.postData.mimeType = "application/x-www-form-urlencoded";
              Object.keys(cleanFormData_1).forEach(function(name) {
                har.postData.params.push({
                  name,
                  value: stringifyParameter(cleanFormData_1[name])
                });
              });
            }
          }
        } else if ("body" in formData && formData.body !== void 0 && (isPrimitive(formData.body) || Object.keys(formData.body).length)) {
          var isMultipart = operation.isMultipart();
          var isJSON = operation.isJson();
          if (isMultipart || isJSON) {
            try {
              var cleanBody_1 = (0, remove_undefined_objects_1["default"])(JSON.parse(JSON.stringify(formData.body)));
              if (isMultipart) {
                har.postData.mimeType = "multipart/form-data";
                har.postData.params = [];
                var binaryTypes_1 = Object.keys(requestBodySchema_1.properties).filter(function(key) {
                  var propData = requestBodySchema_1.properties[key];
                  if (propData.format === "binary") {
                    return true;
                  } else if (propData.type === "array" && propData.items && typeof propData.items === "object" && propData.items !== null && propData.items.format === "binary") {
                    return true;
                  }
                  return false;
                });
                if (cleanBody_1 !== void 0) {
                  var multipartParams_1 = multipartBodyToFormatterParams(formData.body, operation.schema.requestBody.content["multipart/form-data"]);
                  Object.keys(cleanBody_1).forEach(function(name) {
                    var param = multipartParams_1.find(function(multipartParam) {
                      return multipartParam.name === name;
                    });
                    var addtlData = {};
                    var value = formatter(formData, param, "body", true);
                    if (!Array.isArray(value)) {
                      value = [value];
                    }
                    value.forEach(function(val) {
                      if (binaryTypes_1.includes(name)) {
                        var parsed = (0, data_urls_1.parse)(val);
                        if (parsed) {
                          addtlData.fileName = "name" in parsed ? parsed.name : "unknown";
                          if ("contentType" in parsed) {
                            addtlData.contentType = parsed.contentType;
                          }
                        }
                      }
                      appendHarValue(har.postData.params, name, val, addtlData);
                    });
                  });
                }
              } else {
                har.postData.mimeType = contentType;
                if (requestBody.schema.type === "string") {
                  har.postData.text = JSON.stringify(JSON.parse(cleanBody_1));
                } else {
                  var jsonTypes = Object.keys(requestBodySchema_1.properties).filter(function(key) {
                    var propData = requestBodySchema_1.properties[key];
                    return propData.format === "json" && cleanBody_1[key] !== void 0;
                  });
                  if (jsonTypes.length) {
                    try {
                      jsonTypes.forEach(function(prop) {
                        try {
                          cleanBody_1[prop] = JSON.parse(cleanBody_1[prop]);
                        } catch (e) {
                        }
                      });
                      if (typeof cleanBody_1.RAW_BODY !== "undefined") {
                        cleanBody_1 = cleanBody_1.RAW_BODY;
                      }
                      har.postData.text = JSON.stringify(cleanBody_1);
                    } catch (e) {
                      har.postData.text = stringify(formData.body);
                    }
                  } else {
                    har.postData.text = encodeBodyForHAR(formData.body);
                  }
                }
              }
            } catch (e) {
              har.postData.text = stringify(formData.body);
            }
          } else {
            har.postData.mimeType = contentType;
            har.postData.text = encodeBodyForHAR(formData.body);
          }
        }
      }
      if ((har.postData.text || requestBody && requestBody.schema && Object.keys(requestBody.schema).length) && !hasContentType) {
        har.headers.push({
          name: "content-type",
          value: contentType
        });
      }
      var securityRequirements = operation.getSecurity();
      if (securityRequirements && securityRequirements.length) {
        securityRequirements.forEach(function(schemes) {
          Object.keys(schemes).forEach(function(security) {
            var securityValue = (0, configure_security_1["default"])(apiDefinition, auth, security);
            if (!securityValue) {
              return;
            }
            if (securityValue.value.name === "authorization") {
              if (har[securityValue.type].find(function(v) {
                return v.name === securityValue.value.name;
              })) {
                return;
              }
            }
            if (har[securityValue.type].find(function(v) {
              return v.name === securityValue.value.name && v.value === securityValue.value.value;
            })) {
              return;
            }
            har[securityValue.type].push(securityValue.value);
          });
        });
      }
      if (Object.keys(har.postData).length === 0) {
        delete har.postData;
      }
      return {
        log: {
          entries: [
            {
              request: har
            }
          ]
        }
      };
    }
    exports["default"] = oasToHar;
  }
});

// browser-external:events
var require_events = __commonJS({
  "browser-external:events"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "events" has been externalized for browser compatibility. Cannot access "events.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// .api/apis/zklighter/node_modules/readable-stream/lib/internal/streams/stream-browser.js
var require_stream_browser = __commonJS({
  ".api/apis/zklighter/node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
    module.exports = require_events().EventEmitter;
  }
});

// .api/apis/zklighter/node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  ".api/apis/zklighter/node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// .api/apis/zklighter/node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  ".api/apis/zklighter/node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
  }
});

// .api/apis/zklighter/node_modules/buffer/index.js
var require_buffer = __commonJS({
  ".api/apis/zklighter/node_modules/buffer/index.js"(exports) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer2;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1);
        var proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this)) return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this)) return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      var buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function Buffer2(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer2.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      var valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length);
      }
      var b = fromObject(value);
      if (b) return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(
          value[Symbol.toPrimitive]("string"),
          encodingOrOffset,
          length
        );
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      var length = byteLength(string, encoding) | 0;
      var buf = createBuffer(length);
      var actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      var buf = createBuffer(length);
      for (var i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      var buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer2.alloc(+length);
    }
    Buffer2.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer2.prototype;
    };
    Buffer2.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array)) a = Buffer2.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array)) b = Buffer2.from(b, b.offset, b.byteLength);
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b) return 0;
      var x = a.length;
      var y = b.length;
      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      var i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      var buffer = Buffer2.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            Buffer2.from(buf).copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer2.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      var len = string.length;
      var mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0;
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      var loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding) encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b, n, m) {
      var i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer2.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString() {
      var length = this.length;
      if (length === 0) return "";
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals(b) {
      if (!Buffer2.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
      if (this === b) return true;
      return Buffer2.compare(this, b) === 0;
    };
    Buffer2.prototype.inspect = function inspect() {
      var str = "";
      var max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max) str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      var i;
      if (dir) {
        var foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          var found = true;
          for (var j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found) return i;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      var strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer2.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0) encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining) length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding) encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];
      var i = start;
      while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      var res = "";
      var i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      var len = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      var out = "";
      for (var i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = "";
      for (var i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start) end = start;
      var newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
      if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      var val = this[offset + --byteLength2];
      var mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      var i = byteLength2;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128)) return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer2.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var mul = 1;
      var i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
      if (value < 0) value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0) value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
      if (offset < 0) throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target)) throw new TypeError("argument should be a Buffer");
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;
      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
      if (end < 0) throw new RangeError("sourceEnd out of bounds");
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val) val = 0;
      var i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        var len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2) return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];
      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0) break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0) break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0) break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      var c, hi, lo;
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      var alphabet = "0123456789abcdef";
      var table = new Array(256);
      for (var i = 0; i < 16; ++i) {
        var i16 = i * 16;
        for (var j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
  }
});

// .api/apis/zklighter/node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  ".api/apis/zklighter/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
    "use strict";
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require = require_buffer();
    var Buffer2 = _require.Buffer;
    var _require2 = require_util();
    var inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer2.prototype.copy.call(src, target, offset);
    }
    module.exports = function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0) this.tail.next = entry;
          else this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0) this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0) return;
          var ret = this.head.data;
          if (this.length === 1) this.head = this.tail = null;
          else this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s) {
          if (this.length === 0) return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next) ret += s + p.data;
          return ret;
        }
      }, {
        key: "concat",
        value: function concat(n) {
          if (this.length === 0) return Buffer2.alloc(0);
          var ret = Buffer2.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n, hasStrings) {
          var ret;
          if (n < this.head.data.length) {
            ret = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n) {
          var p = this.head;
          var c = 1;
          var ret = p.data;
          n -= ret.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length) ret += str;
            else ret += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next) this.head = p.next;
                else this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n) {
          var ret = Buffer2.allocUnsafe(n);
          var p = this.head;
          var c = 1;
          p.data.copy(ret);
          n -= p.data.length;
          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret, ret.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf.length) {
                ++c;
                if (p.next) this.head = p.next;
                else this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value(_, options) {
          return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
  }
});

// .api/apis/zklighter/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  ".api/apis/zklighter/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
    "use strict";
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose) return;
      if (self2._readableState && !self2._readableState.emitClose) return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);
      else stream.emit("error", err);
    }
    module.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// .api/apis/zklighter/node_modules/readable-stream/errors-browser.js
var require_errors_browser = __commonJS({
  ".api/apis/zklighter/node_modules/readable-stream/errors-browser.js"(exports, module) {
    "use strict";
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      var NodeError = function(_Base) {
        _inheritsLoose(NodeError2, _Base);
        function NodeError2(arg1, arg2, arg3) {
          return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
        }
        return NodeError2;
      }(Base);
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i) {
          return String(i);
        });
        if (len > 2) {
          return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        } else if (len === 2) {
          return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        } else {
          return "of ".concat(thing, " ").concat(expected[0]);
        }
      } else {
        return "of ".concat(thing, " ").concat(String(expected));
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      var determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      var msg;
      if (endsWith(name, " argument")) {
        msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      } else {
        var type = includes(name, ".") ? "property" : "argument";
        msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      }
      msg += ". Received type ".concat(typeof actual);
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module.exports.codes = codes;
  }
});

// .api/apis/zklighter/node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  ".api/apis/zklighter/node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
    "use strict";
    var ERR_INVALID_OPT_VALUE = require_errors_browser().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module.exports = {
      getHighWaterMark
    };
  }
});

// .api/apis/zklighter/node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  ".api/apis/zklighter/node_modules/inherits/inherits_browser.js"(exports, module) {
    if (typeof Object.create === "function") {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// .api/apis/zklighter/node_modules/util-deprecate/browser.js
var require_browser = __commonJS({
  ".api/apis/zklighter/node_modules/util-deprecate/browser.js"(exports, module) {
    module.exports = deprecate;
    function deprecate(fn, msg) {
      if (config("noDeprecation")) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (config("throwDeprecation")) {
            throw new Error(msg);
          } else if (config("traceDeprecation")) {
            console.trace(msg);
          } else {
            console.warn(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    }
    function config(name) {
      try {
        if (!global.localStorage) return false;
      } catch (_) {
        return false;
      }
      var val = global.localStorage[name];
      if (null == val) return false;
      return String(val).toLowerCase() === "true";
    }
  }
});

// .api/apis/zklighter/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  ".api/apis/zklighter/node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
    "use strict";
    module.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_browser()
    };
    var Stream = require_stream_browser();
    var Buffer2 = require_buffer().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits_browser()(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object)) return true;
          if (this !== Writable) return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function") this._write = options.write;
        if (typeof options.writev === "function") this._writev = options.writev;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.final === "function") this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf) encoding = "buffer";
      else if (!encoding) encoding = state.defaultEncoding;
      if (typeof cb !== "function") cb = nop;
      if (state.ending) writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string") encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret) state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev) stream._writev(chunk, state.onwrite);
      else stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er) onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished) onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf) allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null) state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending) endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished) process.nextTick(cb);
        else stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// .api/apis/zklighter/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  ".api/apis/zklighter/node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
    "use strict";
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) keys2.push(key);
      return keys2;
    };
    module.exports = Duplex;
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    require_inherits_browser()(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex)) return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false) this.readable = false;
        if (options.writable === false) this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended) return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// .api/apis/zklighter/node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  ".api/apis/zklighter/node_modules/safe-buffer/index.js"(exports, module) {
    var buffer = require_buffer();
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// .api/apis/zklighter/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  ".api/apis/zklighter/node_modules/string_decoder/lib/string_decoder.js"(exports) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc) return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried) return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0) return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0) return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127) return 0;
      else if (byte >> 5 === 6) return 2;
      else if (byte >> 4 === 14) return 3;
      else if (byte >> 3 === 30) return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i) return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2) nb = 0;
          else self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0) return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed) return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + "";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0) return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// .api/apis/zklighter/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  ".api/apis/zklighter/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
    "use strict";
    var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called) return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function") return eos(stream, null, opts);
      if (!opts) opts = {};
      callback = once(callback || noop);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable) onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable) callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable) callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req) onrequest();
        else stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false) stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module.exports = eos;
  }
});

// .api/apis/zklighter/node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  ".api/apis/zklighter/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module) {
    "use strict";
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var finished = require_end_of_stream();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module.exports = createReadableStreamAsyncIterator;
  }
});

// .api/apis/zklighter/node_modules/readable-stream/lib/internal/streams/from-browser.js
var require_from_browser = __commonJS({
  ".api/apis/zklighter/node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports, module) {
    module.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  }
});

// .api/apis/zklighter/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  ".api/apis/zklighter/node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
    "use strict";
    module.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require_events().EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream_browser();
    var Buffer2 = require_buffer().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require_util();
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    require_inherits_browser()(Readable, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
      else emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder) StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable)) return new Readable(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function") this._read = options.read;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck) er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
              else maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if (state.needReadable) emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder) StringDecoder = require_string_decoder().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "") this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended) return 0;
      if (state.objectMode) return 1;
      if (n !== n) {
        if (state.flowing && state.length) return state.buffer.head.data.length;
        else return state.length;
      }
      if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length) return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0) state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);
        else emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0) state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading) n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0) ret = fromList(n, state);
      else ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended) state.needReadable = true;
        if (nOrig !== n && state.ended) endReadable(this);
      }
      if (ret !== null) this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended) return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted) process.nextTick(endFn);
      else src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0) return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) dests[i].emit("unpipe", this, {
          hasUnpiped: false
        });
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1) return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1) state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false) this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      var res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading) stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) ;
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder) chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0)) return;
        else if (!state.objectMode && (!chunk || !chunk.length)) return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = /* @__PURE__ */ function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.length;
      }
    });
    function fromList(n, state) {
      if (state.length === 0) return null;
      var ret;
      if (state.objectMode) ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder) ret = state.buffer.join("");
        else if (state.buffer.length === 1) ret = state.buffer.first();
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from === void 0) {
          from = require_from_browser();
        }
        return from(Readable, iterable, opts);
      };
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) return i;
      }
      return -1;
    }
  }
});

// .api/apis/zklighter/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  ".api/apis/zklighter/node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
    "use strict";
    module.exports = Transform;
    var _require$codes = require_errors_browser().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex();
    require_inherits_browser()(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform)) return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function") this._transform = options.transform;
        if (typeof options.flush === "function") this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er) return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// .api/apis/zklighter/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  ".api/apis/zklighter/node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
    "use strict";
    module.exports = PassThrough;
    var Transform = require_stream_transform();
    require_inherits_browser()(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough)) return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// .api/apis/zklighter/node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  ".api/apis/zklighter/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
    "use strict";
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called) return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors_browser().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop(err) {
      if (err) throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0) eos = require_end_of_stream();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err) return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed) return;
        if (destroyed) return;
        destroyed = true;
        if (isRequest(stream)) return stream.abort();
        if (typeof stream.destroy === "function") return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe(from, to) {
      return from.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length) return noop;
      if (typeof streams[streams.length - 1] !== "function") return noop;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0])) streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error) error = err;
          if (err) destroys.forEach(call);
          if (reading) return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    module.exports = pipeline;
  }
});

// .api/apis/zklighter/node_modules/readable-stream/readable-browser.js
var require_readable_browser = __commonJS({
  ".api/apis/zklighter/node_modules/readable-stream/readable-browser.js"(exports, module) {
    exports = module.exports = require_stream_readable();
    exports.Stream = exports;
    exports.Readable = exports;
    exports.Writable = require_stream_writable();
    exports.Duplex = require_stream_duplex();
    exports.Transform = require_stream_transform();
    exports.PassThrough = require_stream_passthrough();
    exports.finished = require_end_of_stream();
    exports.pipeline = require_pipeline();
  }
});

// .api/apis/zklighter/node_modules/formdata-node/lib/cjs/browser.js
var require_browser2 = __commonJS({
  ".api/apis/zklighter/node_modules/formdata-node/lib/cjs/browser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.File = exports.Blob = exports.FormData = void 0;
    var globalObject = function() {
      if (typeof globalThis !== "undefined") {
        return globalThis;
      }
      if (typeof self !== "undefined") {
        return self;
      }
      return window;
    }();
    exports.FormData = globalObject.FormData, exports.Blob = globalObject.Blob, exports.File = globalObject.File;
  }
});

// .api/apis/zklighter/node_modules/fetch-har/dist/index.js
var require_dist6 = __commonJS({
  ".api/apis/zklighter/node_modules/fetch-har/dist/index.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    exports.__esModule = true;
    var data_urls_1 = require_dist2();
    var readable_stream_1 = require_readable_browser();
    if (!globalThis.Blob) {
      try {
        globalThis.Blob = require_browser2().Blob;
      } catch (e) {
        throw new Error("Since you do not have the Blob API available in this environment you must install the optional `formdata-node` dependency.");
      }
    }
    if (!globalThis.File) {
      try {
        globalThis.File = require_browser2().File;
      } catch (e) {
        throw new Error("Since you do not have the File API available in this environment you must install the optional `formdata-node` dependency.");
      }
    }
    if (!globalThis.FormData) {
      try {
        globalThis.FormData = require_browser2().FormData;
      } catch (e) {
        throw new Error("Since you do not have the FormData API available in this environment you must install the optional `formdata-node` dependency.");
      }
    }
    function isBrowser() {
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function isBuffer(value) {
      return typeof Buffer !== "undefined" && Buffer.isBuffer(value);
    }
    function isFile(value) {
      if (value instanceof File) {
        return value.constructor.name === "File";
      }
      return false;
    }
    function isFunction(value) {
      return typeof value === "function";
    }
    function isFormData(value) {
      return value && isFunction(value.constructor) && value[Symbol.toStringTag] === "FormData" && isFunction(value.append) && isFunction(value.getAll) && isFunction(value.entries) && isFunction(value[Symbol.iterator]);
    }
    function getFileFromSuppliedFiles(filename, files) {
      if (filename in files) {
        return files[filename];
      } else if (decodeURIComponent(filename) in files) {
        return files[decodeURIComponent(filename)];
      }
      return false;
    }
    function fetchHAR(har, opts) {
      var _a;
      if (opts === void 0) {
        opts = {};
      }
      if (!har)
        throw new Error("Missing HAR definition");
      if (!har.log || !har.log.entries || !har.log.entries.length)
        throw new Error("Missing log.entries array");
      var request = har.log.entries[0].request;
      var url = request.url;
      var querystring = "";
      var shouldSetDuplex = false;
      var options = __assign(__assign({}, opts.init ? opts.init : {}), { method: request.method });
      if (!options.headers) {
        options.headers = new Headers();
      } else if (typeof options.headers === "object" && !(options.headers instanceof Headers) && options.headers !== null) {
        options.headers = new Headers(options.headers);
      }
      var headers = options.headers;
      if ("headers" in request && request.headers.length) {
        request.headers.forEach(function(header) {
          try {
            return headers.append(header.name, header.value);
          } catch (err) {
          }
        });
      }
      if ("cookies" in request && request.cookies.length) {
        if (isBrowser()) {
          request.cookies.forEach(function(cookie) {
            document.cookie = "".concat(encodeURIComponent(cookie.name), "=").concat(encodeURIComponent(cookie.value));
          });
          options.credentials = "include";
        } else {
          headers.append("cookie", request.cookies.map(function(cookie) {
            return "".concat(encodeURIComponent(cookie.name), "=").concat(encodeURIComponent(cookie.value));
          }).join("; "));
        }
      }
      if ("postData" in request) {
        if ("params" in request.postData) {
          if (!("mimeType" in request.postData)) {
            request.postData.mimeType = "application/octet-stream";
          }
          switch (request.postData.mimeType) {
            case "application/x-www-form-urlencoded":
              headers.set("Content-Type", request.postData.mimeType);
              var encodedParams_1 = new URLSearchParams();
              request.postData.params.forEach(function(param) {
                return encodedParams_1.set(param.name, param.value);
              });
              options.body = encodedParams_1.toString();
              break;
            case "multipart/alternative":
            case "multipart/form-data":
            case "multipart/mixed":
            case "multipart/related":
              if (headers.has("Content-Type")) {
                headers["delete"]("Content-Type");
              }
              var form_1 = new FormData();
              if (!isFormData(form_1)) {
                throw new Error("We've detected you're using a non-spec compliant FormData library. We recommend polyfilling FormData with https://npm.im/formdata-node");
              }
              request.postData.params.forEach(function(param) {
                if ("fileName" in param) {
                  if (opts.files) {
                    var fileContents2 = getFileFromSuppliedFiles(param.fileName, opts.files);
                    if (fileContents2) {
                      if (isBuffer(fileContents2)) {
                        form_1.append(param.name, new File([fileContents2], param.fileName, {
                          type: param.contentType || null
                        }), param.fileName);
                        return;
                      } else if (isFile(fileContents2)) {
                        form_1.append(param.name, fileContents2, param.fileName);
                        return;
                      }
                      throw new TypeError("An unknown object has been supplied into the `files` config for use. We only support instances of the File API and Node Buffer objects.");
                    }
                  }
                  if ("value" in param) {
                    var paramBlob = void 0;
                    var parsed2 = (0, data_urls_1.parse)(param.value);
                    if (parsed2) {
                      paramBlob = new Blob([param.value], { type: parsed2.contentType || param.contentType || null });
                    } else {
                      paramBlob = new Blob([param.value], { type: param.contentType || null });
                    }
                    form_1.append(param.name, paramBlob, param.fileName);
                    return;
                  }
                  throw new Error("The supplied HAR has a postData parameter with `fileName`, but neither `value` content within the HAR or any file buffers were supplied with the `files` option. Since this library doesn't have access to the filesystem, it can't fetch that file.");
                }
                form_1.append(param.name, param.value);
              });
              if (opts.multipartEncoder) {
                var encoder_1 = new opts.multipartEncoder(form_1);
                Object.keys(encoder_1.headers).forEach(function(header) {
                  headers.set(header, encoder_1.headers[header]);
                });
                options.body = readable_stream_1.Readable.from(encoder_1);
                shouldSetDuplex = true;
              } else {
                options.body = form_1;
              }
              break;
            default:
              var formBody_1 = {};
              request.postData.params.map(function(param) {
                try {
                  formBody_1[param.name] = JSON.parse(param.value);
                } catch (e) {
                  formBody_1[param.name] = param.value;
                }
                return true;
              });
              options.body = JSON.stringify(formBody_1);
          }
        } else if ((_a = request.postData.text) === null || _a === void 0 ? void 0 : _a.length) {
          if (opts.files) {
            var parsed = (0, data_urls_1.parse)(request.postData.text);
            if (parsed) {
              if ((parsed === null || parsed === void 0 ? void 0 : parsed.name) && parsed.name in opts.files) {
                var fileContents = getFileFromSuppliedFiles(parsed.name, opts.files);
                if (fileContents) {
                  if (isBuffer(fileContents)) {
                    options.body = fileContents;
                  } else if (isFile(fileContents)) {
                    if (isBrowser()) {
                      options.body = fileContents;
                    } else {
                      options.body = readable_stream_1.Readable.from(fileContents.stream());
                      shouldSetDuplex = true;
                      if (!headers.has("content-length")) {
                        headers.set("content-length", String(fileContents.size));
                      }
                    }
                  }
                }
              }
            }
          }
          if (typeof options.body === "undefined") {
            options.body = request.postData.text;
          }
        }
        if (shouldSetDuplex && !isBrowser()) {
          options.duplex = "half";
        }
      }
      var requestURL = url;
      if ("queryString" in request && request.queryString.length) {
        var urlObj = new URL(requestURL);
        var queryParams_1 = Array.from(urlObj.searchParams).map(function(_a2) {
          var k = _a2[0], v = _a2[1];
          return "".concat(k, "=").concat(v);
        });
        request.queryString.forEach(function(q) {
          queryParams_1.push("".concat(q.name, "=").concat(q.value));
        });
        querystring = queryParams_1.join("&");
        if (urlObj.hash) {
          var urlWithoutHashes = requestURL.replace(urlObj.hash, "");
          requestURL = "".concat(urlWithoutHashes.split("?")[0]).concat(querystring ? "?".concat(querystring) : "");
          requestURL += urlObj.hash;
        } else {
          requestURL = "".concat(requestURL.split("?")[0]).concat(querystring ? "?".concat(querystring) : "");
        }
      }
      if (opts.userAgent) {
        headers.append("User-Agent", opts.userAgent);
      }
      options.headers = headers;
      return fetch(requestURL, options);
    }
    exports["default"] = fetchHAR;
  }
});

// .api/apis/zklighter/node_modules/form-data-encoder/lib/cjs/util/isFunction.js
var require_isFunction = __commonJS({
  ".api/apis/zklighter/node_modules/form-data-encoder/lib/cjs/util/isFunction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var isFunction = (value) => typeof value === "function";
    exports.default = isFunction;
  }
});

// .api/apis/zklighter/node_modules/form-data-encoder/lib/cjs/util/getStreamIterator.js
var require_getStreamIterator = __commonJS({
  ".api/apis/zklighter/node_modules/form-data-encoder/lib/cjs/util/getStreamIterator.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var isFunction_1 = __importDefault(require_isFunction());
    var isAsyncIterable = (value) => (0, isFunction_1.default)(value[Symbol.asyncIterator]);
    async function* readStream(readable) {
      const reader = readable.getReader();
      while (true) {
        const { done, value } = await reader.read();
        if (done) {
          break;
        }
        yield value;
      }
    }
    var getStreamIterator = (source) => {
      if (isAsyncIterable(source)) {
        return source;
      }
      if ((0, isFunction_1.default)(source.getReader)) {
        return readStream(source);
      }
      throw new TypeError("Unsupported data source: Expected either ReadableStream or async iterable.");
    };
    exports.default = getStreamIterator;
  }
});

// .api/apis/zklighter/node_modules/form-data-encoder/lib/cjs/util/createBoundary.js
var require_createBoundary = __commonJS({
  ".api/apis/zklighter/node_modules/form-data-encoder/lib/cjs/util/createBoundary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var alphabet = "abcdefghijklmnopqrstuvwxyz0123456789";
    function createBoundary() {
      let size = 16;
      let res = "";
      while (size--) {
        res += alphabet[Math.random() * alphabet.length << 0];
      }
      return res;
    }
    exports.default = createBoundary;
  }
});

// .api/apis/zklighter/node_modules/form-data-encoder/lib/cjs/util/isPlainObject.js
var require_isPlainObject = __commonJS({
  ".api/apis/zklighter/node_modules/form-data-encoder/lib/cjs/util/isPlainObject.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var getType = (value) => Object.prototype.toString.call(value).slice(8, -1).toLowerCase();
    function isPlainObject(value) {
      if (getType(value) !== "object") {
        return false;
      }
      const pp = Object.getPrototypeOf(value);
      if (pp === null || pp === void 0) {
        return true;
      }
      const Ctor = pp.constructor && pp.constructor.toString();
      return Ctor === Object.toString();
    }
    exports.default = isPlainObject;
  }
});

// .api/apis/zklighter/node_modules/form-data-encoder/lib/cjs/util/normalizeValue.js
var require_normalizeValue = __commonJS({
  ".api/apis/zklighter/node_modules/form-data-encoder/lib/cjs/util/normalizeValue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var normalizeValue2 = (value) => String(value).replace(/\r|\n/g, (match, i, str) => {
      if (match === "\r" && str[i + 1] !== "\n" || match === "\n" && str[i - 1] !== "\r") {
        return "\r\n";
      }
      return match;
    });
    exports.default = normalizeValue2;
  }
});

// .api/apis/zklighter/node_modules/form-data-encoder/lib/cjs/util/escapeName.js
var require_escapeName = __commonJS({
  ".api/apis/zklighter/node_modules/form-data-encoder/lib/cjs/util/escapeName.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var escapeName = (name) => String(name).replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/"/g, "%22");
    exports.default = escapeName;
  }
});

// .api/apis/zklighter/node_modules/form-data-encoder/lib/cjs/util/isFileLike.js
var require_isFileLike = __commonJS({
  ".api/apis/zklighter/node_modules/form-data-encoder/lib/cjs/util/isFileLike.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isFileLike = void 0;
    var isFunction_1 = __importDefault(require_isFunction());
    var isFileLike = (value) => Boolean(value && typeof value === "object" && (0, isFunction_1.default)(value.constructor) && value[Symbol.toStringTag] === "File" && (0, isFunction_1.default)(value.stream) && value.name != null);
    exports.isFileLike = isFileLike;
  }
});

// .api/apis/zklighter/node_modules/form-data-encoder/lib/cjs/util/isFormData.js
var require_isFormData = __commonJS({
  ".api/apis/zklighter/node_modules/form-data-encoder/lib/cjs/util/isFormData.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isFormDataLike = exports.isFormData = void 0;
    var isFunction_1 = __importDefault(require_isFunction());
    var isFormData = (value) => Boolean(value && (0, isFunction_1.default)(value.constructor) && value[Symbol.toStringTag] === "FormData" && (0, isFunction_1.default)(value.append) && (0, isFunction_1.default)(value.getAll) && (0, isFunction_1.default)(value.entries) && (0, isFunction_1.default)(value[Symbol.iterator]));
    exports.isFormData = isFormData;
    exports.isFormDataLike = exports.isFormData;
  }
});

// .api/apis/zklighter/node_modules/form-data-encoder/lib/cjs/FormDataEncoder.js
var require_FormDataEncoder = __commonJS({
  ".api/apis/zklighter/node_modules/form-data-encoder/lib/cjs/FormDataEncoder.js"(exports) {
    "use strict";
    var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m") throw new TypeError("Private method is not writable");
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _FormDataEncoder_instances;
    var _FormDataEncoder_CRLF;
    var _FormDataEncoder_CRLF_BYTES;
    var _FormDataEncoder_CRLF_BYTES_LENGTH;
    var _FormDataEncoder_DASHES;
    var _FormDataEncoder_encoder;
    var _FormDataEncoder_footer;
    var _FormDataEncoder_form;
    var _FormDataEncoder_options;
    var _FormDataEncoder_getFieldHeader;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Encoder = exports.FormDataEncoder = void 0;
    var getStreamIterator_1 = __importDefault(require_getStreamIterator());
    var createBoundary_1 = __importDefault(require_createBoundary());
    var isPlainObject_1 = __importDefault(require_isPlainObject());
    var normalizeValue_1 = __importDefault(require_normalizeValue());
    var escapeName_1 = __importDefault(require_escapeName());
    var isFileLike_1 = require_isFileLike();
    var isFormData_1 = require_isFormData();
    var defaultOptions = {
      enableAdditionalHeaders: false
    };
    var FormDataEncoder = class {
      constructor(form, boundaryOrOptions, options) {
        _FormDataEncoder_instances.add(this);
        _FormDataEncoder_CRLF.set(this, "\r\n");
        _FormDataEncoder_CRLF_BYTES.set(this, void 0);
        _FormDataEncoder_CRLF_BYTES_LENGTH.set(this, void 0);
        _FormDataEncoder_DASHES.set(this, "-".repeat(2));
        _FormDataEncoder_encoder.set(this, new TextEncoder());
        _FormDataEncoder_footer.set(this, void 0);
        _FormDataEncoder_form.set(this, void 0);
        _FormDataEncoder_options.set(this, void 0);
        if (!(0, isFormData_1.isFormData)(form)) {
          throw new TypeError("Expected first argument to be a FormData instance.");
        }
        let boundary;
        if ((0, isPlainObject_1.default)(boundaryOrOptions)) {
          options = boundaryOrOptions;
        } else {
          boundary = boundaryOrOptions;
        }
        if (!boundary) {
          boundary = (0, createBoundary_1.default)();
        }
        if (typeof boundary !== "string") {
          throw new TypeError("Expected boundary argument to be a string.");
        }
        if (options && !(0, isPlainObject_1.default)(options)) {
          throw new TypeError("Expected options argument to be an object.");
        }
        __classPrivateFieldSet(this, _FormDataEncoder_form, form, "f");
        __classPrivateFieldSet(this, _FormDataEncoder_options, { ...defaultOptions, ...options }, "f");
        __classPrivateFieldSet(this, _FormDataEncoder_CRLF_BYTES, __classPrivateFieldGet(this, _FormDataEncoder_encoder, "f").encode(__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f")), "f");
        __classPrivateFieldSet(this, _FormDataEncoder_CRLF_BYTES_LENGTH, __classPrivateFieldGet(this, _FormDataEncoder_CRLF_BYTES, "f").byteLength, "f");
        this.boundary = `form-data-boundary-${boundary}`;
        this.contentType = `multipart/form-data; boundary=${this.boundary}`;
        __classPrivateFieldSet(this, _FormDataEncoder_footer, __classPrivateFieldGet(this, _FormDataEncoder_encoder, "f").encode(`${__classPrivateFieldGet(this, _FormDataEncoder_DASHES, "f")}${this.boundary}${__classPrivateFieldGet(this, _FormDataEncoder_DASHES, "f")}${__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f").repeat(2)}`), "f");
        this.contentLength = String(this.getContentLength());
        this.headers = Object.freeze({
          "Content-Length": this.contentLength,
          "Content-Type": this.contentType
        });
        Object.defineProperties(this, {
          boundary: { writable: false, configurable: false },
          contentType: { writable: false, configurable: false },
          contentLength: { writable: false, configurable: false },
          headers: { writable: false, configurable: false }
        });
      }
      getContentLength() {
        let length = 0;
        for (const [name, raw] of __classPrivateFieldGet(this, _FormDataEncoder_form, "f")) {
          const value = (0, isFileLike_1.isFileLike)(raw) ? raw : __classPrivateFieldGet(this, _FormDataEncoder_encoder, "f").encode((0, normalizeValue_1.default)(raw));
          length += __classPrivateFieldGet(this, _FormDataEncoder_instances, "m", _FormDataEncoder_getFieldHeader).call(this, name, value).byteLength;
          length += (0, isFileLike_1.isFileLike)(value) ? value.size : value.byteLength;
          length += __classPrivateFieldGet(this, _FormDataEncoder_CRLF_BYTES_LENGTH, "f");
        }
        return length + __classPrivateFieldGet(this, _FormDataEncoder_footer, "f").byteLength;
      }
      *values() {
        for (const [name, raw] of __classPrivateFieldGet(this, _FormDataEncoder_form, "f").entries()) {
          const value = (0, isFileLike_1.isFileLike)(raw) ? raw : __classPrivateFieldGet(this, _FormDataEncoder_encoder, "f").encode((0, normalizeValue_1.default)(raw));
          yield __classPrivateFieldGet(this, _FormDataEncoder_instances, "m", _FormDataEncoder_getFieldHeader).call(this, name, value);
          yield value;
          yield __classPrivateFieldGet(this, _FormDataEncoder_CRLF_BYTES, "f");
        }
        yield __classPrivateFieldGet(this, _FormDataEncoder_footer, "f");
      }
      async *encode() {
        for (const part of this.values()) {
          if ((0, isFileLike_1.isFileLike)(part)) {
            yield* (0, getStreamIterator_1.default)(part.stream());
          } else {
            yield part;
          }
        }
      }
      [(_FormDataEncoder_CRLF = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_CRLF_BYTES = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_CRLF_BYTES_LENGTH = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_DASHES = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_encoder = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_footer = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_form = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_options = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_instances = /* @__PURE__ */ new WeakSet(), _FormDataEncoder_getFieldHeader = function _FormDataEncoder_getFieldHeader2(name, value) {
        let header = "";
        header += `${__classPrivateFieldGet(this, _FormDataEncoder_DASHES, "f")}${this.boundary}${__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f")}`;
        header += `Content-Disposition: form-data; name="${(0, escapeName_1.default)(name)}"`;
        if ((0, isFileLike_1.isFileLike)(value)) {
          header += `; filename="${(0, escapeName_1.default)(value.name)}"${__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f")}`;
          header += `Content-Type: ${value.type || "application/octet-stream"}`;
        }
        if (__classPrivateFieldGet(this, _FormDataEncoder_options, "f").enableAdditionalHeaders === true) {
          const size = (0, isFileLike_1.isFileLike)(value) ? value.size : value.byteLength;
          if (size != null && !isNaN(size)) {
            header += `${__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f")}Content-Length: ${size}`;
          }
        }
        return __classPrivateFieldGet(this, _FormDataEncoder_encoder, "f").encode(`${header}${__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f").repeat(2)}`);
      }, Symbol.iterator)]() {
        return this.values();
      }
      [Symbol.asyncIterator]() {
        return this.encode();
      }
    };
    exports.FormDataEncoder = FormDataEncoder;
    exports.Encoder = FormDataEncoder;
  }
});

// .api/apis/zklighter/node_modules/form-data-encoder/lib/cjs/FileLike.js
var require_FileLike = __commonJS({
  ".api/apis/zklighter/node_modules/form-data-encoder/lib/cjs/FileLike.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// .api/apis/zklighter/node_modules/form-data-encoder/lib/cjs/FormDataLike.js
var require_FormDataLike = __commonJS({
  ".api/apis/zklighter/node_modules/form-data-encoder/lib/cjs/FormDataLike.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// .api/apis/zklighter/node_modules/form-data-encoder/lib/cjs/index.js
var require_cjs = __commonJS({
  ".api/apis/zklighter/node_modules/form-data-encoder/lib/cjs/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_FormDataEncoder(), exports);
    __exportStar(require_FileLike(), exports);
    __exportStar(require_FormDataLike(), exports);
    __exportStar(require_isFileLike(), exports);
    __exportStar(require_isFormData(), exports);
  }
});

// .api/apis/zklighter/node_modules/whatwg-fetch/fetch.js
var fetch_exports = {};
__export(fetch_exports, {
  DOMException: () => DOMException,
  Headers: () => Headers2,
  Request: () => Request,
  Response: () => Response,
  fetch: () => fetch2
});
function isDataView(obj) {
  return obj && DataView.prototype.isPrototypeOf(obj);
}
function normalizeName(name) {
  if (typeof name !== "string") {
    name = String(name);
  }
  if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
    throw new TypeError('Invalid character in header field name: "' + name + '"');
  }
  return name.toLowerCase();
}
function normalizeValue(value) {
  if (typeof value !== "string") {
    value = String(value);
  }
  return value;
}
function iteratorFor(items) {
  var iterator = {
    next: function() {
      var value = items.shift();
      return { done: value === void 0, value };
    }
  };
  if (support.iterable) {
    iterator[Symbol.iterator] = function() {
      return iterator;
    };
  }
  return iterator;
}
function Headers2(headers) {
  this.map = {};
  if (headers instanceof Headers2) {
    headers.forEach(function(value, name) {
      this.append(name, value);
    }, this);
  } else if (Array.isArray(headers)) {
    headers.forEach(function(header) {
      if (header.length != 2) {
        throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + header.length);
      }
      this.append(header[0], header[1]);
    }, this);
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function(name) {
      this.append(name, headers[name]);
    }, this);
  }
}
function consumed(body) {
  if (body._noBody) return;
  if (body.bodyUsed) {
    return Promise.reject(new TypeError("Already read"));
  }
  body.bodyUsed = true;
}
function fileReaderReady(reader) {
  return new Promise(function(resolve, reject) {
    reader.onload = function() {
      resolve(reader.result);
    };
    reader.onerror = function() {
      reject(reader.error);
    };
  });
}
function readBlobAsArrayBuffer(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  reader.readAsArrayBuffer(blob);
  return promise;
}
function readBlobAsText(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
  var encoding = match ? match[1] : "utf-8";
  reader.readAsText(blob, encoding);
  return promise;
}
function readArrayBufferAsText(buf) {
  var view = new Uint8Array(buf);
  var chars = new Array(view.length);
  for (var i = 0; i < view.length; i++) {
    chars[i] = String.fromCharCode(view[i]);
  }
  return chars.join("");
}
function bufferClone(buf) {
  if (buf.slice) {
    return buf.slice(0);
  } else {
    var view = new Uint8Array(buf.byteLength);
    view.set(new Uint8Array(buf));
    return view.buffer;
  }
}
function Body() {
  this.bodyUsed = false;
  this._initBody = function(body) {
    this.bodyUsed = this.bodyUsed;
    this._bodyInit = body;
    if (!body) {
      this._noBody = true;
      this._bodyText = "";
    } else if (typeof body === "string") {
      this._bodyText = body;
    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
      this._bodyBlob = body;
    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
      this._bodyFormData = body;
    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
      this._bodyText = body.toString();
    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
      this._bodyArrayBuffer = bufferClone(body.buffer);
      this._bodyInit = new Blob([this._bodyArrayBuffer]);
    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
      this._bodyArrayBuffer = bufferClone(body);
    } else {
      this._bodyText = body = Object.prototype.toString.call(body);
    }
    if (!this.headers.get("content-type")) {
      if (typeof body === "string") {
        this.headers.set("content-type", "text/plain;charset=UTF-8");
      } else if (this._bodyBlob && this._bodyBlob.type) {
        this.headers.set("content-type", this._bodyBlob.type);
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
      }
    }
  };
  if (support.blob) {
    this.blob = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected;
      }
      if (this._bodyBlob) {
        return Promise.resolve(this._bodyBlob);
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(new Blob([this._bodyArrayBuffer]));
      } else if (this._bodyFormData) {
        throw new Error("could not read FormData body as blob");
      } else {
        return Promise.resolve(new Blob([this._bodyText]));
      }
    };
  }
  this.arrayBuffer = function() {
    if (this._bodyArrayBuffer) {
      var isConsumed = consumed(this);
      if (isConsumed) {
        return isConsumed;
      } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
        return Promise.resolve(
          this._bodyArrayBuffer.buffer.slice(
            this._bodyArrayBuffer.byteOffset,
            this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
          )
        );
      } else {
        return Promise.resolve(this._bodyArrayBuffer);
      }
    } else if (support.blob) {
      return this.blob().then(readBlobAsArrayBuffer);
    } else {
      throw new Error("could not read as ArrayBuffer");
    }
  };
  this.text = function() {
    var rejected = consumed(this);
    if (rejected) {
      return rejected;
    }
    if (this._bodyBlob) {
      return readBlobAsText(this._bodyBlob);
    } else if (this._bodyArrayBuffer) {
      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
    } else if (this._bodyFormData) {
      throw new Error("could not read FormData body as text");
    } else {
      return Promise.resolve(this._bodyText);
    }
  };
  if (support.formData) {
    this.formData = function() {
      return this.text().then(decode);
    };
  }
  this.json = function() {
    return this.text().then(JSON.parse);
  };
  return this;
}
function normalizeMethod(method) {
  var upcased = method.toUpperCase();
  return methods.indexOf(upcased) > -1 ? upcased : method;
}
function Request(input, options) {
  if (!(this instanceof Request)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  }
  options = options || {};
  var body = options.body;
  if (input instanceof Request) {
    if (input.bodyUsed) {
      throw new TypeError("Already read");
    }
    this.url = input.url;
    this.credentials = input.credentials;
    if (!options.headers) {
      this.headers = new Headers2(input.headers);
    }
    this.method = input.method;
    this.mode = input.mode;
    this.signal = input.signal;
    if (!body && input._bodyInit != null) {
      body = input._bodyInit;
      input.bodyUsed = true;
    }
  } else {
    this.url = String(input);
  }
  this.credentials = options.credentials || this.credentials || "same-origin";
  if (options.headers || !this.headers) {
    this.headers = new Headers2(options.headers);
  }
  this.method = normalizeMethod(options.method || this.method || "GET");
  this.mode = options.mode || this.mode || null;
  this.signal = options.signal || this.signal || function() {
    if ("AbortController" in g) {
      var ctrl = new AbortController();
      return ctrl.signal;
    }
  }();
  this.referrer = null;
  if ((this.method === "GET" || this.method === "HEAD") && body) {
    throw new TypeError("Body not allowed for GET or HEAD requests");
  }
  this._initBody(body);
  if (this.method === "GET" || this.method === "HEAD") {
    if (options.cache === "no-store" || options.cache === "no-cache") {
      var reParamSearch = /([?&])_=[^&]*/;
      if (reParamSearch.test(this.url)) {
        this.url = this.url.replace(reParamSearch, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
      } else {
        var reQueryString = /\?/;
        this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
      }
    }
  }
}
function decode(body) {
  var form = new FormData();
  body.trim().split("&").forEach(function(bytes) {
    if (bytes) {
      var split = bytes.split("=");
      var name = split.shift().replace(/\+/g, " ");
      var value = split.join("=").replace(/\+/g, " ");
      form.append(decodeURIComponent(name), decodeURIComponent(value));
    }
  });
  return form;
}
function parseHeaders(rawHeaders) {
  var headers = new Headers2();
  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
  preProcessedHeaders.split("\r").map(function(header) {
    return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
  }).forEach(function(line) {
    var parts = line.split(":");
    var key = parts.shift().trim();
    if (key) {
      var value = parts.join(":").trim();
      try {
        headers.append(key, value);
      } catch (error) {
        console.warn("Response " + error.message);
      }
    }
  });
  return headers;
}
function Response(bodyInit, options) {
  if (!(this instanceof Response)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  }
  if (!options) {
    options = {};
  }
  this.type = "default";
  this.status = options.status === void 0 ? 200 : options.status;
  if (this.status < 200 || this.status > 599) {
    throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
  }
  this.ok = this.status >= 200 && this.status < 300;
  this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
  this.headers = new Headers2(options.headers);
  this.url = options.url || "";
  this._initBody(bodyInit);
}
function fetch2(input, init) {
  return new Promise(function(resolve, reject) {
    var request = new Request(input, init);
    if (request.signal && request.signal.aborted) {
      return reject(new DOMException("Aborted", "AbortError"));
    }
    var xhr = new XMLHttpRequest();
    function abortXhr() {
      xhr.abort();
    }
    xhr.onload = function() {
      var options = {
        statusText: xhr.statusText,
        headers: parseHeaders(xhr.getAllResponseHeaders() || "")
      };
      if (request.url.indexOf("file://") === 0 && (xhr.status < 200 || xhr.status > 599)) {
        options.status = 200;
      } else {
        options.status = xhr.status;
      }
      options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
      var body = "response" in xhr ? xhr.response : xhr.responseText;
      setTimeout(function() {
        resolve(new Response(body, options));
      }, 0);
    };
    xhr.onerror = function() {
      setTimeout(function() {
        reject(new TypeError("Network request failed"));
      }, 0);
    };
    xhr.ontimeout = function() {
      setTimeout(function() {
        reject(new TypeError("Network request timed out"));
      }, 0);
    };
    xhr.onabort = function() {
      setTimeout(function() {
        reject(new DOMException("Aborted", "AbortError"));
      }, 0);
    };
    function fixUrl(url) {
      try {
        return url === "" && g.location.href ? g.location.href : url;
      } catch (e) {
        return url;
      }
    }
    xhr.open(request.method, fixUrl(request.url), true);
    if (request.credentials === "include") {
      xhr.withCredentials = true;
    } else if (request.credentials === "omit") {
      xhr.withCredentials = false;
    }
    if ("responseType" in xhr) {
      if (support.blob) {
        xhr.responseType = "blob";
      } else if (support.arrayBuffer) {
        xhr.responseType = "arraybuffer";
      }
    }
    if (init && typeof init.headers === "object" && !(init.headers instanceof Headers2 || g.Headers && init.headers instanceof g.Headers)) {
      var names = [];
      Object.getOwnPropertyNames(init.headers).forEach(function(name) {
        names.push(normalizeName(name));
        xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
      });
      request.headers.forEach(function(value, name) {
        if (names.indexOf(name) === -1) {
          xhr.setRequestHeader(name, value);
        }
      });
    } else {
      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });
    }
    if (request.signal) {
      request.signal.addEventListener("abort", abortXhr);
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
          request.signal.removeEventListener("abort", abortXhr);
        }
      };
    }
    xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
  });
}
var g, support, viewClasses, isArrayBufferView, methods, redirectStatuses, DOMException;
var init_fetch = __esm({
  ".api/apis/zklighter/node_modules/whatwg-fetch/fetch.js"() {
    g = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || // eslint-disable-next-line no-undef
    typeof global !== "undefined" && global || {};
    support = {
      searchParams: "URLSearchParams" in g,
      iterable: "Symbol" in g && "iterator" in Symbol,
      blob: "FileReader" in g && "Blob" in g && function() {
        try {
          new Blob();
          return true;
        } catch (e) {
          return false;
        }
      }(),
      formData: "FormData" in g,
      arrayBuffer: "ArrayBuffer" in g
    };
    if (support.arrayBuffer) {
      viewClasses = [
        "[object Int8Array]",
        "[object Uint8Array]",
        "[object Uint8ClampedArray]",
        "[object Int16Array]",
        "[object Uint16Array]",
        "[object Int32Array]",
        "[object Uint32Array]",
        "[object Float32Array]",
        "[object Float64Array]"
      ];
      isArrayBufferView = ArrayBuffer.isView || function(obj) {
        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
      };
    }
    Headers2.prototype.append = function(name, value) {
      name = normalizeName(name);
      value = normalizeValue(value);
      var oldValue = this.map[name];
      this.map[name] = oldValue ? oldValue + ", " + value : value;
    };
    Headers2.prototype["delete"] = function(name) {
      delete this.map[normalizeName(name)];
    };
    Headers2.prototype.get = function(name) {
      name = normalizeName(name);
      return this.has(name) ? this.map[name] : null;
    };
    Headers2.prototype.has = function(name) {
      return this.map.hasOwnProperty(normalizeName(name));
    };
    Headers2.prototype.set = function(name, value) {
      this.map[normalizeName(name)] = normalizeValue(value);
    };
    Headers2.prototype.forEach = function(callback, thisArg) {
      for (var name in this.map) {
        if (this.map.hasOwnProperty(name)) {
          callback.call(thisArg, this.map[name], name, this);
        }
      }
    };
    Headers2.prototype.keys = function() {
      var items = [];
      this.forEach(function(value, name) {
        items.push(name);
      });
      return iteratorFor(items);
    };
    Headers2.prototype.values = function() {
      var items = [];
      this.forEach(function(value) {
        items.push(value);
      });
      return iteratorFor(items);
    };
    Headers2.prototype.entries = function() {
      var items = [];
      this.forEach(function(value, name) {
        items.push([name, value]);
      });
      return iteratorFor(items);
    };
    if (support.iterable) {
      Headers2.prototype[Symbol.iterator] = Headers2.prototype.entries;
    }
    methods = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
    Request.prototype.clone = function() {
      return new Request(this, { body: this._bodyInit });
    };
    Body.call(Request.prototype);
    Body.call(Response.prototype);
    Response.prototype.clone = function() {
      return new Response(this._bodyInit, {
        status: this.status,
        statusText: this.statusText,
        headers: new Headers2(this.headers),
        url: this.url
      });
    };
    Response.error = function() {
      var response = new Response(null, { status: 200, statusText: "" });
      response.ok = false;
      response.status = 0;
      response.type = "error";
      return response;
    };
    redirectStatuses = [301, 302, 303, 307, 308];
    Response.redirect = function(url, status) {
      if (redirectStatuses.indexOf(status) === -1) {
        throw new RangeError("Invalid status code");
      }
      return new Response(null, { status, headers: { location: url } });
    };
    DOMException = g.DOMException;
    try {
      new DOMException();
    } catch (err) {
      DOMException = function(message, name) {
        this.message = message;
        this.name = name;
        var error = Error(message);
        this.stack = error.stack;
      };
      DOMException.prototype = Object.create(Error.prototype);
      DOMException.prototype.constructor = DOMException;
    }
    fetch2.polyfill = true;
    if (!g.fetch) {
      g.fetch = fetch2;
      g.Headers = Headers2;
      g.Request = Request;
      g.Response = Response;
    }
  }
});

// .api/apis/zklighter/node_modules/isomorphic-fetch/fetch-npm-browserify.js
var require_fetch_npm_browserify = __commonJS({
  ".api/apis/zklighter/node_modules/isomorphic-fetch/fetch-npm-browserify.js"(exports, module) {
    init_fetch();
    module.exports = self.fetch.bind(self);
  }
});

// .api/apis/zklighter/node_modules/node-abort-controller/browser.js
var require_browser3 = __commonJS({
  ".api/apis/zklighter/node_modules/node-abort-controller/browser.js"(exports, module) {
    "use strict";
    var _global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : (
      /* otherwise */
      void 0
    );
    if (!_global) {
      throw new Error(
        `Unable to find global scope. Are you sure this is running in the browser?`
      );
    }
    if (!_global.AbortController) {
      throw new Error(
        `Could not find "AbortController" in the global scope. You need to polyfill it first`
      );
    }
    module.exports.AbortController = _global.AbortController;
  }
});

// .api/apis/zklighter/node_modules/api/dist/core/errors/fetchError.js
var require_fetchError = __commonJS({
  ".api/apis/zklighter/node_modules/api/dist/core/errors/fetchError.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    exports.__esModule = true;
    var FetchError = (
      /** @class */
      function(_super) {
        __extends(FetchError2, _super);
        function FetchError2(status, data, headers, res) {
          var _this = _super.call(this, res.statusText) || this;
          _this.name = "FetchError";
          _this.status = status;
          _this.data = data;
          _this.headers = headers;
          _this.res = res;
          Object.setPrototypeOf(_this, FetchError2.prototype);
          return _this;
        }
        return FetchError2;
      }(Error)
    );
    exports["default"] = FetchError;
  }
});

// .api/apis/zklighter/node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS({
  ".api/apis/zklighter/node_modules/json-schema-traverse/index.js"(exports, module) {
    "use strict";
    var traverse = module.exports = function(schema, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      };
      var post = cb.post || function() {
      };
      _traverse(opts, pre, post, schema, "", schema);
    };
    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true,
      if: true,
      then: true,
      else: true
    };
    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse.propsKeywords = {
      $defs: true,
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords) {
              for (var i = 0; i < sch.length; i++)
                _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
            }
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop in sch)
                _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
            }
          } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
            _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
          }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }
});

// .api/apis/zklighter/node_modules/api/dist/core/getJSONSchemaDefaults.js
var require_getJSONSchemaDefaults = __commonJS({
  ".api/apis/zklighter/node_modules/api/dist/core/getJSONSchemaDefaults.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    exports.__esModule = true;
    var json_schema_traverse_1 = __importDefault(require_json_schema_traverse());
    function getJSONSchemaDefaults(jsonSchemas) {
      return jsonSchemas.map(function(_a) {
        var _b;
        var payloadType = _a.type, jsonSchema = _a.schema;
        var defaults = {};
        (0, json_schema_traverse_1["default"])(jsonSchema, function(schema, pointer, rootSchema, parentPointer, parentKeyword, parentSchema, indexProperty) {
          if (!pointer.startsWith("/properties/")) {
            return;
          }
          if (Array.isArray(parentSchema === null || parentSchema === void 0 ? void 0 : parentSchema.required) && parentSchema.required.includes(indexProperty)) {
            if (schema.type === "object" && indexProperty) {
              defaults[indexProperty] = {};
            }
            var destination_1 = defaults;
            if (parentPointer) {
              parentPointer.replace(/\/properties/g, "").split("/").forEach(function(subSchema) {
                if (subSchema === "") {
                  return;
                }
                destination_1 = (destination_1 === null || destination_1 === void 0 ? void 0 : destination_1[subSchema]) || {};
              });
            }
            if (schema["default"] !== void 0) {
              if (indexProperty !== void 0) {
                destination_1[indexProperty] = schema["default"];
              }
            }
          }
        });
        if (!Object.keys(defaults).length) {
          return {};
        }
        return _b = {}, // @todo should we filter out empty and undefined objects from here with `remove-undefined-objects`?
        _b[payloadType] = defaults, _b;
      }).reduce(function(prev, next) {
        return Object.assign(prev, next);
      });
    }
    exports["default"] = getJSONSchemaDefaults;
  }
});

// .api/apis/zklighter/node_modules/api/dist/core/parseResponse.js
var require_parseResponse = __commonJS({
  ".api/apis/zklighter/node_modules/api/dist/core/parseResponse.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g2;
      return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
        return this;
      }), g2;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g2 && (g2 = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    exports.__esModule = true;
    var oas_1 = require_dist();
    var matchesMimeType = oas_1.utils.matchesMimeType;
    function getResponseBody(response) {
      return __awaiter(this, void 0, void 0, function() {
        var contentType, isJSON, responseBody, data;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              contentType = response.headers.get("Content-Type");
              isJSON = contentType && (matchesMimeType.json(contentType) || matchesMimeType.wildcard(contentType));
              return [4, response.text()];
            case 1:
              responseBody = _a.sent();
              data = responseBody;
              if (isJSON) {
                try {
                  data = JSON.parse(responseBody);
                } catch (e) {
                }
              }
              return [2, {
                data,
                status: response.status,
                headers: response.headers,
                res: response
              }];
          }
        });
      });
    }
    exports["default"] = getResponseBody;
  }
});

// .api/apis/zklighter/node_modules/api/dist/core/prepareAuth.js
var require_prepareAuth = __commonJS({
  ".api/apis/zklighter/node_modules/api/dist/core/prepareAuth.js"(exports) {
    "use strict";
    exports.__esModule = true;
    function prepareAuth(authKey, operation) {
      if (authKey.length === 0) {
        return {};
      }
      var preparedAuth = {};
      var security = operation.getSecurity();
      if (security.length === 0) {
        return {};
      }
      if (security.every(function(s) {
        return Object.keys(s).length > 1;
      })) {
        throw new Error("Sorry, this operation currently requires multiple forms of authentication which this library doesn't yet support.");
      }
      var usableSecurity = security.map(function(s) {
        return Object.keys(s).length === 1 ? s : false;
      }).filter(Boolean);
      var usableSecuritySchemes = usableSecurity.map(function(s) {
        return Object.keys(s);
      }).reduce(function(prev, next) {
        return prev.concat(next);
      }, []);
      var preparedSecurity = operation.prepareSecurity();
      if (authKey.length >= 2) {
        if (!("Basic" in preparedSecurity)) {
          throw new Error("Multiple auth tokens were supplied for this endpoint but only a single token is needed.");
        }
        var schemes_1 = preparedSecurity.Basic.filter(function(s) {
          return usableSecuritySchemes.includes(s._key);
        });
        if (!schemes_1.length) {
          throw new Error("Credentials for Basic Authentication were supplied but this operation requires another form of auth in that case, which this library does not yet support. This operation does, however, allow supplying a single auth token.");
        }
        var scheme_1 = schemes_1.shift();
        preparedAuth[scheme_1._key] = {
          user: authKey[0],
          pass: authKey.length === 2 ? authKey[1] : ""
        };
        return preparedAuth;
      }
      var usableScheme = usableSecuritySchemes[0];
      var schemes = Object.entries(preparedSecurity).map(function(_a) {
        var ps = _a[1];
        return ps.filter(function(s) {
          return usableScheme === s._key;
        });
      }).reduce(function(prev, next) {
        return prev.concat(next);
      }, []);
      var scheme = schemes.shift();
      switch (scheme.type) {
        case "http":
          if (scheme.scheme === "basic") {
            preparedAuth[scheme._key] = {
              user: authKey[0],
              pass: authKey.length === 2 ? authKey[1] : ""
            };
          } else if (scheme.scheme === "bearer") {
            preparedAuth[scheme._key] = authKey[0];
          }
          break;
        case "oauth2":
          preparedAuth[scheme._key] = authKey[0];
          break;
        case "apiKey":
          if (scheme["in"] === "query" || scheme["in"] === "header" || scheme["in"] === "cookie") {
            preparedAuth[scheme._key] = authKey[0];
          }
          break;
        default:
          throw new Error("Sorry, this API currently uses a security scheme, ".concat(scheme.type, ", which this library doesn't yet support."));
      }
      return preparedAuth;
    }
    exports["default"] = prepareAuth;
  }
});

// browser-external:path
var require_path = __commonJS({
  "browser-external:path"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "path" has been externalized for browser compatibility. Cannot access "path.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:stream
var require_stream = __commonJS({
  "browser-external:stream"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "stream" has been externalized for browser compatibility. Cannot access "stream.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// .api/apis/zklighter/node_modules/caseless/index.js
var require_caseless = __commonJS({
  ".api/apis/zklighter/node_modules/caseless/index.js"(exports, module) {
    function Caseless(dict) {
      this.dict = dict || {};
    }
    Caseless.prototype.set = function(name, value, clobber) {
      if (typeof name === "object") {
        for (var i in name) {
          this.set(i, name[i], value);
        }
      } else {
        if (typeof clobber === "undefined") clobber = true;
        var has = this.has(name);
        if (!clobber && has) this.dict[has] = this.dict[has] + "," + value;
        else this.dict[has || name] = value;
        return has;
      }
    };
    Caseless.prototype.has = function(name) {
      var keys = Object.keys(this.dict), name = name.toLowerCase();
      for (var i = 0; i < keys.length; i++) {
        if (keys[i].toLowerCase() === name) return keys[i];
      }
      return false;
    };
    Caseless.prototype.get = function(name) {
      name = name.toLowerCase();
      var result, _key;
      var headers = this.dict;
      Object.keys(headers).forEach(function(key) {
        _key = key.toLowerCase();
        if (name === _key) result = headers[key];
      });
      return result;
    };
    Caseless.prototype.swap = function(name) {
      var has = this.has(name);
      if (has === name) return;
      if (!has) throw new Error('There is no header than matches "' + name + '"');
      this.dict[name] = this.dict[has];
      delete this.dict[has];
    };
    Caseless.prototype.del = function(name) {
      var has = this.has(name);
      return delete this.dict[has || name];
    };
    module.exports = function(dict) {
      return new Caseless(dict);
    };
    module.exports.httpify = function(resp, headers) {
      var c = new Caseless(headers);
      resp.setHeader = function(key, value, clobber) {
        if (typeof value === "undefined") return;
        return c.set(key, value, clobber);
      };
      resp.hasHeader = function(key) {
        return c.has(key);
      };
      resp.getHeader = function(key) {
        return c.get(key);
      };
      resp.removeHeader = function(key) {
        return c.del(key);
      };
      resp.headers = c.dict;
      return c;
    };
  }
});

// .api/apis/zklighter/node_modules/mimer/map.js
var require_map = __commonJS({
  ".api/apis/zklighter/node_modules/mimer/map.js"(exports, module) {
    module.exports = /* @__PURE__ */ new Map([["ez", "application/andrew-inset"], ["aw", "application/applixware"], ["atom", "application/atom+xml"], ["atomcat", "application/atomcat+xml"], ["atomdeleted", "application/atomdeleted+xml"], ["atomsvc", "application/atomsvc+xml"], ["dwd", "application/atsc-dwd+xml"], ["held", "application/atsc-held+xml"], ["rsat", "application/atsc-rsat+xml"], ["bdoc", "application/bdoc"], ["xcs", "application/calendar+xml"], ["ccxml", "application/ccxml+xml"], ["cdfx", "application/cdfx+xml"], ["cdmia", "application/cdmi-capability"], ["cdmic", "application/cdmi-container"], ["cdmid", "application/cdmi-domain"], ["cdmio", "application/cdmi-object"], ["cdmiq", "application/cdmi-queue"], ["cu", "application/cu-seeme"], ["mpd", "application/dash+xml"], ["davmount", "application/davmount+xml"], ["dbk", "application/docbook+xml"], ["dssc", "application/dssc+der"], ["xdssc", "application/dssc+xml"], ["es", "application/ecmascript"], ["ecma", "application/ecmascript"], ["emma", "application/emma+xml"], ["emotionml", "application/emotionml+xml"], ["epub", "application/epub+zip"], ["exi", "application/exi"], ["fdt", "application/fdt+xml"], ["pfr", "application/font-tdpfr"], ["geojson", "application/geo+json"], ["gml", "application/gml+xml"], ["gpx", "application/gpx+xml"], ["gxf", "application/gxf"], ["gz", "application/gzip"], ["hjson", "application/hjson"], ["stk", "application/hyperstudio"], ["ink", "application/inkml+xml"], ["inkml", "application/inkml+xml"], ["ipfix", "application/ipfix"], ["its", "application/its+xml"], ["jar", "application/java-archive"], ["war", "application/java-archive"], ["ear", "application/java-archive"], ["ser", "application/java-serialized-object"], ["class", "application/java-vm"], ["js", "application/javascript"], ["mjs", "application/javascript"], ["json", "application/json"], ["map", "application/json"], ["json5", "application/json5"], ["jsonml", "application/jsonml+json"], ["jsonld", "application/ld+json"], ["lgr", "application/lgr+xml"], ["lostxml", "application/lost+xml"], ["hqx", "application/mac-binhex40"], ["cpt", "application/mac-compactpro"], ["mads", "application/mads+xml"], ["webmanifest", "application/manifest+json"], ["mrc", "application/marc"], ["mrcx", "application/marcxml+xml"], ["ma", "application/mathematica"], ["nb", "application/mathematica"], ["mb", "application/mathematica"], ["mathml", "application/mathml+xml"], ["mbox", "application/mbox"], ["mscml", "application/mediaservercontrol+xml"], ["metalink", "application/metalink+xml"], ["meta4", "application/metalink4+xml"], ["mets", "application/mets+xml"], ["maei", "application/mmt-aei+xml"], ["musd", "application/mmt-usd+xml"], ["mods", "application/mods+xml"], ["m21", "application/mp21"], ["mp21", "application/mp21"], ["mp4s", "application/mp4"], ["m4p", "application/mp4"], ["doc", "application/msword"], ["dot", "application/msword"], ["mxf", "application/mxf"], ["nq", "application/n-quads"], ["nt", "application/n-triples"], ["cjs", "application/node"], ["bin", "application/octet-stream"], ["dms", "application/octet-stream"], ["lrf", "application/octet-stream"], ["mar", "application/octet-stream"], ["so", "application/octet-stream"], ["dist", "application/octet-stream"], ["distz", "application/octet-stream"], ["pkg", "application/octet-stream"], ["bpk", "application/octet-stream"], ["dump", "application/octet-stream"], ["elc", "application/octet-stream"], ["deploy", "application/octet-stream"], ["exe", "application/octet-stream"], ["dll", "application/octet-stream"], ["deb", "application/octet-stream"], ["dmg", "application/octet-stream"], ["iso", "application/octet-stream"], ["img", "application/octet-stream"], ["msi", "application/octet-stream"], ["msp", "application/octet-stream"], ["msm", "application/octet-stream"], ["buffer", "application/octet-stream"], ["oda", "application/oda"], ["opf", "application/oebps-package+xml"], ["ogx", "application/ogg"], ["omdoc", "application/omdoc+xml"], ["onetoc", "application/onenote"], ["onetoc2", "application/onenote"], ["onetmp", "application/onenote"], ["onepkg", "application/onenote"], ["oxps", "application/oxps"], ["relo", "application/p2p-overlay+xml"], ["xer", "application/patch-ops-error+xml"], ["pdf", "application/pdf"], ["pgp", "application/pgp-encrypted"], ["asc", "application/pgp-signature"], ["sig", "application/pgp-signature"], ["prf", "application/pics-rules"], ["p10", "application/pkcs10"], ["p7m", "application/pkcs7-mime"], ["p7c", "application/pkcs7-mime"], ["p7s", "application/pkcs7-signature"], ["p8", "application/pkcs8"], ["ac", "application/pkix-attr-cert"], ["cer", "application/pkix-cert"], ["crl", "application/pkix-crl"], ["pkipath", "application/pkix-pkipath"], ["pki", "application/pkixcmp"], ["pls", "application/pls+xml"], ["ai", "application/postscript"], ["eps", "application/postscript"], ["ps", "application/postscript"], ["provx", "application/provenance+xml"], ["cww", "application/prs.cww"], ["pskcxml", "application/pskc+xml"], ["raml", "application/raml+yaml"], ["rdf", "application/rdf+xml"], ["owl", "application/rdf+xml"], ["rif", "application/reginfo+xml"], ["rnc", "application/relax-ng-compact-syntax"], ["rl", "application/resource-lists+xml"], ["rld", "application/resource-lists-diff+xml"], ["rs", "application/rls-services+xml"], ["rapd", "application/route-apd+xml"], ["sls", "application/route-s-tsid+xml"], ["rusd", "application/route-usd+xml"], ["gbr", "application/rpki-ghostbusters"], ["mft", "application/rpki-manifest"], ["roa", "application/rpki-roa"], ["rsd", "application/rsd+xml"], ["rss", "application/rss+xml"], ["rtf", "application/rtf"], ["sbml", "application/sbml+xml"], ["scq", "application/scvp-cv-request"], ["scs", "application/scvp-cv-response"], ["spq", "application/scvp-vp-request"], ["spp", "application/scvp-vp-response"], ["sdp", "application/sdp"], ["senmlx", "application/senml+xml"], ["sensmlx", "application/sensml+xml"], ["setpay", "application/set-payment-initiation"], ["setreg", "application/set-registration-initiation"], ["shf", "application/shf+xml"], ["siv", "application/sieve"], ["sieve", "application/sieve"], ["smi", "application/smil+xml"], ["smil", "application/smil+xml"], ["rq", "application/sparql-query"], ["srx", "application/sparql-results+xml"], ["gram", "application/srgs"], ["grxml", "application/srgs+xml"], ["sru", "application/sru+xml"], ["ssdl", "application/ssdl+xml"], ["ssml", "application/ssml+xml"], ["swidtag", "application/swid+xml"], ["tei", "application/tei+xml"], ["teicorpus", "application/tei+xml"], ["tfi", "application/thraud+xml"], ["tsd", "application/timestamped-data"], ["toml", "application/toml"], ["trig", "application/trig"], ["ttml", "application/ttml+xml"], ["ubj", "application/ubjson"], ["rsheet", "application/urc-ressheet+xml"], ["td", "application/urc-targetdesc+xml"], ["1km", "application/vnd.1000minds.decision-model+xml"], ["plb", "application/vnd.3gpp.pic-bw-large"], ["psb", "application/vnd.3gpp.pic-bw-small"], ["pvb", "application/vnd.3gpp.pic-bw-var"], ["tcap", "application/vnd.3gpp2.tcap"], ["pwn", "application/vnd.3m.post-it-notes"], ["aso", "application/vnd.accpac.simply.aso"], ["imp", "application/vnd.accpac.simply.imp"], ["acu", "application/vnd.acucobol"], ["atc", "application/vnd.acucorp"], ["acutc", "application/vnd.acucorp"], ["air", "application/vnd.adobe.air-application-installer-package+zip"], ["fcdt", "application/vnd.adobe.formscentral.fcdt"], ["fxp", "application/vnd.adobe.fxp"], ["fxpl", "application/vnd.adobe.fxp"], ["xdp", "application/vnd.adobe.xdp+xml"], ["xfdf", "application/vnd.adobe.xfdf"], ["ahead", "application/vnd.ahead.space"], ["azf", "application/vnd.airzip.filesecure.azf"], ["azs", "application/vnd.airzip.filesecure.azs"], ["azw", "application/vnd.amazon.ebook"], ["acc", "application/vnd.americandynamics.acc"], ["ami", "application/vnd.amiga.ami"], ["apk", "application/vnd.android.package-archive"], ["cii", "application/vnd.anser-web-certificate-issue-initiation"], ["fti", "application/vnd.anser-web-funds-transfer-initiation"], ["atx", "application/vnd.antix.game-component"], ["mpkg", "application/vnd.apple.installer+xml"], ["key", "application/vnd.apple.keynote"], ["m3u8", "application/vnd.apple.mpegurl"], ["numbers", "application/vnd.apple.numbers"], ["pages", "application/vnd.apple.pages"], ["pkpass", "application/vnd.apple.pkpass"], ["swi", "application/vnd.aristanetworks.swi"], ["iota", "application/vnd.astraea-software.iota"], ["aep", "application/vnd.audiograph"], ["bmml", "application/vnd.balsamiq.bmml+xml"], ["mpm", "application/vnd.blueice.multipass"], ["bmi", "application/vnd.bmi"], ["rep", "application/vnd.businessobjects"], ["cdxml", "application/vnd.chemdraw+xml"], ["mmd", "application/vnd.chipnuts.karaoke-mmd"], ["cdy", "application/vnd.cinderella"], ["csl", "application/vnd.citationstyles.style+xml"], ["cla", "application/vnd.claymore"], ["rp9", "application/vnd.cloanto.rp9"], ["c4g", "application/vnd.clonk.c4group"], ["c4d", "application/vnd.clonk.c4group"], ["c4f", "application/vnd.clonk.c4group"], ["c4p", "application/vnd.clonk.c4group"], ["c4u", "application/vnd.clonk.c4group"], ["c11amc", "application/vnd.cluetrust.cartomobile-config"], ["c11amz", "application/vnd.cluetrust.cartomobile-config-pkg"], ["csp", "application/vnd.commonspace"], ["cdbcmsg", "application/vnd.contact.cmsg"], ["cmc", "application/vnd.cosmocaller"], ["clkx", "application/vnd.crick.clicker"], ["clkk", "application/vnd.crick.clicker.keyboard"], ["clkp", "application/vnd.crick.clicker.palette"], ["clkt", "application/vnd.crick.clicker.template"], ["clkw", "application/vnd.crick.clicker.wordbank"], ["wbs", "application/vnd.criticaltools.wbs+xml"], ["pml", "application/vnd.ctc-posml"], ["ppd", "application/vnd.cups-ppd"], ["car", "application/vnd.curl.car"], ["pcurl", "application/vnd.curl.pcurl"], ["dart", "application/vnd.dart"], ["rdz", "application/vnd.data-vision.rdz"], ["dbf", "application/vnd.dbf"], ["uvf", "application/vnd.dece.data"], ["uvvf", "application/vnd.dece.data"], ["uvd", "application/vnd.dece.data"], ["uvvd", "application/vnd.dece.data"], ["uvt", "application/vnd.dece.ttml+xml"], ["uvvt", "application/vnd.dece.ttml+xml"], ["uvx", "application/vnd.dece.unspecified"], ["uvvx", "application/vnd.dece.unspecified"], ["uvz", "application/vnd.dece.zip"], ["uvvz", "application/vnd.dece.zip"], ["fe_launch", "application/vnd.denovo.fcselayout-link"], ["dna", "application/vnd.dna"], ["mlp", "application/vnd.dolby.mlp"], ["dpg", "application/vnd.dpgraph"], ["dfac", "application/vnd.dreamfactory"], ["kpxx", "application/vnd.ds-keypoint"], ["ait", "application/vnd.dvb.ait"], ["svc", "application/vnd.dvb.service"], ["geo", "application/vnd.dynageo"], ["mag", "application/vnd.ecowin.chart"], ["nml", "application/vnd.enliven"], ["esf", "application/vnd.epson.esf"], ["msf", "application/vnd.epson.msf"], ["qam", "application/vnd.epson.quickanime"], ["slt", "application/vnd.epson.salt"], ["ssf", "application/vnd.epson.ssf"], ["es3", "application/vnd.eszigno3+xml"], ["et3", "application/vnd.eszigno3+xml"], ["ez2", "application/vnd.ezpix-album"], ["ez3", "application/vnd.ezpix-package"], ["fdf", "application/vnd.fdf"], ["mseed", "application/vnd.fdsn.mseed"], ["seed", "application/vnd.fdsn.seed"], ["dataless", "application/vnd.fdsn.seed"], ["gph", "application/vnd.flographit"], ["ftc", "application/vnd.fluxtime.clip"], ["fm", "application/vnd.framemaker"], ["frame", "application/vnd.framemaker"], ["maker", "application/vnd.framemaker"], ["book", "application/vnd.framemaker"], ["fnc", "application/vnd.frogans.fnc"], ["ltf", "application/vnd.frogans.ltf"], ["fsc", "application/vnd.fsc.weblaunch"], ["oas", "application/vnd.fujitsu.oasys"], ["oa2", "application/vnd.fujitsu.oasys2"], ["oa3", "application/vnd.fujitsu.oasys3"], ["fg5", "application/vnd.fujitsu.oasysgp"], ["bh2", "application/vnd.fujitsu.oasysprs"], ["ddd", "application/vnd.fujixerox.ddd"], ["xdw", "application/vnd.fujixerox.docuworks"], ["xbd", "application/vnd.fujixerox.docuworks.binder"], ["fzs", "application/vnd.fuzzysheet"], ["txd", "application/vnd.genomatix.tuxedo"], ["ggb", "application/vnd.geogebra.file"], ["ggt", "application/vnd.geogebra.tool"], ["gex", "application/vnd.geometry-explorer"], ["gre", "application/vnd.geometry-explorer"], ["gxt", "application/vnd.geonext"], ["g2w", "application/vnd.geoplan"], ["g3w", "application/vnd.geospace"], ["gmx", "application/vnd.gmx"], ["gdoc", "application/vnd.google-apps.document"], ["gslides", "application/vnd.google-apps.presentation"], ["gsheet", "application/vnd.google-apps.spreadsheet"], ["kml", "application/vnd.google-earth.kml+xml"], ["kmz", "application/vnd.google-earth.kmz"], ["gqf", "application/vnd.grafeq"], ["gqs", "application/vnd.grafeq"], ["gac", "application/vnd.groove-account"], ["ghf", "application/vnd.groove-help"], ["gim", "application/vnd.groove-identity-message"], ["grv", "application/vnd.groove-injector"], ["gtm", "application/vnd.groove-tool-message"], ["tpl", "application/vnd.groove-tool-template"], ["vcg", "application/vnd.groove-vcard"], ["hal", "application/vnd.hal+xml"], ["zmm", "application/vnd.handheld-entertainment+xml"], ["hbci", "application/vnd.hbci"], ["les", "application/vnd.hhe.lesson-player"], ["hpgl", "application/vnd.hp-hpgl"], ["hpid", "application/vnd.hp-hpid"], ["hps", "application/vnd.hp-hps"], ["jlt", "application/vnd.hp-jlyt"], ["pcl", "application/vnd.hp-pcl"], ["pclxl", "application/vnd.hp-pclxl"], ["sfd-hdstx", "application/vnd.hydrostatix.sof-data"], ["mpy", "application/vnd.ibm.minipay"], ["afp", "application/vnd.ibm.modcap"], ["listafp", "application/vnd.ibm.modcap"], ["list3820", "application/vnd.ibm.modcap"], ["irm", "application/vnd.ibm.rights-management"], ["sc", "application/vnd.ibm.secure-container"], ["icc", "application/vnd.iccprofile"], ["icm", "application/vnd.iccprofile"], ["igl", "application/vnd.igloader"], ["ivp", "application/vnd.immervision-ivp"], ["ivu", "application/vnd.immervision-ivu"], ["igm", "application/vnd.insors.igm"], ["xpw", "application/vnd.intercon.formnet"], ["xpx", "application/vnd.intercon.formnet"], ["i2g", "application/vnd.intergeo"], ["qbo", "application/vnd.intu.qbo"], ["qfx", "application/vnd.intu.qfx"], ["rcprofile", "application/vnd.ipunplugged.rcprofile"], ["irp", "application/vnd.irepository.package+xml"], ["xpr", "application/vnd.is-xpr"], ["fcs", "application/vnd.isac.fcs"], ["jam", "application/vnd.jam"], ["rms", "application/vnd.jcp.javame.midlet-rms"], ["jisp", "application/vnd.jisp"], ["joda", "application/vnd.joost.joda-archive"], ["ktz", "application/vnd.kahootz"], ["ktr", "application/vnd.kahootz"], ["karbon", "application/vnd.kde.karbon"], ["chrt", "application/vnd.kde.kchart"], ["kfo", "application/vnd.kde.kformula"], ["flw", "application/vnd.kde.kivio"], ["kon", "application/vnd.kde.kontour"], ["kpr", "application/vnd.kde.kpresenter"], ["kpt", "application/vnd.kde.kpresenter"], ["ksp", "application/vnd.kde.kspread"], ["kwd", "application/vnd.kde.kword"], ["kwt", "application/vnd.kde.kword"], ["htke", "application/vnd.kenameaapp"], ["kia", "application/vnd.kidspiration"], ["kne", "application/vnd.kinar"], ["knp", "application/vnd.kinar"], ["skp", "application/vnd.koan"], ["skd", "application/vnd.koan"], ["skt", "application/vnd.koan"], ["skm", "application/vnd.koan"], ["sse", "application/vnd.kodak-descriptor"], ["lasxml", "application/vnd.las.las+xml"], ["lbd", "application/vnd.llamagraphics.life-balance.desktop"], ["lbe", "application/vnd.llamagraphics.life-balance.exchange+xml"], ["123", "application/vnd.lotus-1-2-3"], ["apr", "application/vnd.lotus-approach"], ["pre", "application/vnd.lotus-freelance"], ["nsf", "application/vnd.lotus-notes"], ["org", "application/vnd.lotus-organizer"], ["scm", "application/vnd.lotus-screencam"], ["lwp", "application/vnd.lotus-wordpro"], ["portpkg", "application/vnd.macports.portpkg"], ["mvt", "application/vnd.mapbox-vector-tile"], ["mcd", "application/vnd.mcd"], ["mc1", "application/vnd.medcalcdata"], ["cdkey", "application/vnd.mediastation.cdkey"], ["mwf", "application/vnd.mfer"], ["mfm", "application/vnd.mfmp"], ["flo", "application/vnd.micrografx.flo"], ["igx", "application/vnd.micrografx.igx"], ["mif", "application/vnd.mif"], ["daf", "application/vnd.mobius.daf"], ["dis", "application/vnd.mobius.dis"], ["mbk", "application/vnd.mobius.mbk"], ["mqy", "application/vnd.mobius.mqy"], ["msl", "application/vnd.mobius.msl"], ["plc", "application/vnd.mobius.plc"], ["txf", "application/vnd.mobius.txf"], ["mpn", "application/vnd.mophun.application"], ["mpc", "application/vnd.mophun.certificate"], ["xul", "application/vnd.mozilla.xul+xml"], ["cil", "application/vnd.ms-artgalry"], ["cab", "application/vnd.ms-cab-compressed"], ["xls", "application/vnd.ms-excel"], ["xlm", "application/vnd.ms-excel"], ["xla", "application/vnd.ms-excel"], ["xlc", "application/vnd.ms-excel"], ["xlt", "application/vnd.ms-excel"], ["xlw", "application/vnd.ms-excel"], ["xlam", "application/vnd.ms-excel.addin.macroenabled.12"], ["xlsb", "application/vnd.ms-excel.sheet.binary.macroenabled.12"], ["xlsm", "application/vnd.ms-excel.sheet.macroenabled.12"], ["xltm", "application/vnd.ms-excel.template.macroenabled.12"], ["eot", "application/vnd.ms-fontobject"], ["chm", "application/vnd.ms-htmlhelp"], ["ims", "application/vnd.ms-ims"], ["lrm", "application/vnd.ms-lrm"], ["thmx", "application/vnd.ms-officetheme"], ["msg", "application/vnd.ms-outlook"], ["cat", "application/vnd.ms-pki.seccat"], ["stl", "application/vnd.ms-pki.stl"], ["ppt", "application/vnd.ms-powerpoint"], ["pps", "application/vnd.ms-powerpoint"], ["pot", "application/vnd.ms-powerpoint"], ["ppam", "application/vnd.ms-powerpoint.addin.macroenabled.12"], ["pptm", "application/vnd.ms-powerpoint.presentation.macroenabled.12"], ["sldm", "application/vnd.ms-powerpoint.slide.macroenabled.12"], ["ppsm", "application/vnd.ms-powerpoint.slideshow.macroenabled.12"], ["potm", "application/vnd.ms-powerpoint.template.macroenabled.12"], ["mpp", "application/vnd.ms-project"], ["mpt", "application/vnd.ms-project"], ["docm", "application/vnd.ms-word.document.macroenabled.12"], ["dotm", "application/vnd.ms-word.template.macroenabled.12"], ["wps", "application/vnd.ms-works"], ["wks", "application/vnd.ms-works"], ["wcm", "application/vnd.ms-works"], ["wdb", "application/vnd.ms-works"], ["wpl", "application/vnd.ms-wpl"], ["xps", "application/vnd.ms-xpsdocument"], ["mseq", "application/vnd.mseq"], ["mus", "application/vnd.musician"], ["msty", "application/vnd.muvee.style"], ["taglet", "application/vnd.mynfc"], ["nlu", "application/vnd.neurolanguage.nlu"], ["ntf", "application/vnd.nitf"], ["nitf", "application/vnd.nitf"], ["nnd", "application/vnd.noblenet-directory"], ["nns", "application/vnd.noblenet-sealer"], ["nnw", "application/vnd.noblenet-web"], ["ac", "application/vnd.nokia.n-gage.ac+xml"], ["ngdat", "application/vnd.nokia.n-gage.data"], ["n-gage", "application/vnd.nokia.n-gage.symbian.install"], ["rpst", "application/vnd.nokia.radio-preset"], ["rpss", "application/vnd.nokia.radio-presets"], ["edm", "application/vnd.novadigm.edm"], ["edx", "application/vnd.novadigm.edx"], ["ext", "application/vnd.novadigm.ext"], ["odc", "application/vnd.oasis.opendocument.chart"], ["otc", "application/vnd.oasis.opendocument.chart-template"], ["odb", "application/vnd.oasis.opendocument.database"], ["odf", "application/vnd.oasis.opendocument.formula"], ["odft", "application/vnd.oasis.opendocument.formula-template"], ["odg", "application/vnd.oasis.opendocument.graphics"], ["otg", "application/vnd.oasis.opendocument.graphics-template"], ["odi", "application/vnd.oasis.opendocument.image"], ["oti", "application/vnd.oasis.opendocument.image-template"], ["odp", "application/vnd.oasis.opendocument.presentation"], ["otp", "application/vnd.oasis.opendocument.presentation-template"], ["ods", "application/vnd.oasis.opendocument.spreadsheet"], ["ots", "application/vnd.oasis.opendocument.spreadsheet-template"], ["odt", "application/vnd.oasis.opendocument.text"], ["odm", "application/vnd.oasis.opendocument.text-master"], ["ott", "application/vnd.oasis.opendocument.text-template"], ["oth", "application/vnd.oasis.opendocument.text-web"], ["xo", "application/vnd.olpc-sugar"], ["dd2", "application/vnd.oma.dd2+xml"], ["obgx", "application/vnd.openblox.game+xml"], ["oxt", "application/vnd.openofficeorg.extension"], ["osm", "application/vnd.openstreetmap.data+xml"], ["pptx", "application/vnd.openxmlformats-officedocument.presentationml.presentation"], ["sldx", "application/vnd.openxmlformats-officedocument.presentationml.slide"], ["ppsx", "application/vnd.openxmlformats-officedocument.presentationml.slideshow"], ["potx", "application/vnd.openxmlformats-officedocument.presentationml.template"], ["xlsx", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"], ["xltx", "application/vnd.openxmlformats-officedocument.spreadsheetml.template"], ["docx", "application/vnd.openxmlformats-officedocument.wordprocessingml.document"], ["dotx", "application/vnd.openxmlformats-officedocument.wordprocessingml.template"], ["mgp", "application/vnd.osgeo.mapguide.package"], ["dp", "application/vnd.osgi.dp"], ["esa", "application/vnd.osgi.subsystem"], ["pdb", "application/vnd.palm"], ["pqa", "application/vnd.palm"], ["oprc", "application/vnd.palm"], ["paw", "application/vnd.pawaafile"], ["str", "application/vnd.pg.format"], ["ei6", "application/vnd.pg.osasli"], ["efif", "application/vnd.picsel"], ["wg", "application/vnd.pmi.widget"], ["plf", "application/vnd.pocketlearn"], ["pbd", "application/vnd.powerbuilder6"], ["box", "application/vnd.previewsystems.box"], ["mgz", "application/vnd.proteus.magazine"], ["qps", "application/vnd.publishare-delta-tree"], ["ptid", "application/vnd.pvi.ptid1"], ["qxd", "application/vnd.quark.quarkxpress"], ["qxt", "application/vnd.quark.quarkxpress"], ["qwd", "application/vnd.quark.quarkxpress"], ["qwt", "application/vnd.quark.quarkxpress"], ["qxl", "application/vnd.quark.quarkxpress"], ["qxb", "application/vnd.quark.quarkxpress"], ["rar", "application/vnd.rar"], ["bed", "application/vnd.realvnc.bed"], ["mxl", "application/vnd.recordare.musicxml"], ["musicxml", "application/vnd.recordare.musicxml+xml"], ["cryptonote", "application/vnd.rig.cryptonote"], ["cod", "application/vnd.rim.cod"], ["rm", "application/vnd.rn-realmedia"], ["rmvb", "application/vnd.rn-realmedia-vbr"], ["link66", "application/vnd.route66.link66+xml"], ["st", "application/vnd.sailingtracker.track"], ["see", "application/vnd.seemail"], ["sema", "application/vnd.sema"], ["semd", "application/vnd.semd"], ["semf", "application/vnd.semf"], ["ifm", "application/vnd.shana.informed.formdata"], ["itp", "application/vnd.shana.informed.formtemplate"], ["iif", "application/vnd.shana.informed.interchange"], ["ipk", "application/vnd.shana.informed.package"], ["twd", "application/vnd.simtech-mindmapper"], ["twds", "application/vnd.simtech-mindmapper"], ["mmf", "application/vnd.smaf"], ["teacher", "application/vnd.smart.teacher"], ["fo", "application/vnd.software602.filler.form+xml"], ["sdkm", "application/vnd.solent.sdkm+xml"], ["sdkd", "application/vnd.solent.sdkm+xml"], ["dxp", "application/vnd.spotfire.dxp"], ["sfs", "application/vnd.spotfire.sfs"], ["sdc", "application/vnd.stardivision.calc"], ["sda", "application/vnd.stardivision.draw"], ["sdd", "application/vnd.stardivision.impress"], ["smf", "application/vnd.stardivision.math"], ["sdw", "application/vnd.stardivision.writer"], ["vor", "application/vnd.stardivision.writer"], ["sgl", "application/vnd.stardivision.writer-global"], ["smzip", "application/vnd.stepmania.package"], ["sm", "application/vnd.stepmania.stepchart"], ["wadl", "application/vnd.sun.wadl+xml"], ["sxc", "application/vnd.sun.xml.calc"], ["stc", "application/vnd.sun.xml.calc.template"], ["sxd", "application/vnd.sun.xml.draw"], ["std", "application/vnd.sun.xml.draw.template"], ["sxi", "application/vnd.sun.xml.impress"], ["sti", "application/vnd.sun.xml.impress.template"], ["sxm", "application/vnd.sun.xml.math"], ["sxw", "application/vnd.sun.xml.writer"], ["sxg", "application/vnd.sun.xml.writer.global"], ["stw", "application/vnd.sun.xml.writer.template"], ["sus", "application/vnd.sus-calendar"], ["susp", "application/vnd.sus-calendar"], ["svd", "application/vnd.svd"], ["sis", "application/vnd.symbian.install"], ["sisx", "application/vnd.symbian.install"], ["xsm", "application/vnd.syncml+xml"], ["bdm", "application/vnd.syncml.dm+wbxml"], ["xdm", "application/vnd.syncml.dm+xml"], ["ddf", "application/vnd.syncml.dmddf+xml"], ["tao", "application/vnd.tao.intent-module-archive"], ["pcap", "application/vnd.tcpdump.pcap"], ["cap", "application/vnd.tcpdump.pcap"], ["dmp", "application/vnd.tcpdump.pcap"], ["tmo", "application/vnd.tmobile-livetv"], ["tpt", "application/vnd.trid.tpt"], ["mxs", "application/vnd.triscape.mxs"], ["tra", "application/vnd.trueapp"], ["ufd", "application/vnd.ufdl"], ["ufdl", "application/vnd.ufdl"], ["utz", "application/vnd.uiq.theme"], ["umj", "application/vnd.umajin"], ["unityweb", "application/vnd.unity"], ["uoml", "application/vnd.uoml+xml"], ["vcx", "application/vnd.vcx"], ["vsd", "application/vnd.visio"], ["vst", "application/vnd.visio"], ["vss", "application/vnd.visio"], ["vsw", "application/vnd.visio"], ["vis", "application/vnd.visionary"], ["vsf", "application/vnd.vsf"], ["wbxml", "application/vnd.wap.wbxml"], ["wmlc", "application/vnd.wap.wmlc"], ["wmlsc", "application/vnd.wap.wmlscriptc"], ["wtb", "application/vnd.webturbo"], ["nbp", "application/vnd.wolfram.player"], ["wpd", "application/vnd.wordperfect"], ["wqd", "application/vnd.wqd"], ["stf", "application/vnd.wt.stf"], ["xar", "application/vnd.xara"], ["xfdl", "application/vnd.xfdl"], ["hvd", "application/vnd.yamaha.hv-dic"], ["hvs", "application/vnd.yamaha.hv-script"], ["hvp", "application/vnd.yamaha.hv-voice"], ["osf", "application/vnd.yamaha.openscoreformat"], ["osfpvg", "application/vnd.yamaha.openscoreformat.osfpvg+xml"], ["saf", "application/vnd.yamaha.smaf-audio"], ["spf", "application/vnd.yamaha.smaf-phrase"], ["cmp", "application/vnd.yellowriver-custom-menu"], ["zir", "application/vnd.zul"], ["zirz", "application/vnd.zul"], ["zaz", "application/vnd.zzazz.deck+xml"], ["vxml", "application/voicexml+xml"], ["wasm", "application/wasm"], ["wgt", "application/widget"], ["hlp", "application/winhlp"], ["wsdl", "application/wsdl+xml"], ["wspolicy", "application/wspolicy+xml"], ["7z", "application/x-7z-compressed"], ["abw", "application/x-abiword"], ["ace", "application/x-ace-compressed"], ["dmg", "application/x-apple-diskimage"], ["arj", "application/x-arj"], ["aab", "application/x-authorware-bin"], ["x32", "application/x-authorware-bin"], ["u32", "application/x-authorware-bin"], ["vox", "application/x-authorware-bin"], ["aam", "application/x-authorware-map"], ["aas", "application/x-authorware-seg"], ["bcpio", "application/x-bcpio"], ["bdoc", "application/x-bdoc"], ["torrent", "application/x-bittorrent"], ["blb", "application/x-blorb"], ["blorb", "application/x-blorb"], ["bz", "application/x-bzip"], ["bz2", "application/x-bzip2"], ["boz", "application/x-bzip2"], ["cbr", "application/x-cbr"], ["cba", "application/x-cbr"], ["cbt", "application/x-cbr"], ["cbz", "application/x-cbr"], ["cb7", "application/x-cbr"], ["vcd", "application/x-cdlink"], ["cfs", "application/x-cfs-compressed"], ["chat", "application/x-chat"], ["pgn", "application/x-chess-pgn"], ["crx", "application/x-chrome-extension"], ["cco", "application/x-cocoa"], ["nsc", "application/x-conference"], ["cpio", "application/x-cpio"], ["csh", "application/x-csh"], ["deb", "application/x-debian-package"], ["udeb", "application/x-debian-package"], ["dgc", "application/x-dgc-compressed"], ["dir", "application/x-director"], ["dcr", "application/x-director"], ["dxr", "application/x-director"], ["cst", "application/x-director"], ["cct", "application/x-director"], ["cxt", "application/x-director"], ["w3d", "application/x-director"], ["fgd", "application/x-director"], ["swa", "application/x-director"], ["wad", "application/x-doom"], ["ncx", "application/x-dtbncx+xml"], ["dtb", "application/x-dtbook+xml"], ["res", "application/x-dtbresource+xml"], ["dvi", "application/x-dvi"], ["evy", "application/x-envoy"], ["eva", "application/x-eva"], ["bdf", "application/x-font-bdf"], ["gsf", "application/x-font-ghostscript"], ["psf", "application/x-font-linux-psf"], ["pcf", "application/x-font-pcf"], ["snf", "application/x-font-snf"], ["pfa", "application/x-font-type1"], ["pfb", "application/x-font-type1"], ["pfm", "application/x-font-type1"], ["afm", "application/x-font-type1"], ["arc", "application/x-freearc"], ["spl", "application/x-futuresplash"], ["gca", "application/x-gca-compressed"], ["ulx", "application/x-glulx"], ["gnumeric", "application/x-gnumeric"], ["gramps", "application/x-gramps-xml"], ["gtar", "application/x-gtar"], ["hdf", "application/x-hdf"], ["php", "application/x-httpd-php"], ["install", "application/x-install-instructions"], ["iso", "application/x-iso9660-image"], ["jardiff", "application/x-java-archive-diff"], ["jnlp", "application/x-java-jnlp-file"], ["kdbx", "application/x-keepass2"], ["latex", "application/x-latex"], ["luac", "application/x-lua-bytecode"], ["lzh", "application/x-lzh-compressed"], ["lha", "application/x-lzh-compressed"], ["run", "application/x-makeself"], ["mie", "application/x-mie"], ["prc", "application/x-mobipocket-ebook"], ["mobi", "application/x-mobipocket-ebook"], ["application", "application/x-ms-application"], ["lnk", "application/x-ms-shortcut"], ["wmd", "application/x-ms-wmd"], ["wmz", "application/x-ms-wmz"], ["xbap", "application/x-ms-xbap"], ["mdb", "application/x-msaccess"], ["obd", "application/x-msbinder"], ["crd", "application/x-mscardfile"], ["clp", "application/x-msclip"], ["exe", "application/x-msdos-program"], ["exe", "application/x-msdownload"], ["dll", "application/x-msdownload"], ["com", "application/x-msdownload"], ["bat", "application/x-msdownload"], ["msi", "application/x-msdownload"], ["mvb", "application/x-msmediaview"], ["m13", "application/x-msmediaview"], ["m14", "application/x-msmediaview"], ["wmf", "application/x-msmetafile"], ["wmz", "application/x-msmetafile"], ["emf", "application/x-msmetafile"], ["emz", "application/x-msmetafile"], ["mny", "application/x-msmoney"], ["pub", "application/x-mspublisher"], ["scd", "application/x-msschedule"], ["trm", "application/x-msterminal"], ["wri", "application/x-mswrite"], ["nc", "application/x-netcdf"], ["cdf", "application/x-netcdf"], ["pac", "application/x-ns-proxy-autoconfig"], ["nzb", "application/x-nzb"], ["pl", "application/x-perl"], ["pm", "application/x-perl"], ["prc", "application/x-pilot"], ["pdb", "application/x-pilot"], ["p12", "application/x-pkcs12"], ["pfx", "application/x-pkcs12"], ["p7b", "application/x-pkcs7-certificates"], ["spc", "application/x-pkcs7-certificates"], ["p7r", "application/x-pkcs7-certreqresp"], ["rar", "application/x-rar-compressed"], ["rpm", "application/x-redhat-package-manager"], ["ris", "application/x-research-info-systems"], ["sea", "application/x-sea"], ["sh", "application/x-sh"], ["shar", "application/x-shar"], ["swf", "application/x-shockwave-flash"], ["xap", "application/x-silverlight-app"], ["sql", "application/x-sql"], ["sit", "application/x-stuffit"], ["sitx", "application/x-stuffitx"], ["srt", "application/x-subrip"], ["sv4cpio", "application/x-sv4cpio"], ["sv4crc", "application/x-sv4crc"], ["t3", "application/x-t3vm-image"], ["gam", "application/x-tads"], ["tar", "application/x-tar"], ["tcl", "application/x-tcl"], ["tk", "application/x-tcl"], ["tex", "application/x-tex"], ["tfm", "application/x-tex-tfm"], ["texinfo", "application/x-texinfo"], ["texi", "application/x-texinfo"], ["obj", "application/x-tgif"], ["ustar", "application/x-ustar"], ["hdd", "application/x-virtualbox-hdd"], ["ova", "application/x-virtualbox-ova"], ["ovf", "application/x-virtualbox-ovf"], ["vbox", "application/x-virtualbox-vbox"], ["vbox-extpack", "application/x-virtualbox-vbox-extpack"], ["vdi", "application/x-virtualbox-vdi"], ["vhd", "application/x-virtualbox-vhd"], ["vmdk", "application/x-virtualbox-vmdk"], ["src", "application/x-wais-source"], ["webapp", "application/x-web-app-manifest+json"], ["der", "application/x-x509-ca-cert"], ["crt", "application/x-x509-ca-cert"], ["pem", "application/x-x509-ca-cert"], ["fig", "application/x-xfig"], ["xlf", "application/x-xliff+xml"], ["xpi", "application/x-xpinstall"], ["xz", "application/x-xz"], ["z1", "application/x-zmachine"], ["z2", "application/x-zmachine"], ["z3", "application/x-zmachine"], ["z4", "application/x-zmachine"], ["z5", "application/x-zmachine"], ["z6", "application/x-zmachine"], ["z7", "application/x-zmachine"], ["z8", "application/x-zmachine"], ["xaml", "application/xaml+xml"], ["xav", "application/xcap-att+xml"], ["xca", "application/xcap-caps+xml"], ["xdf", "application/xcap-diff+xml"], ["xel", "application/xcap-el+xml"], ["xns", "application/xcap-ns+xml"], ["xenc", "application/xenc+xml"], ["xhtml", "application/xhtml+xml"], ["xht", "application/xhtml+xml"], ["xlf", "application/xliff+xml"], ["xml", "application/xml"], ["xsl", "application/xml"], ["xsd", "application/xml"], ["rng", "application/xml"], ["dtd", "application/xml-dtd"], ["xop", "application/xop+xml"], ["xpl", "application/xproc+xml"], ["xsl", "application/xslt+xml"], ["xslt", "application/xslt+xml"], ["xspf", "application/xspf+xml"], ["mxml", "application/xv+xml"], ["xhvml", "application/xv+xml"], ["xvml", "application/xv+xml"], ["xvm", "application/xv+xml"], ["yang", "application/yang"], ["yin", "application/yin+xml"], ["zip", "application/zip"], ["3gpp", "audio/3gpp"], ["adp", "audio/adpcm"], ["amr", "audio/amr"], ["au", "audio/basic"], ["snd", "audio/basic"], ["mid", "audio/midi"], ["midi", "audio/midi"], ["kar", "audio/midi"], ["rmi", "audio/midi"], ["mxmf", "audio/mobile-xmf"], ["mp3", "audio/mp3"], ["m4a", "audio/mp4"], ["mp4a", "audio/mp4"], ["mpga", "audio/mpeg"], ["mp2", "audio/mpeg"], ["mp2a", "audio/mpeg"], ["mp3", "audio/mpeg"], ["m2a", "audio/mpeg"], ["m3a", "audio/mpeg"], ["oga", "audio/ogg"], ["ogg", "audio/ogg"], ["spx", "audio/ogg"], ["opus", "audio/ogg"], ["s3m", "audio/s3m"], ["sil", "audio/silk"], ["uva", "audio/vnd.dece.audio"], ["uvva", "audio/vnd.dece.audio"], ["eol", "audio/vnd.digital-winds"], ["dra", "audio/vnd.dra"], ["dts", "audio/vnd.dts"], ["dtshd", "audio/vnd.dts.hd"], ["lvp", "audio/vnd.lucent.voice"], ["pya", "audio/vnd.ms-playready.media.pya"], ["ecelp4800", "audio/vnd.nuera.ecelp4800"], ["ecelp7470", "audio/vnd.nuera.ecelp7470"], ["ecelp9600", "audio/vnd.nuera.ecelp9600"], ["rip", "audio/vnd.rip"], ["wav", "audio/wav"], ["wav", "audio/wave"], ["weba", "audio/webm"], ["aac", "audio/x-aac"], ["aif", "audio/x-aiff"], ["aiff", "audio/x-aiff"], ["aifc", "audio/x-aiff"], ["caf", "audio/x-caf"], ["flac", "audio/x-flac"], ["m4a", "audio/x-m4a"], ["mka", "audio/x-matroska"], ["m3u", "audio/x-mpegurl"], ["wax", "audio/x-ms-wax"], ["wma", "audio/x-ms-wma"], ["ram", "audio/x-pn-realaudio"], ["ra", "audio/x-pn-realaudio"], ["rmp", "audio/x-pn-realaudio-plugin"], ["ra", "audio/x-realaudio"], ["wav", "audio/x-wav"], ["xm", "audio/xm"], ["cdx", "chemical/x-cdx"], ["cif", "chemical/x-cif"], ["cmdf", "chemical/x-cmdf"], ["cml", "chemical/x-cml"], ["csml", "chemical/x-csml"], ["xyz", "chemical/x-xyz"], ["ttc", "font/collection"], ["otf", "font/otf"], ["ttf", "font/ttf"], ["woff", "font/woff"], ["woff2", "font/woff2"], ["exr", "image/aces"], ["apng", "image/apng"], ["avif", "image/avif"], ["bmp", "image/bmp"], ["cgm", "image/cgm"], ["drle", "image/dicom-rle"], ["emf", "image/emf"], ["fits", "image/fits"], ["g3", "image/g3fax"], ["gif", "image/gif"], ["heic", "image/heic"], ["heics", "image/heic-sequence"], ["heif", "image/heif"], ["heifs", "image/heif-sequence"], ["hej2", "image/hej2k"], ["hsj2", "image/hsj2"], ["ief", "image/ief"], ["jls", "image/jls"], ["jp2", "image/jp2"], ["jpg2", "image/jp2"], ["jpeg", "image/jpeg"], ["jpg", "image/jpeg"], ["jpe", "image/jpeg"], ["jph", "image/jph"], ["jhc", "image/jphc"], ["jpm", "image/jpm"], ["jpx", "image/jpx"], ["jpf", "image/jpx"], ["jxr", "image/jxr"], ["jxra", "image/jxra"], ["jxrs", "image/jxrs"], ["jxs", "image/jxs"], ["jxsc", "image/jxsc"], ["jxsi", "image/jxsi"], ["jxss", "image/jxss"], ["ktx", "image/ktx"], ["ktx2", "image/ktx2"], ["png", "image/png"], ["btif", "image/prs.btif"], ["pti", "image/prs.pti"], ["sgi", "image/sgi"], ["svg", "image/svg+xml"], ["svgz", "image/svg+xml"], ["t38", "image/t38"], ["tif", "image/tiff"], ["tiff", "image/tiff"], ["tfx", "image/tiff-fx"], ["psd", "image/vnd.adobe.photoshop"], ["azv", "image/vnd.airzip.accelerator.azv"], ["uvi", "image/vnd.dece.graphic"], ["uvvi", "image/vnd.dece.graphic"], ["uvg", "image/vnd.dece.graphic"], ["uvvg", "image/vnd.dece.graphic"], ["djvu", "image/vnd.djvu"], ["djv", "image/vnd.djvu"], ["sub", "image/vnd.dvb.subtitle"], ["dwg", "image/vnd.dwg"], ["dxf", "image/vnd.dxf"], ["fbs", "image/vnd.fastbidsheet"], ["fpx", "image/vnd.fpx"], ["fst", "image/vnd.fst"], ["mmr", "image/vnd.fujixerox.edmics-mmr"], ["rlc", "image/vnd.fujixerox.edmics-rlc"], ["ico", "image/vnd.microsoft.icon"], ["dds", "image/vnd.ms-dds"], ["mdi", "image/vnd.ms-modi"], ["wdp", "image/vnd.ms-photo"], ["npx", "image/vnd.net-fpx"], ["b16", "image/vnd.pco.b16"], ["tap", "image/vnd.tencent.tap"], ["vtf", "image/vnd.valve.source.texture"], ["wbmp", "image/vnd.wap.wbmp"], ["xif", "image/vnd.xiff"], ["pcx", "image/vnd.zbrush.pcx"], ["webp", "image/webp"], ["wmf", "image/wmf"], ["3ds", "image/x-3ds"], ["ras", "image/x-cmu-raster"], ["cmx", "image/x-cmx"], ["fh", "image/x-freehand"], ["fhc", "image/x-freehand"], ["fh4", "image/x-freehand"], ["fh5", "image/x-freehand"], ["fh7", "image/x-freehand"], ["ico", "image/x-icon"], ["jng", "image/x-jng"], ["sid", "image/x-mrsid-image"], ["bmp", "image/x-ms-bmp"], ["pcx", "image/x-pcx"], ["pic", "image/x-pict"], ["pct", "image/x-pict"], ["pnm", "image/x-portable-anymap"], ["pbm", "image/x-portable-bitmap"], ["pgm", "image/x-portable-graymap"], ["ppm", "image/x-portable-pixmap"], ["rgb", "image/x-rgb"], ["tga", "image/x-tga"], ["xbm", "image/x-xbitmap"], ["xpm", "image/x-xpixmap"], ["xwd", "image/x-xwindowdump"], ["disposition-notification", "message/disposition-notification"], ["u8msg", "message/global"], ["u8dsn", "message/global-delivery-status"], ["u8mdn", "message/global-disposition-notification"], ["u8hdr", "message/global-headers"], ["eml", "message/rfc822"], ["mime", "message/rfc822"], ["wsc", "message/vnd.wfa.wsc"], ["3mf", "model/3mf"], ["gltf", "model/gltf+json"], ["glb", "model/gltf-binary"], ["igs", "model/iges"], ["iges", "model/iges"], ["msh", "model/mesh"], ["mesh", "model/mesh"], ["silo", "model/mesh"], ["mtl", "model/mtl"], ["obj", "model/obj"], ["stpz", "model/step+zip"], ["stpxz", "model/step-xml+zip"], ["stl", "model/stl"], ["dae", "model/vnd.collada+xml"], ["dwf", "model/vnd.dwf"], ["gdl", "model/vnd.gdl"], ["gtw", "model/vnd.gtw"], ["mts", "model/vnd.mts"], ["ogex", "model/vnd.opengex"], ["x_b", "model/vnd.parasolid.transmit.binary"], ["x_t", "model/vnd.parasolid.transmit.text"], ["vds", "model/vnd.sap.vds"], ["usdz", "model/vnd.usdz+zip"], ["bsp", "model/vnd.valve.source.compiled-map"], ["vtu", "model/vnd.vtu"], ["wrl", "model/vrml"], ["vrml", "model/vrml"], ["x3db", "model/x3d+binary"], ["x3dbz", "model/x3d+binary"], ["x3db", "model/x3d+fastinfoset"], ["x3dv", "model/x3d+vrml"], ["x3dvz", "model/x3d+vrml"], ["x3d", "model/x3d+xml"], ["x3dz", "model/x3d+xml"], ["x3dv", "model/x3d-vrml"], ["appcache", "text/cache-manifest"], ["manifest", "text/cache-manifest"], ["ics", "text/calendar"], ["ifb", "text/calendar"], ["coffee", "text/coffeescript"], ["litcoffee", "text/coffeescript"], ["css", "text/css"], ["csv", "text/csv"], ["html", "text/html"], ["htm", "text/html"], ["shtml", "text/html"], ["jade", "text/jade"], ["jsx", "text/jsx"], ["less", "text/less"], ["markdown", "text/markdown"], ["md", "text/markdown"], ["mml", "text/mathml"], ["mdx", "text/mdx"], ["n3", "text/n3"], ["txt", "text/plain"], ["text", "text/plain"], ["conf", "text/plain"], ["def", "text/plain"], ["list", "text/plain"], ["log", "text/plain"], ["in", "text/plain"], ["ini", "text/plain"], ["dsc", "text/prs.lines.tag"], ["rtx", "text/richtext"], ["rtf", "text/rtf"], ["sgml", "text/sgml"], ["sgm", "text/sgml"], ["shex", "text/shex"], ["slim", "text/slim"], ["slm", "text/slim"], ["spdx", "text/spdx"], ["stylus", "text/stylus"], ["styl", "text/stylus"], ["tsv", "text/tab-separated-values"], ["t", "text/troff"], ["tr", "text/troff"], ["roff", "text/troff"], ["man", "text/troff"], ["me", "text/troff"], ["ms", "text/troff"], ["ttl", "text/turtle"], ["uri", "text/uri-list"], ["uris", "text/uri-list"], ["urls", "text/uri-list"], ["vcard", "text/vcard"], ["curl", "text/vnd.curl"], ["dcurl", "text/vnd.curl.dcurl"], ["mcurl", "text/vnd.curl.mcurl"], ["scurl", "text/vnd.curl.scurl"], ["sub", "text/vnd.dvb.subtitle"], ["fly", "text/vnd.fly"], ["flx", "text/vnd.fmi.flexstor"], ["gv", "text/vnd.graphviz"], ["3dml", "text/vnd.in3d.3dml"], ["spot", "text/vnd.in3d.spot"], ["jad", "text/vnd.sun.j2me.app-descriptor"], ["wml", "text/vnd.wap.wml"], ["wmls", "text/vnd.wap.wmlscript"], ["vtt", "text/vtt"], ["s", "text/x-asm"], ["asm", "text/x-asm"], ["c", "text/x-c"], ["cc", "text/x-c"], ["cxx", "text/x-c"], ["cpp", "text/x-c"], ["h", "text/x-c"], ["hh", "text/x-c"], ["dic", "text/x-c"], ["htc", "text/x-component"], ["f", "text/x-fortran"], ["for", "text/x-fortran"], ["f77", "text/x-fortran"], ["f90", "text/x-fortran"], ["hbs", "text/x-handlebars-template"], ["java", "text/x-java-source"], ["lua", "text/x-lua"], ["mkd", "text/x-markdown"], ["nfo", "text/x-nfo"], ["opml", "text/x-opml"], ["org", "text/x-org"], ["p", "text/x-pascal"], ["pas", "text/x-pascal"], ["pde", "text/x-processing"], ["sass", "text/x-sass"], ["scss", "text/x-scss"], ["etx", "text/x-setext"], ["sfv", "text/x-sfv"], ["ymp", "text/x-suse-ymp"], ["uu", "text/x-uuencode"], ["vcs", "text/x-vcalendar"], ["vcf", "text/x-vcard"], ["xml", "text/xml"], ["yaml", "text/yaml"], ["yml", "text/yaml"], ["3gp", "video/3gpp"], ["3gpp", "video/3gpp"], ["3g2", "video/3gpp2"], ["h261", "video/h261"], ["h263", "video/h263"], ["h264", "video/h264"], ["m4s", "video/iso.segment"], ["jpgv", "video/jpeg"], ["jpm", "video/jpm"], ["jpgm", "video/jpm"], ["mj2", "video/mj2"], ["mjp2", "video/mj2"], ["ts", "video/mp2t"], ["mp4", "video/mp4"], ["mp4v", "video/mp4"], ["mpg4", "video/mp4"], ["mpeg", "video/mpeg"], ["mpg", "video/mpeg"], ["mpe", "video/mpeg"], ["m1v", "video/mpeg"], ["m2v", "video/mpeg"], ["ogv", "video/ogg"], ["qt", "video/quicktime"], ["mov", "video/quicktime"], ["uvh", "video/vnd.dece.hd"], ["uvvh", "video/vnd.dece.hd"], ["uvm", "video/vnd.dece.mobile"], ["uvvm", "video/vnd.dece.mobile"], ["uvp", "video/vnd.dece.pd"], ["uvvp", "video/vnd.dece.pd"], ["uvs", "video/vnd.dece.sd"], ["uvvs", "video/vnd.dece.sd"], ["uvv", "video/vnd.dece.video"], ["uvvv", "video/vnd.dece.video"], ["dvb", "video/vnd.dvb.file"], ["fvt", "video/vnd.fvt"], ["mxu", "video/vnd.mpegurl"], ["m4u", "video/vnd.mpegurl"], ["pyv", "video/vnd.ms-playready.media.pyv"], ["uvu", "video/vnd.uvvu.mp4"], ["uvvu", "video/vnd.uvvu.mp4"], ["viv", "video/vnd.vivo"], ["webm", "video/webm"], ["f4v", "video/x-f4v"], ["fli", "video/x-fli"], ["flv", "video/x-flv"], ["m4v", "video/x-m4v"], ["mkv", "video/x-matroska"], ["mk3d", "video/x-matroska"], ["mks", "video/x-matroska"], ["mng", "video/x-mng"], ["asf", "video/x-ms-asf"], ["asx", "video/x-ms-asf"], ["vob", "video/x-ms-vob"], ["wm", "video/x-ms-wm"], ["wmv", "video/x-ms-wmv"], ["wmx", "video/x-ms-wmx"], ["wvx", "video/x-ms-wvx"], ["avi", "video/x-msvideo"], ["movie", "video/x-sgi-movie"], ["smv", "video/x-smv"], ["ice", "x-conference/x-cooltalk"]]);
  }
});

// .api/apis/zklighter/node_modules/mimer/index.js
var require_mimer = __commonJS({
  ".api/apis/zklighter/node_modules/mimer/index.js"(exports, module) {
    var { extname } = require_path();
    var defaultMap = require_map();
    var defaultMime = "application/octet-stream";
    module.exports = function Mimer(input, extMap = defaultMap) {
      return extMap.get(extname(`_${input.startsWith(".") ? "" : "."}${input}`).slice(1)) || defaultMime;
    };
  }
});

// .api/apis/zklighter/node_modules/datauri/template/uriTemplate.js
var require_uriTemplate = __commonJS({
  ".api/apis/zklighter/node_modules/datauri/template/uriTemplate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uriParser = void 0;
    var uriParser = ({ mimetype = "application/octet-stream", base64 = "" }) => `data:${mimetype};base64,${base64}`;
    exports.uriParser = uriParser;
  }
});

// .api/apis/zklighter/node_modules/datauri/parser.js
var require_parser = __commonJS({
  ".api/apis/zklighter/node_modules/datauri/parser.js"(exports, module) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var fs_1 = require_fs();
    var mimer_1 = __importDefault(require_mimer());
    var uriTemplate_1 = require_uriTemplate();
    var { readFile } = fs_1.promises;
    var DataURIParser = class {
      async encode(fileName, handler) {
        try {
          const buffer = await readFile(fileName);
          this.format(fileName, buffer);
          handler && handler(void 0, this.content, this);
          return this.content;
        } catch (err) {
          if (handler) {
            handler(err);
            return;
          }
          throw err;
        }
      }
      format(fileName, fileContent) {
        const fileBuffer = fileContent instanceof Buffer ? fileContent : Buffer.from(fileContent);
        this.buffer = fileBuffer;
        this.base64 = fileBuffer.toString("base64");
        this.createMetadata(fileName);
        return this;
      }
      createMetadata(fileName) {
        const { base64, mimetype = mimer_1.default(fileName) } = this;
        this.fileName = fileName;
        this.mimetype = mimetype;
        this.content = uriTemplate_1.uriParser({ base64, mimetype });
        return this;
      }
    };
    module.exports = DataURIParser;
  }
});

// .api/apis/zklighter/node_modules/datauri/sync.js
var require_sync = __commonJS({
  ".api/apis/zklighter/node_modules/datauri/sync.js"(exports, module) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var parser_1 = __importDefault(require_parser());
    var fs_1 = __importDefault(require_fs());
    function DataURISync(fileName) {
      if (!fileName || !fileName.trim || fileName.trim() === "") {
        throw new Error("Insert a File path as string argument");
      }
      const parser = new parser_1.default();
      if (fs_1.default.existsSync(fileName)) {
        const fileContent = fs_1.default.readFileSync(fileName);
        return parser.format(fileName, fileContent);
      }
      throw new Error(`The file ${fileName} was not found!`);
    }
    module.exports = DataURISync;
  }
});

// .api/apis/zklighter/node_modules/get-stream/buffer-stream.js
var require_buffer_stream = __commonJS({
  ".api/apis/zklighter/node_modules/get-stream/buffer-stream.js"(exports, module) {
    "use strict";
    var { PassThrough: PassThroughStream } = require_stream();
    module.exports = (options) => {
      options = { ...options };
      const { array } = options;
      let { encoding } = options;
      const isBuffer = encoding === "buffer";
      let objectMode = false;
      if (array) {
        objectMode = !(encoding || isBuffer);
      } else {
        encoding = encoding || "utf8";
      }
      if (isBuffer) {
        encoding = null;
      }
      const stream = new PassThroughStream({ objectMode });
      if (encoding) {
        stream.setEncoding(encoding);
      }
      let length = 0;
      const chunks = [];
      stream.on("data", (chunk) => {
        chunks.push(chunk);
        if (objectMode) {
          length = chunks.length;
        } else {
          length += chunk.length;
        }
      });
      stream.getBufferedValue = () => {
        if (array) {
          return chunks;
        }
        return isBuffer ? Buffer.concat(chunks, length) : chunks.join("");
      };
      stream.getBufferedLength = () => length;
      return stream;
    };
  }
});

// .api/apis/zklighter/node_modules/get-stream/index.js
var require_get_stream = __commonJS({
  ".api/apis/zklighter/node_modules/get-stream/index.js"(exports, module) {
    "use strict";
    var { constants: BufferConstants } = require_buffer();
    var stream = require_stream();
    var { promisify } = require_util();
    var bufferStream = require_buffer_stream();
    var streamPipelinePromisified = promisify(stream.pipeline);
    var MaxBufferError = class extends Error {
      constructor() {
        super("maxBuffer exceeded");
        this.name = "MaxBufferError";
      }
    };
    async function getStream(inputStream, options) {
      if (!inputStream) {
        throw new Error("Expected a stream");
      }
      options = {
        maxBuffer: Infinity,
        ...options
      };
      const { maxBuffer } = options;
      const stream2 = bufferStream(options);
      await new Promise((resolve, reject) => {
        const rejectPromise = (error) => {
          if (error && stream2.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
            error.bufferedData = stream2.getBufferedValue();
          }
          reject(error);
        };
        (async () => {
          try {
            await streamPipelinePromisified(inputStream, stream2);
            resolve();
          } catch (error) {
            rejectPromise(error);
          }
        })();
        stream2.on("data", () => {
          if (stream2.getBufferedLength() > maxBuffer) {
            rejectPromise(new MaxBufferError());
          }
        });
      });
      return stream2.getBufferedValue();
    }
    module.exports = getStream;
    module.exports.buffer = (stream2, options) => getStream(stream2, { ...options, encoding: "buffer" });
    module.exports.array = (stream2, options) => getStream(stream2, { ...options, array: true });
    module.exports.MaxBufferError = MaxBufferError;
  }
});

// .api/apis/zklighter/node_modules/lodash/merge.js
var require_merge = __commonJS({
  ".api/apis/zklighter/node_modules/lodash/merge.js"(exports, module) {
    var baseMerge = require_baseMerge();
    var createAssigner = require_createAssigner();
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });
    module.exports = merge;
  }
});

// .api/apis/zklighter/node_modules/api/dist/core/prepareParams.js
var require_prepareParams = __commonJS({
  ".api/apis/zklighter/node_modules/api/dist/core/prepareParams.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g2;
      return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
        return this;
      }), g2;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g2 && (g2 = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    exports.__esModule = true;
    var fs_1 = __importDefault(require_fs());
    var path_1 = __importDefault(require_path());
    var stream_1 = __importDefault(require_stream());
    var caseless_1 = __importDefault(require_caseless());
    var parser_1 = __importDefault(require_parser());
    var sync_1 = __importDefault(require_sync());
    var get_stream_1 = __importDefault(require_get_stream());
    var merge_1 = __importDefault(require_merge());
    var remove_undefined_objects_1 = __importDefault(require_dist4());
    var getJSONSchemaDefaults_1 = __importDefault(require_getJSONSchemaDefaults());
    var specialHeaders = ["accept", "authorization"];
    function digestParameters(parameters) {
      return parameters.reduce(function(prev, param) {
        var _a;
        if ("$ref" in param || "allOf" in param || "anyOf" in param || "oneOf" in param) {
          throw new Error("The OpenAPI document for this operation wasn't dereferenced before processing.");
        } else if (param.name in prev) {
          throw new Error("The operation you are using has the same parameter, ".concat(param.name, ", spread across multiple entry points. We unfortunately can't handle this right now."));
        }
        return Object.assign(prev, (_a = {}, _a[param.name] = param, _a));
      }, {});
    }
    function isEmpty(obj) {
      return [Object, Array].includes((obj || {}).constructor) && !Object.entries(obj || {}).length;
    }
    function isObject(thing) {
      if (thing instanceof stream_1["default"].Readable) {
        return false;
      }
      return typeof thing === "object" && thing !== null && !Array.isArray(thing);
    }
    function isPrimitive(obj) {
      return obj === null || typeof obj === "number" || typeof obj === "string";
    }
    function merge(src, target) {
      if (Array.isArray(target)) {
        return target;
      } else if (!isObject(target)) {
        return target;
      }
      return (0, merge_1["default"])(src, target);
    }
    function processFile(paramName, file) {
      var _this = this;
      if (typeof file === "string") {
        var resolvedFile_1 = path_1["default"].resolve(file);
        return new Promise(function(resolve, reject) {
          fs_1["default"].stat(resolvedFile_1, function(err) {
            return __awaiter(_this, void 0, void 0, function() {
              var fileMetadata, payloadFilename;
              return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    if (err) {
                      if (err.code === "ENOENT") {
                        return [2, resolve(void 0)];
                      }
                      return [2, reject(err)];
                    }
                    return [4, (0, sync_1["default"])(resolvedFile_1)];
                  case 1:
                    fileMetadata = _a.sent();
                    payloadFilename = encodeURIComponent(path_1["default"].basename(resolvedFile_1));
                    return [2, resolve({
                      paramName,
                      base64: fileMetadata.content.replace(";base64", ";name=".concat(payloadFilename, ";base64")),
                      filename: payloadFilename,
                      buffer: fileMetadata.buffer
                    })];
                }
              });
            });
          });
        });
      } else if (file instanceof stream_1["default"].Readable) {
        return get_stream_1["default"].buffer(file).then(function(buffer) {
          var filePath = file.path;
          var parser = new parser_1["default"]();
          var base64 = parser.format(filePath, buffer).content;
          var payloadFilename = encodeURIComponent(path_1["default"].basename(filePath));
          return {
            paramName,
            base64: base64.replace(";base64", ";name=".concat(payloadFilename, ";base64")),
            filename: payloadFilename,
            buffer
          };
        });
      }
      return Promise.reject(new TypeError(paramName ? "The data supplied for the `".concat(paramName, "` request body parameter is not a file handler that we support.") : "The data supplied for the request body payload is not a file handler that we support."));
    }
    function prepareParams(operation, body, metadata) {
      var _a, _b, _c, _d;
      return __awaiter(this, void 0, void 0, function() {
        var metadataIntersected, digestedParameters, jsonSchema, throwNoParamsError, bodyParams_1, jsonSchemaDefaults, params, headerParams_1, intersection, payloadJsonSchema, conversions_1;
        return __generator(this, function(_e) {
          switch (_e.label) {
            case 0:
              metadataIntersected = false;
              digestedParameters = digestParameters(operation.getParameters());
              jsonSchema = operation.getParametersAsJSONSchema();
              metadata = (0, remove_undefined_objects_1["default"])(metadata);
              if (!jsonSchema && (body !== void 0 || metadata !== void 0)) {
                throwNoParamsError = true;
                if (body !== void 0) {
                  if (typeof body === "object" && body !== null && !Array.isArray(body)) {
                    if (Object.keys(body).length <= 2) {
                      bodyParams_1 = (0, caseless_1["default"])(body);
                      if (specialHeaders.some(function(header) {
                        return bodyParams_1.has(header);
                      })) {
                        throwNoParamsError = false;
                      }
                    }
                  }
                }
                if (throwNoParamsError) {
                  throw new Error("You supplied metadata and/or body data for this operation but it doesn't have any documented parameters or request payloads. If you think this is an error please contact support for the API you're using.");
                }
              }
              jsonSchemaDefaults = jsonSchema ? (0, getJSONSchemaDefaults_1["default"])(jsonSchema) : {};
              params = jsonSchemaDefaults;
              if (typeof body !== "undefined") {
                if (Array.isArray(body) || isPrimitive(body)) {
                  params.body = merge(params.body, body);
                } else if (typeof metadata === "undefined") {
                  headerParams_1 = (0, caseless_1["default"])({});
                  Object.entries(digestedParameters).forEach(function(_a2) {
                    var paramName = _a2[0], param = _a2[1];
                    if (param["in"] === "header") {
                      headerParams_1.set(paramName, "");
                    }
                  });
                  specialHeaders.forEach(function(header) {
                    if (!headerParams_1.has(header)) {
                      headerParams_1.set(header, "");
                    }
                  });
                  intersection = Object.keys(body).filter(function(value) {
                    if (Object.keys(digestedParameters).includes(value)) {
                      return true;
                    } else if (headerParams_1.has(value)) {
                      return true;
                    }
                    return false;
                  }).length;
                  if (intersection && intersection / Object.keys(body).length > 0.25) {
                    metadataIntersected = true;
                    metadata = merge(params.body, body);
                    body = void 0;
                  } else {
                    params.body = merge(params.body, body);
                  }
                } else {
                  params.body = merge(params.body, body);
                }
              }
              if (!!operation.hasRequestBody()) return [3, 1];
              delete params.body;
              return [3, 3];
            case 1:
              if (!("body" in params))
                params.body = {};
              payloadJsonSchema = jsonSchema.find(function(js) {
                return js.type === "body";
              });
              if (!payloadJsonSchema) return [3, 3];
              if (!params.files)
                params.files = {};
              conversions_1 = [];
              if ((_a = payloadJsonSchema.schema) === null || _a === void 0 ? void 0 : _a.properties) {
                Object.entries((_b = payloadJsonSchema.schema) === null || _b === void 0 ? void 0 : _b.properties).filter(function(_a2) {
                  var schema = _a2[1];
                  return (schema === null || schema === void 0 ? void 0 : schema.format) === "binary";
                }).filter(function(_a2) {
                  var prop = _a2[0];
                  return Object.keys(params.body).includes(prop);
                }).forEach(function(_a2) {
                  var prop = _a2[0];
                  conversions_1.push(processFile(prop, params.body[prop]));
                });
              } else if (((_c = payloadJsonSchema.schema) === null || _c === void 0 ? void 0 : _c.type) === "string") {
                if (((_d = payloadJsonSchema.schema) === null || _d === void 0 ? void 0 : _d.format) === "binary") {
                  conversions_1.push(processFile(void 0, params.body));
                }
              }
              return [4, Promise.all(conversions_1).then(function(fileMetadata) {
                return fileMetadata.filter(Boolean);
              }).then(function(fm) {
                fm.forEach(function(fileMetadata) {
                  if (!fileMetadata) {
                    return;
                  }
                  if (fileMetadata.paramName) {
                    params.body[fileMetadata.paramName] = fileMetadata.base64;
                  } else {
                    params.body = fileMetadata.base64;
                  }
                  params.files[fileMetadata.filename] = fileMetadata.buffer;
                });
              })];
            case 2:
              _e.sent();
              _e.label = 3;
            case 3:
              if (operation.isFormUrlEncoded()) {
                params.formData = merge(params.formData, params.body);
                delete params.body;
              }
              if (typeof metadata !== "undefined") {
                if (!("cookie" in params))
                  params.cookie = {};
                if (!("header" in params))
                  params.header = {};
                if (!("path" in params))
                  params.path = {};
                if (!("query" in params))
                  params.query = {};
                Object.entries(digestedParameters).forEach(function(_a2) {
                  var paramName = _a2[0], param = _a2[1];
                  var value;
                  var metadataHeaderParam;
                  if (typeof metadata === "object" && !isEmpty(metadata)) {
                    if (paramName in metadata) {
                      value = metadata[paramName];
                      metadataHeaderParam = paramName;
                    } else if (param["in"] === "header") {
                      metadataHeaderParam = Object.keys(metadata).find(function(k) {
                        return k.toLowerCase() === paramName.toLowerCase();
                      });
                      value = metadata[metadataHeaderParam];
                    }
                  }
                  if (value === void 0) {
                    return;
                  }
                  switch (param["in"]) {
                    case "path":
                      params.path[paramName] = value;
                      delete metadata[paramName];
                      break;
                    case "query":
                      params.query[paramName] = value;
                      delete metadata[paramName];
                      break;
                    case "header":
                      params.header[paramName.toLowerCase()] = value;
                      delete metadata[metadataHeaderParam];
                      break;
                    case "cookie":
                      params.cookie[paramName] = value;
                      delete metadata[paramName];
                      break;
                    default:
                  }
                  if (metadataIntersected && operation.isFormUrlEncoded()) {
                    if (paramName in params.formData) {
                      delete params.formData[paramName];
                    }
                  }
                });
                if (!isEmpty(metadata)) {
                  if (typeof metadata === "object") {
                    specialHeaders.forEach(function(headerName) {
                      var headerParam = Object.keys(metadata).find(function(m) {
                        return m.toLowerCase() === headerName;
                      });
                      if (headerParam) {
                        params.header[headerName] = metadata[headerParam];
                        delete metadata[headerParam];
                      }
                    });
                  }
                  if (operation.isFormUrlEncoded()) {
                    params.formData = merge(params.formData, metadata);
                  } else {
                  }
                }
              }
              ["body", "cookie", "files", "formData", "header", "path", "query"].forEach(function(type) {
                if (type in params && isEmpty(params[type])) {
                  delete params[type];
                }
              });
              return [2, params];
          }
        });
      });
    }
    exports["default"] = prepareParams;
  }
});

// .api/apis/zklighter/node_modules/api/dist/core/prepareServer.js
var require_prepareServer = __commonJS({
  ".api/apis/zklighter/node_modules/api/dist/core/prepareServer.js"(exports) {
    "use strict";
    exports.__esModule = true;
    function stripTrailingSlash(url) {
      if (url[url.length - 1] === "/") {
        return url.slice(0, -1);
      }
      return url;
    }
    function prepareServer(spec, url, variables) {
      if (variables === void 0) {
        variables = {};
      }
      var serverIdx;
      var sanitizedUrl = stripTrailingSlash(url);
      (spec.api.servers || []).forEach(function(server2, i) {
        if (server2.url === sanitizedUrl) {
          serverIdx = i;
        }
      });
      if (serverIdx) {
        return {
          selected: serverIdx,
          variables
        };
      } else if (Object.keys(variables).length) {
      } else {
        var server = spec.splitVariables(url);
        if (server) {
          return {
            selected: server.selected,
            variables: server.variables
          };
        }
      }
      return false;
    }
    exports["default"] = prepareServer;
  }
});

// .api/apis/zklighter/node_modules/api/dist/core/index.js
var require_core = __commonJS({
  ".api/apis/zklighter/node_modules/api/dist/core/index.js"(exports) {
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g2;
      return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
        return this;
      }), g2;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g2 && (g2 = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    exports.__esModule = true;
    exports.prepareServer = exports.prepareParams = exports.prepareAuth = exports.parseResponse = exports.getJSONSchemaDefaults = void 0;
    var oas_to_har_1 = __importDefault(require_dist5());
    var fetch_har_1 = __importDefault(require_dist6());
    var form_data_encoder_1 = require_cjs();
    require_fetch_npm_browserify();
    var node_abort_controller_1 = require_browser3();
    var fetchError_1 = __importDefault(require_fetchError());
    var getJSONSchemaDefaults_1 = __importDefault(require_getJSONSchemaDefaults());
    exports.getJSONSchemaDefaults = getJSONSchemaDefaults_1["default"];
    var parseResponse_1 = __importDefault(require_parseResponse());
    exports.parseResponse = parseResponse_1["default"];
    var prepareAuth_1 = __importDefault(require_prepareAuth());
    exports.prepareAuth = prepareAuth_1["default"];
    var prepareParams_1 = __importDefault(require_prepareParams());
    exports.prepareParams = prepareParams_1["default"];
    var prepareServer_1 = __importDefault(require_prepareServer());
    exports.prepareServer = prepareServer_1["default"];
    var APICore = (
      /** @class */
      function() {
        function APICore2(spec, userAgent) {
          this.auth = [];
          this.server = false;
          this.config = {};
          this.spec = spec;
          this.userAgent = userAgent;
        }
        APICore2.prototype.setSpec = function(spec) {
          this.spec = spec;
        };
        APICore2.prototype.setConfig = function(config) {
          this.config = config;
          return this;
        };
        APICore2.prototype.setUserAgent = function(userAgent) {
          this.userAgent = userAgent;
          return this;
        };
        APICore2.prototype.setAuth = function() {
          var values = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            values[_i] = arguments[_i];
          }
          this.auth = values;
          return this;
        };
        APICore2.prototype.setServer = function(url, variables) {
          if (variables === void 0) {
            variables = {};
          }
          this.server = { url, variables };
          return this;
        };
        APICore2.prototype.fetch = function(path, method, body, metadata) {
          return __awaiter(this, void 0, void 0, function() {
            var operation;
            return __generator(this, function(_a) {
              operation = this.spec.operation(path, method);
              return [2, this.fetchOperation(operation, body, metadata)];
            });
          });
        };
        APICore2.prototype.fetchOperation = function(operation, body, metadata) {
          return __awaiter(this, void 0, void 0, function() {
            var _this = this;
            return __generator(this, function(_a) {
              return [2, (0, prepareParams_1["default"])(operation, body, metadata).then(function(params) {
                var data = __assign({}, params);
                if (_this.server) {
                  var preparedServer = (0, prepareServer_1["default"])(_this.spec, _this.server.url, _this.server.variables);
                  if (preparedServer) {
                    data.server = preparedServer;
                  }
                }
                var har = (0, oas_to_har_1["default"])(_this.spec, operation, data, (0, prepareAuth_1["default"])(_this.auth, operation));
                var timeoutSignal;
                var init = {};
                if (_this.config.timeout) {
                  var controller_1 = new node_abort_controller_1.AbortController();
                  timeoutSignal = setTimeout(function() {
                    return controller_1.abort();
                  }, _this.config.timeout);
                  init.signal = controller_1.signal;
                }
                return (0, fetch_har_1["default"])(har, {
                  files: data.files || {},
                  init,
                  multipartEncoder: form_data_encoder_1.FormDataEncoder,
                  userAgent: _this.userAgent
                }).then(function(res) {
                  return __awaiter(_this, void 0, void 0, function() {
                    var parsed;
                    return __generator(this, function(_a2) {
                      switch (_a2.label) {
                        case 0:
                          return [4, (0, parseResponse_1["default"])(res)];
                        case 1:
                          parsed = _a2.sent();
                          if (res.status >= 400 && res.status <= 599) {
                            throw new fetchError_1["default"](parsed.status, parsed.data, parsed.headers, parsed.res);
                          }
                          return [2, parsed];
                      }
                    });
                  });
                })["finally"](function() {
                  if (_this.config.timeout) {
                    clearTimeout(timeoutSignal);
                  }
                });
              })];
            });
          });
        };
        return APICore2;
      }()
    );
    exports["default"] = APICore;
  }
});
export default require_core();
/*! Bundled license information:

@readme/oas-to-har/dist/lib/style-formatting/style-serializer.js:
  (**
   * This file has been extracted and modified from `swagger-client`.
   *
   * @license Apache 2.0
   * @link https://npm.im/swagger-client
   * @link https://github.com/swagger-api/swagger-js/blob/master/src/execute/oas3/style-serializer.js
   *)

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

fetch-har/dist/index.js:
  (**
   * @license MIT
   * @see {@link https://github.com/octet-stream/form-data-encoder/blob/master/lib/util/isFunction.ts}
   *)
  (**
   * We're using this library in here instead of loading it from `form-data-encoder` because that
   * uses lookbehind regex in its main encoder that Safari doesn't support so it throws a fatal page
   * exception.
   *
   * @license MIT
   * @see {@link https://github.com/octet-stream/form-data-encoder/blob/master/lib/util/isFormData.ts}
   *)
*/
//# sourceMappingURL=api_dist_core.js.map
